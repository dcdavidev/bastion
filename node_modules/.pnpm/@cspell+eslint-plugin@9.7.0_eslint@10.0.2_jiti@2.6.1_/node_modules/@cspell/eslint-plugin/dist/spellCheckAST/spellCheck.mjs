// cspell:ignore TSESTree
import assert from 'node:assert';
import * as path from 'node:path';
import { toFileDirURL, toFileURL } from '@cspell/url';
import { createTextDocument, DocumentValidator, extractImportErrors, getDictionary, refreshDictionaryCache, } from 'cspell-lib';
import { getDefaultLogger } from '../common/logger.cjs';
import { defaultOptions } from '../common/options.cjs';
const ALLOWED_ISSUES_FOR_FLAGGED = new Set(['Forbidden']);
const ALLOWED_ISSUES_FOR_TYPOS = new Set([...ALLOWED_ISSUES_FOR_FLAGGED, 'Misspelled']);
const defaultSettings = {
    name: 'eslint-configuration-file',
    patterns: [
    // @todo: be able to use cooked / transformed strings.
    // {
    //     // Do not block unicode escape sequences.
    //     name: 'js-unicode-escape',
    //     pattern: /$^/g,
    // },
    ],
};
const isDebugModeExtended = false;
const forceLogging = false;
const knownConfigErrors = new Set();
export async function spellCheck(filename, text, ranges, options) {
    const logger = getDefaultLogger();
    const debugMode = forceLogging || options.debugMode || false;
    logger.enabled = forceLogging || (options.debugMode ?? (logger.enabled || isDebugModeExtended));
    const log = logger.log;
    const filterIssues = generateReportingPredicate(options.report);
    log('options: %o', options);
    const validator = getDocValidator(filename, text, options);
    await validator.prepare();
    log('Settings: %o', validator.settings);
    const errors = [...validator.errors];
    errors.push(...(await checkSettings()));
    const issues = ranges
        .map((range, idx) => {
        const issues = validator
            .checkText(range, undefined, undefined)
            .map((issue) => normalizeIssue(issue, range, idx))
            .filter(filterIssues);
        return issues.length ? issues : undefined;
    })
        .filter((issues) => !!issues)
        .flat();
    return { issues, errors };
    async function checkSettings() {
        const finalSettings = validator.getFinalizedDocSettings();
        const found = await reportConfigurationErrors(finalSettings, knownConfigErrors);
        found.forEach((err) => (debugMode ? log(err) : log('Error: %s', err.message)));
        return found;
    }
    function normalizeIssue(issue, range, rangeIdx) {
        const { text: word, offset: start, suggestionsEx: suggestions } = issue;
        const end = issue.offset + (issue.length || issue.text.length);
        let severity = 'Unknown';
        severity = issue.hasPreferredSuggestions ? 'Misspelled' : severity;
        severity = issue.isFlagged ? 'Forbidden' : severity;
        const hasPreferredFixes = issue.hasPreferredSuggestions || false;
        const hasSimpleSuggestions = issue.hasSimpleSuggestions || false;
        return { word, start, end, suggestions, severity, range, rangeIdx, hasPreferredFixes, hasSimpleSuggestions };
    }
}
function generateReportingPredicate(report) {
    switch (report) {
        case 'simple': {
            return (issue) => ALLOWED_ISSUES_FOR_TYPOS.has(issue.severity) ||
                (issue.severity === 'Unknown' && issue.hasSimpleSuggestions);
        }
        case 'flagged': {
            return (issue) => ALLOWED_ISSUES_FOR_FLAGGED.has(issue.severity);
        }
        case 'typos': {
            return (issue) => ALLOWED_ISSUES_FOR_TYPOS.has(issue.severity);
        }
    }
    // report === 'all' or undefined
    return () => true;
}
const cache = { lastDoc: undefined };
const docValCache = new WeakMap();
function getDocValidator(filename, text, options) {
    const doc = getTextDocument(filename, text);
    const settings = calcInitialSettings(options);
    const cachedValidator = docValCache.get(doc);
    if (cachedValidator && deepEqual(cachedValidator.settings, settings)) {
        refreshDictionaryCache(0);
        cachedValidator.updateDocumentText(text).catch(() => undefined);
        return cachedValidator;
    }
    const resolveImportsRelativeTo = toFileURL(options.cspellOptionsRoot || import.meta.url, toFileDirURL(options.cwd));
    const report = options.report || 'all';
    const generateSuggestions = report && report !== 'all'
        ? (options.generateSuggestions ?? false)
        : (options.generateSuggestions ?? defaultOptions.generateSuggestions);
    const validator = new DocumentValidator(doc, { ...options, resolveImportsRelativeTo, generateSuggestions }, settings);
    docValCache.set(doc, validator);
    return validator;
}
export const mapReportToUnknownWordChoices = {
    all: 'report-all',
    simple: 'report-simple',
    typos: 'report-common-typos',
    flagged: 'report-flagged',
};
function mapReportToUnknownWords(report) {
    const unknownWords = report ? mapReportToUnknownWordChoices[report] : undefined;
    return unknownWords ? { unknownWords } : {};
}
function calcInitialSettings(options) {
    const { customWordListFile, cspell, cwd } = options;
    const settings = {
        ...defaultSettings,
        ...cspell,
        words: cspell?.words || [],
        ignoreWords: cspell?.ignoreWords || [],
        flagWords: cspell?.flagWords || [],
        ...mapReportToUnknownWords(options.report),
    };
    if (options.configFile) {
        const optionCspellImport = options.cspell?.import;
        const importConfig = typeof optionCspellImport === 'string'
            ? [optionCspellImport]
            : Array.isArray(optionCspellImport)
                ? optionCspellImport
                : [];
        importConfig.push(options.configFile);
        settings.import = importConfig;
    }
    if (customWordListFile) {
        const filePath = isCustomWordListFile(customWordListFile) ? customWordListFile.path : customWordListFile;
        const { dictionaries = [], dictionaryDefinitions = [] } = settings;
        dictionaries.push('eslint-plugin-custom-words');
        dictionaryDefinitions.push({ name: 'eslint-plugin-custom-words', path: filePath });
        settings.dictionaries = dictionaries;
        settings.dictionaryDefinitions = dictionaryDefinitions;
    }
    resolveDictionaryPaths(settings.dictionaryDefinitions, cwd);
    return settings;
}
const regexIsUrl = /^(https?|file|ftp):/i;
/** Patches the path of dictionary definitions. */
function resolveDictionaryPaths(defs, cwd) {
    if (!defs)
        return;
    for (const def of defs) {
        if (!def.path)
            continue;
        if (regexIsUrl.test(def.path))
            continue;
        def.path = path.resolve(cwd, def.path);
    }
}
function getTextDocument(filename, content) {
    if (cache.lastDoc?.filename === filename) {
        return cache.lastDoc.doc;
    }
    const doc = createTextDocument({ uri: filename, content });
    cache.lastDoc = { filename, doc };
    return doc;
}
function isCustomWordListFile(value) {
    return !!value && typeof value === 'object';
}
/**
 * Deep Equal check.
 * Note: There are faster methods, but this is called once per file, so speed is not a concern.
 */
function deepEqual(a, b) {
    try {
        assert.deepStrictEqual(a, b);
        return true;
    }
    catch {
        return false;
    }
}
async function reportConfigurationErrors(config, knownConfigErrors) {
    const errors = [];
    const importErrors = extractImportErrors(config);
    importErrors.forEach((ref) => {
        const key = ref.error.toString();
        if (knownConfigErrors.has(key))
            return;
        knownConfigErrors.add(key);
        errors.push(new Error('Configuration Error: \n  ' + ref.error.message));
    });
    const dictCollection = await getDictionary(config);
    dictCollection.dictionaries.forEach((dict) => {
        const dictErrors = dict.getErrors?.() || [];
        const msg = `Dictionary Error with (${dict.name})`;
        dictErrors.forEach((error) => {
            const key = msg + error.toString();
            if (knownConfigErrors.has(key))
                return;
            knownConfigErrors.add(key);
            const errMsg = `${msg}: ${error.message}\n  Source: ${dict.source}`;
            errors.push(new Error(errMsg));
        });
    });
    return errors;
}
//# sourceMappingURL=spellCheck.mjs.map