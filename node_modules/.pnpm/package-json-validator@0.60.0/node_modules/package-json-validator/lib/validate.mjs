import { validateFieldType } from "./utils/validateFieldType.mjs";
import { validateAuthor } from "./validators/validateAuthor.mjs";
import { validateBin } from "./validators/validateBin.mjs";
import { validateBundleDependencies } from "./validators/validateBundleDependencies.mjs";
import { validateConfig } from "./validators/validateConfig.mjs";
import { validateContributors } from "./validators/validateContributors.mjs";
import { validateCpu } from "./validators/validateCpu.mjs";
import { validateDependencies } from "./validators/validateDependencies.mjs";
import { validateDescription } from "./validators/validateDescription.mjs";
import { validateDirectories } from "./validators/validateDirectories.mjs";
import { validateEngines } from "./validators/validateEngines.mjs";
import { validateExports } from "./validators/validateExports.mjs";
import { validateFiles } from "./validators/validateFiles.mjs";
import { validateHomepage } from "./validators/validateHomepage.mjs";
import { validateKeywords } from "./validators/validateKeywords.mjs";
import { validateLicense } from "./validators/validateLicense.mjs";
import { validateMain } from "./validators/validateMain.mjs";
import { validateMan } from "./validators/validateMan.mjs";
import { validateName } from "./validators/validateName.mjs";
import { validateOs } from "./validators/validateOs.mjs";
import { validatePrivate } from "./validators/validatePrivate.mjs";
import { validatePublishConfig } from "./validators/validatePublishConfig.mjs";
import { validateRepository } from "./validators/validateRepository.mjs";
import { validateScripts } from "./validators/validateScripts.mjs";
import { validateSideEffects } from "./validators/validateSideEffects.mjs";
import { validateType } from "./validators/validateType.mjs";
import { validateUrlOrMailto } from "./validators/validateUrlOrMailto.mjs";
import { validateVersion } from "./validators/validateVersion.mjs";
import { validateWorkspaces } from "./validators/validateWorkspaces.mjs";

//#region src/validate.ts
const getSpecMap = (isPrivate) => ({
	author: {
		validate: (_, value) => validateAuthor(value).errorMessages,
		warning: true
	},
	bin: { validate: (_, value) => validateBin(value).errorMessages },
	bugs: {
		validate: validateUrlOrMailto,
		warning: true
	},
	bundledDependencies: { validate: (_, value) => validateBundleDependencies(value).errorMessages },
	bundleDependencies: { validate: (_, value) => validateBundleDependencies(value).errorMessages },
	config: { validate: (_, value) => validateConfig(value).errorMessages },
	contributors: { validate: (_, value) => validateContributors(value).errorMessages },
	cpu: { validate: (_, value) => validateCpu(value).errorMessages },
	dependencies: {
		recommended: true,
		validate: (_, value) => validateDependencies(value).errorMessages
	},
	description: {
		validate: (_, value) => validateDescription(value).errorMessages,
		warning: true
	},
	devDependencies: { validate: (_, value) => validateDependencies(value).errorMessages },
	directories: { validate: (_, value) => validateDirectories(value).errorMessages },
	engines: {
		recommended: true,
		validate: (_, value) => validateEngines(value).errorMessages
	},
	exports: { validate: (_, value) => validateExports(value).errorMessages },
	files: { validate: (_, value) => validateFiles(value).errorMessages },
	homepage: {
		recommended: true,
		validate: (_, value) => validateHomepage(value).errorMessages
	},
	keywords: {
		validate: (_, value) => validateKeywords(value).errorMessages,
		warning: true
	},
	license: {
		validate: (_, value) => validateLicense(value).errorMessages,
		warning: true
	},
	main: { validate: (_, value) => validateMain(value).errorMessages },
	man: { validate: (_, value) => validateMan(value).errorMessages },
	name: {
		required: !isPrivate,
		validate: (_, value) => validateName(value).errorMessages
	},
	optionalDependencies: { validate: (_, value) => validateDependencies(value).errorMessages },
	os: { validate: (_, value) => validateOs(value).errorMessages },
	peerDependencies: { validate: (_, value) => validateDependencies(value).errorMessages },
	private: { validate: (_, value) => validatePrivate(value).errorMessages },
	publishConfig: { validate: (_, value) => validatePublishConfig(value).errorMessages },
	repository: {
		validate: (_, value) => validateRepository(value).errorMessages,
		warning: true
	},
	scripts: { validate: (_, value) => validateScripts(value).errorMessages },
	sideEffects: { validate: (_, value) => validateSideEffects(value).errorMessages },
	type: {
		recommended: true,
		validate: (_, value) => validateType(value).errorMessages
	},
	version: {
		required: !isPrivate,
		validate: (_, value) => validateVersion(value).errorMessages
	},
	workspaces: { validate: (_, value) => validateWorkspaces(value).errorMessages }
});
const parse = (data) => {
	if (typeof data != "string") return "Invalid data - Not a string";
	let parsed;
	try {
		parsed = JSON.parse(data);
	} catch (e) {
		let errorMessage = "Invalid JSON";
		if (e instanceof Error) errorMessage = `Invalid JSON - ${e.toString()}`;
		return errorMessage;
	}
	if (typeof parsed !== "object" || parsed === null || parsed instanceof Array) return `Invalid JSON - not an object (actual type: ${typeof parsed})`;
	return parsed;
};
/**
* Validate a package.json object (or string) against the npm spec.
* @param data The package.json data to validate, either as a string or an object.
* @param options The options for validation, if using the deprecated spec name parameter.
* @returns an object with the validation results.
*/
const validate = (data, options = {}) => {
	const parsed = typeof data == "object" ? data : parse(data);
	const out = { valid: false };
	if (typeof parsed == "string") {
		out.critical = parsed;
		return out;
	}
	const map = getSpecMap(parsed.private ?? false);
	const errors = [];
	const warnings = [];
	const recommendations = [];
	let name;
	for (name in map) {
		const field = map[name];
		if (parsed[name] === void 0 && (!field.or || field.or && parsed[field.or] === void 0)) {
			if (field.required) errors.push({
				field: name,
				message: `Missing required field: ${name}`
			});
			else if (field.warning) warnings.push(`Missing recommended field: ${name}`);
			else if (field.recommended) recommendations.push(`Missing optional field: ${name}`);
			continue;
		} else if (parsed[name] === void 0) continue;
		if (field.types || field.type) {
			const typeErrors = validateFieldType(name, field, parsed[name]);
			if (typeErrors.length > 0) {
				errors.push(...typeErrors.map((e) => ({
					field: name,
					message: e
				})));
				continue;
			}
		}
		if (field.format && !field.format.test(parsed[name])) errors.push({
			field: name,
			message: `Value for field ${name}, ${parsed[name]} does not match format: ${field.format.toString()}`
		});
		if (field.validate && typeof field.validate === "function") errors.push(...field.validate(name, parsed[name]).map((e) => ({
			field: name,
			message: e
		})));
	}
	out.valid = errors.length > 0 ? false : true;
	if (errors.length > 0) out.errors = errors;
	if (options.warnings !== false && warnings.length > 0) out.warnings = warnings;
	if (options.recommendations !== false && recommendations.length > 0) out.recommendations = recommendations;
	return out;
};

//#endregion
export { validate };