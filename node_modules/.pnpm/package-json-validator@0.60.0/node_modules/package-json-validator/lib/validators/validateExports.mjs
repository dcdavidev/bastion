import { Result } from "../Result.mjs";

//#region src/validators/validateExports.ts
const validateExportCondition = (obj, propertyName, index) => {
	const result = new Result();
	const normalizedKey = typeof propertyName === "string" && propertyName.trim();
	const fieldName = normalizedKey === "" ? `property ${String(index)}` : `"${normalizedKey}"`;
	if (typeof obj === "string") {
		if (obj.trim() === "") if (typeof propertyName === "string") result.addIssue(`the value of ${fieldName} is empty, but should be an entry point path`);
		else result.addIssue("the value is empty, but should be an entry point path");
	} else if (obj && typeof obj === "object" && !Array.isArray(obj)) {
		const entries = Object.entries(obj);
		for (let i = 0; i < entries.length; i++) {
			const [key, value] = entries[i];
			const childResult = validateExportCondition(value, key, i);
			if (key.trim() === "") childResult.addIssue(`property ${i} has an empty key, but should be an export condition`);
			result.addChildResult(i, childResult);
		}
	} else if (typeof propertyName === "string") result.addIssue(`the value of ${fieldName} should be either an entry point path or an object of export conditions`);
	else if (obj === null) result.addIssue("the value is `null`, but should be an `object` or `string`");
	else {
		const valueType = Array.isArray(obj) ? "Array" : typeof obj;
		result.addIssue(`the type should be \`object\` or \`string\`, not \`${valueType}\``);
	}
	return result;
};
/**
* Validate the `exports` field in a package.json. The value of
* should be either a string or a Record&lt;string, object | string&gt;
*/
const validateExports = (obj) => validateExportCondition(obj);

//#endregion
export { validateExports };