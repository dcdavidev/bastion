//#region src/Result.ts
/** Top-level result, returned from a validator function */
var Result = class {
	/** Equivalent of the previous return type, the full collection of error messages (including errors from child properties) */
	get errorMessages() {
		let errorMessages = this.#issues.map((issue) => issue.message);
		for (const childResult of this.#childResults) errorMessages = errorMessages.concat(childResult.errorMessages);
		return errorMessages;
	}
	#issues;
	/** Collection of issues for *this* object (property or array element) */
	get issues() {
		return this.#issues;
	}
	#childResults;
	/** Collection of result objects for child elements (either properties or array elements), if this property is an object or array */
	get childResults() {
		return this.#childResults;
	}
	/**
	* Create a Result object from the issues for this property value and an array of child results.
	* The resulting object's `errorMessages` property will be a combination of the `message` properties of its issues, and the `errorMessages` props of its children.
	* @param issuesOrMessages the collection of issues from this property value
	* @param childResults results from child property values
	*/
	constructor(issuesOrMessages = [], childResults = []) {
		const issues = issuesOrMessages.map((item) => typeof item === "string" ? { message: item } : item);
		this.#childResults = childResults;
		this.#issues = issues;
	}
	addChildResult(indexOrChild, child = []) {
		let newChild;
		if (indexOrChild instanceof ChildResult) newChild = indexOrChild;
		else if (typeof child === "string") {
			const childResult = new ChildResult(indexOrChild);
			childResult.addIssue(child);
			newChild = childResult;
		} else if (Array.isArray(child)) {
			const childResult = new ChildResult(indexOrChild);
			for (const issueString of child) childResult.addIssue(issueString);
			newChild = childResult;
		} else newChild = new ChildResult(indexOrChild, child);
		this.#childResults.push(newChild);
	}
	/**
	* Creates a new {@link Issue} and adds it to this Result.
	*/
	addIssue(message) {
		this.#issues.push({ message });
	}
	/**
	* Flattens this Result object (along with all child results) and pulls all issues from flattened child results into the top-level result.
	*/
	flatten() {
		const flattenedIssues = [...this.#issues];
		for (const childResult of this.#childResults) {
			const flattenedChild = childResult.flatten();
			flattenedIssues.push(...flattenedChild.issues);
		}
		this.#issues = flattenedIssues;
		this.#childResults = [];
		return this;
	}
};
/** Result object for a child (either a property in an object or an element of an array) */
var ChildResult = class extends Result {
	#index;
	/** The index of this property in relation to its parent's collection (properties or array elements) */
	get index() {
		return this.#index;
	}
	constructor(index, issuesOrMessagesOrResult = [], childResults = []) {
		if (issuesOrMessagesOrResult instanceof Result) super(issuesOrMessagesOrResult.issues, issuesOrMessagesOrResult.childResults);
		else super(issuesOrMessagesOrResult, childResults);
		this.#index = index;
	}
};

//#endregion
export { ChildResult, Result };