import { t as __exportAll } from "./chunk-C7Uep-_p.mjs";
import Module, { createRequire } from "node:module";
import * as jsonParser from "jsonc-eslint-parser";
import { getStaticJSONValue } from "jsonc-eslint-parser";
import { toCompatCreate } from "eslint-json-compat-utils";
import semver, { Range, SemVer, inc, intersects, lt, satisfies, subset } from "semver";
import path from "node:path";
import fs from "node:fs";
import npa from "npm-package-arg";
import { createSyncFn } from "synckit";
import { fileURLToPath } from "node:url";

//#region lib/utils/ast-utils.ts
/**
* Get the key from given object property node
*/
function getKeyFromJSONProperty(node) {
	if (node.key.type === "JSONIdentifier") return node.key.name;
	return node.key.value;
}
/**
* Get the key from given object node
*/
function getKey(node) {
	let parent = node.parent;
	while (parent.type === "JSONUnaryExpression" || parent.type === "JSONBinaryExpression") parent = parent.parent;
	if (parent.type === "JSONExpressionStatement") return null;
	if (parent.type === "JSONArrayExpression") return parent.elements.indexOf(node);
	return getKeyFromJSONProperty(parent);
}

//#endregion
//#region lib/utils/index.ts
/**
* Define the rule.
* @param ruleName ruleName
* @param rule rule module
*/
function createRule(ruleName, rule) {
	const docs = {
		...rule.meta.docs,
		url: `https://ota-meshi.github.io/eslint-plugin-node-dependencies/rules/${ruleName}.html`,
		ruleId: `node-dependencies/${ruleName}`,
		ruleName
	};
	return {
		meta: {
			...rule.meta,
			docs
		},
		create: toCompatCreate(rule.create)
	};
}
/**
* Define the JSON visitor rule.
*/
function defineJsonVisitor(visitor) {
	let stack = null;
	const visitors = [];
	for (const [selector, visit] of Object.entries(visitor)) if (visit) for (const sel of selector.split(",").map((s) => s.trim())) visitors.push({
		test: (s) => {
			if (!s.key || !s.upper || s.upper.key != null) return false;
			return s.key === sel;
		},
		visit
	});
	return {
		"JSONObjectExpression, JSONArrayExpression"(node) {
			stack = {
				node,
				upper: stack,
				key: getKey(node)
			};
		},
		"JSONObjectExpression, JSONArrayExpression:exit"() {
			stack = stack && stack.upper;
		},
		JSONProperty(node) {
			if (!stack) return;
			for (const v of visitors) if (v.test(stack)) v.visit(node);
		}
	};
}
/**
* Composite all given visitors.
*/
function compositingVisitors(visitor, ...visitors) {
	for (const v of visitors) for (const key in v) {
		const orig = visitor[key];
		if (orig) visitor[key] = (...args) => {
			orig(...args);
			v[key](...args);
		};
		else visitor[key] = v[key];
	}
	return visitor;
}

//#endregion
//#region lib/utils/regexp.ts
/**
* Convert to regexp
*/
function toRegExp(str) {
	const regexp = parseRegExp(str);
	if (regexp) return regexp;
	return { test: (s) => s === str };
}
/**
* Parse regexp string
*/
function parseRegExp(str) {
	if (!str.startsWith("/")) return null;
	const lastSlashIndex = str.lastIndexOf("/");
	if (lastSlashIndex <= 1) return null;
	return new RegExp(str.slice(1, lastSlashIndex), str.slice(lastSlashIndex + 1));
}

//#endregion
//#region lib/utils/semver.ts
/** Get the semver range instance from given value */
function getSemverRange(value) {
	if (value == null) return null;
	try {
		return new Range(value);
	} catch {
		return null;
	}
}
/** Normalize version */
function normalizeVer(ver) {
	const n = normalizeSemverRange(ver);
	if (n) return n.raw;
	return ver.raw;
}
/** Normalize semver ranges. */
function normalizeSemverRange(...values) {
	const map = /* @__PURE__ */ new Map();
	for (const ver of values) for (const comparators of ver.set) {
		const normalized = normalizeComparators(comparators);
		if (map.has(normalized)) continue;
		const normalizedVer = getSemverRange(normalized);
		if (!normalizedVer) continue;
		let consume = false;
		let target = {
			range: normalizedVer,
			comparators
		};
		for (const [k, data] of map) {
			if (subset(target.range, data.range)) {
				consume = true;
				break;
			}
			if (subset(data.range, target.range)) map.delete(k);
			if (intersects(target.range, data.range)) {
				const newComparators = joinComparators(comparators, data.comparators);
				if (newComparators) {
					target = {
						range: new Range(normalizeComparators(newComparators)),
						comparators: newComparators
					};
					map.delete(k);
				}
			}
		}
		if (consume) continue;
		map.set(target.range.raw, target);
	}
	return getSemverRange([...map].sort(([, a], [, b]) => {
		const aVer = getMinVer(a.comparators);
		const bVer = getMinVer(b.comparators);
		return aVer.compare(bVer);
	}).map(([v]) => v).join("||"));
	/** Get min version */
	function getMinVer(comparators) {
		let min = null;
		for (const comp of comparators) if (!min || comp.semver.compare(min) < 0) min = comp.semver;
		return min;
	}
}
/** Normalize comparators */
function normalizeComparators(comparators) {
	const rangeComparator = toRangeComparator(comparators);
	if (rangeComparator && rangeComparator.min && rangeComparator.max) {
		if (rangeComparator.min.operator === ">=" && rangeComparator.max.operator === "<") {
			if (rangeComparator.min.semver.major !== 0 && inc(rangeComparator.min.semver.version, "premajor") === rangeComparator.max.semver.version) return `^${rangeComparator.min.semver.version}`;
			if (inc(rangeComparator.min.semver.version, "preminor") === rangeComparator.max.semver.version) return `~${rangeComparator.min.semver.version}`;
		}
	}
	return comparators.map(normalizeComparator).join(" ");
}
/** Normalize comparator */
function normalizeComparator(comparator) {
	if (comparator.operator === "") return comparator.value || "*";
	return comparator.value;
}
/** Join */
function joinComparators(a, b) {
	const aRangeComparator = toRangeComparator(a);
	const bRangeComparator = toRangeComparator(b);
	if (aRangeComparator && bRangeComparator) {
		const comparators = [];
		if (aRangeComparator.min && bRangeComparator.min) comparators.push(aRangeComparator.min.semver.compare(bRangeComparator.min.semver) <= 0 ? aRangeComparator.min : bRangeComparator.min);
		if (aRangeComparator.max && bRangeComparator.max) comparators.push(aRangeComparator.max.semver.compare(bRangeComparator.max.semver) >= 0 ? aRangeComparator.max : bRangeComparator.max);
		if (comparators.length === 0) return new Range("*").set[0];
		return comparators;
	}
	return null;
}
/** Convert to RangeComparator */
function toRangeComparator(comparators) {
	if (comparators.length === 2) {
		if (comparators[0].operator === ">" || comparators[0].operator === ">=") {
			if (comparators[1].operator === "<" || comparators[1].operator === "<=") return {
				min: comparators[0],
				max: comparators[1]
			};
		} else if (comparators[0].operator === "<" || comparators[0].operator === "<=") {
			if (comparators[1].operator === ">" || comparators[1].operator === ">=") return {
				min: comparators[1],
				max: comparators[0]
			};
		}
	}
	if (comparators.length === 1) {
		if (comparators[0].operator === ">" || comparators[0].operator === ">=") return {
			min: comparators[0],
			max: null
		};
		else if (comparators[0].operator === "<" || comparators[0].operator === "<=") return {
			min: null,
			max: comparators[0]
		};
	}
	return null;
}
/** Get max version */
function maxNextVersion(range) {
	let maxVer = null;
	for (const comparators of range.set) {
		let max = null;
		let hasMin = false;
		for (const comparator of comparators) {
			if (isAnyComparator(comparator)) return null;
			const compVer = new SemVer(comparator.semver.version);
			if (comparator.operator === "<=" || comparator.operator === "<" || comparator.operator === "") {
				if (comparator.operator === "<=") compVer.inc("prerelease");
				if (!max || lt(max, compVer)) max = compVer;
			} else if (comparator.operator === ">=" || comparator.operator === ">") hasMin = true;
		}
		if (max) {
			if (!maxVer || lt(maxVer, max)) maxVer = max;
		} else if (hasMin) return null;
	}
	return maxVer;
}
/** Checks whether the given comparator is ANY comparator or not. */
function isAnyComparator(comparator) {
	return !comparator.semver.version;
}

//#endregion
//#region lib/rules/absolute-version.ts
const PREFERS = [
	"always",
	"never",
	"ignore"
];
const SCHEMA_FOR_DEPS_PROPERTIES = {
	dependencies: { enum: PREFERS },
	peerDependencies: { enum: PREFERS },
	optionalDependencies: { enum: PREFERS },
	devDependencies: { enum: PREFERS }
};
const DEFAULT = {
	dependencies: "ignore",
	peerDependencies: "ignore",
	optionalDependencies: "ignore",
	devDependencies: "always"
};
/**
* Convert from string option to object option
*/
function stringToOption(option) {
	return {
		dependencies: option,
		peerDependencies: option,
		optionalDependencies: option,
		devDependencies: option
	};
}
/**
* Convert from object option to object option
*/
function objectToOption(option, defaults) {
	return {
		dependencies: option.dependencies || defaults.dependencies,
		peerDependencies: option.peerDependencies || defaults.peerDependencies,
		optionalDependencies: option.optionalDependencies || defaults.optionalDependencies,
		devDependencies: option.devDependencies || defaults.devDependencies
	};
}
/**
* Parse option
*/
function parseOption(option) {
	if (!option) return () => DEFAULT;
	if (typeof option === "string") {
		const objectOption = stringToOption(option);
		return () => objectOption;
	}
	const baseOption = objectToOption(option, DEFAULT);
	if (!option.overridePackages) return () => baseOption;
	const overridePackages = Object.entries(option.overridePackages).map(([packageName, opt]) => {
		const regexp = toRegExp(packageName);
		return {
			test: (s) => regexp.test(s),
			...typeof opt === "string" ? stringToOption(opt) : objectToOption(opt, baseOption)
		};
	});
	return (name) => {
		for (const overridePackage of overridePackages) if (overridePackage.test(name)) return overridePackage;
		return baseOption;
	};
}
var absolute_version_default = createRule("absolute-version", {
	meta: {
		docs: {
			description: "require or disallow absolute version of dependency.",
			category: "Best Practices",
			recommended: false
		},
		schema: [{ oneOf: [{ enum: PREFERS.filter((p) => p !== "ignore") }, {
			type: "object",
			properties: {
				...SCHEMA_FOR_DEPS_PROPERTIES,
				overridePackages: {
					type: "object",
					patternProperties: { "^(?:\\S+)$": { oneOf: [{ enum: PREFERS }, {
						type: "object",
						properties: SCHEMA_FOR_DEPS_PROPERTIES,
						additionalProperties: false
					}] } },
					minProperties: 1,
					additionalProperties: false
				}
			},
			additionalProperties: false
		}] }],
		messages: {},
		type: "suggestion"
	},
	create(context) {
		if (!context.sourceCode.parserServices.isJSON) return {};
		const getOption = parseOption(context.options[0]);
		/** Define dependency visitor */
		function defineVisitor(visitName) {
			return (node) => {
				const ver = getStaticJSONValue(node.value);
				if (typeof ver !== "string" || ver == null) return;
				const option = getOption(String(getKeyFromJSONProperty(node)))[visitName];
				const semver = getSemverRange(ver);
				if (semver == null) return;
				if (option === "always") {
					if (isAbsoluteVersion(semver)) return;
					context.report({
						loc: node.value.loc,
						message: "Use the absolute version instead."
					});
				} else if (option === "never") {
					if (!isAbsoluteVersion(semver)) return;
					context.report({
						loc: node.value.loc,
						message: "Do not use the absolute version."
					});
				}
			};
		}
		return defineJsonVisitor({
			dependencies: defineVisitor("dependencies"),
			peerDependencies: defineVisitor("peerDependencies"),
			optionalDependencies: defineVisitor("optionalDependencies"),
			devDependencies: defineVisitor("devDependencies")
		});
	}
});
/** Checks whether the given semver is absolute version or not */
function isAbsoluteVersion(semver) {
	for (const comparators of semver.set) for (const comparator of comparators) {
		if (isAnyComparator(comparator)) return false;
		if (comparator.operator !== "=" && comparator.operator !== "") return false;
	}
	return true;
}

//#endregion
//#region lib/utils/package-json/index.ts
const syncPackageJson = createSyncFn(getWorkerPath(), { timeout: 1e4 });
/**
* Get the worker module path
*/
function getWorkerPath() {
	const ext = path.extname(fileURLToPath(import.meta.url));
	try {
		return fileURLToPath(import.meta.resolve(`./worker${ext}`));
	} catch {}
	return createRequire(import.meta.url).resolve(`./worker${ext}`);
}

//#endregion
//#region lib/utils/meta.ts
const TTL = 1e3 * 60 * 60;
const CACHE_VERSION = 2;
const dirname = path.dirname(fileURLToPath(import.meta.url));
const CACHED_META_ROOT = path.join(dirname, `../.cached_meta`);
/**
* Get the meta info from given module name
*/
function getMetaFromNodeModules(name, ver, options) {
	try {
		const ownerJsonPath = options.ownerPackageJsonPath || options.context.filename;
		const relativeTo = path.join(ownerJsonPath && path.isAbsolute(ownerJsonPath) ? path.dirname(ownerJsonPath) : options.context.cwd, "__placeholder__.js");
		const req = Module.createRequire(relativeTo);
		const where = req.resolve(`${name}/package.json`);
		const pkg = req(where);
		if (maybeMeta(pkg)) {
			const vr = getSemverRange(ver);
			if (typeof pkg.version === "string" && (!vr || satisfies(pkg.version, vr))) {
				pkg._where = where;
				return pkg;
			}
		}
	} catch {}
	return null;
}
/**
* Get the npm meta info from given module name and version
*/
function getMetaFromNpm(name, ver) {
	const trimmed = ver.trim();
	if (trimmed.startsWith("npm:")) {
		let parsed = null;
		try {
			parsed = npa(`${trimmed.slice(4).trim()}`);
		} catch {}
		if (parsed && (parsed.type === "range" || parsed.type === "version" || parsed.type === "tag")) return getMetaFromNameAndSpec(parsed.name, parsed.fetchSpec?.trim());
	}
	if (trimmed.includes("/") || trimmed.includes(":")) return {
		cache: [],
		get: () => []
	};
	return getMetaFromNameAndSpec(name, ver.trim());
}
/**
* Get the meta info from npm registry with given package name and spec
*/
function getMetaFromNameAndSpec(name, verOrTag) {
	const { cache, get } = getMetaFromName(name, path.join(CACHED_META_ROOT, `${name}.json`));
	let isTargetVersion;
	let hasUnknown = false;
	const range = getSemverRange(verOrTag || "*");
	if (range) isTargetVersion = (meta) => {
		if (!meta.version) return true;
		return range.test(meta.version);
	};
	else {
		const parsed = npa.resolve(name, verOrTag);
		if (parsed.type === "tag") isTargetVersion = (meta) => {
			if (!meta.version) return true;
			const v = meta["dist-tags"]?.[parsed.fetchSpec];
			if (v == null) hasUnknown = true;
			return v === meta.version;
		};
		else return {
			cache: [],
			get: () => null
		};
	}
	if (cache) {
		let alive = cache.alive;
		if (!alive && range) {
			const maxNext = maxNextVersion(range);
			if (maxNext) alive = cache.data.meta.some((m) => m.version && maxNext.compare(m.version) <= 0);
		}
		const metaList = cache.data.meta.filter(isTargetVersion);
		if (alive) return {
			cache: metaList,
			get: () => hasUnknown ? null : metaList
		};
		return {
			cache: metaList,
			get: () => {
				const list = get()?.filter(isTargetVersion) ?? null;
				return hasUnknown && !list?.length ? null : list;
			}
		};
	}
	return {
		cache: [],
		get: () => {
			const list = get()?.filter(isTargetVersion) ?? null;
			return hasUnknown && !list?.length ? null : list;
		}
	};
}
/**
* Get the meta info from given package name
*/
function getMetaFromName(name, cachedFilePath) {
	return {
		cache: getCache(),
		get: () => {
			return getMetaFromNameWithoutCache(name, cachedFilePath);
		}
	};
	/** Get from cache */
	function getCache() {
		makeDirs(path.dirname(cachedFilePath));
		if (!fs.existsSync(cachedFilePath)) return null;
		const data = JSON.parse(fs.readFileSync(cachedFilePath, "utf8"));
		if (!data || data.meta == null) return null;
		if (data.v !== CACHE_VERSION) return null;
		return {
			data,
			alive: Boolean(typeof data.expired === "number" && data.expired >= Date.now() || typeof data.timestamp === "number" && data.timestamp + TTL >= Date.now() || data.meta.length === 1 && data.meta[0].deprecated)
		};
	}
}
/**
* Get the meta info from given package name
*/
function getMetaFromNameWithoutCache(name, cachedFilePath) {
	let meta = [];
	try {
		const allMeta = syncPackageJson(name);
		meta = Object.values(allMeta.versions).map((vm) => {
			return {
				version: vm.version,
				engines: vm.engines,
				dependencies: vm.dependencies,
				peerDependencies: vm.peerDependencies,
				optionalDependencies: vm.optionalDependencies,
				"dist-tags": allMeta["dist-tags"],
				deprecated: vm.deprecated,
				dist: vm.dist
			};
		});
	} catch {
		return null;
	}
	const timestamp = Date.now();
	const content = {
		v: CACHE_VERSION,
		meta,
		timestamp,
		expired: timestamp + Math.floor(Math.random() * 1e3 * 60)
	};
	fs.writeFileSync(cachedFilePath, JSON.stringify(content));
	return meta;
}
/** Get the engines from given package.json value */
function getEngines(meta) {
	if (!maybeMeta(meta)) return /* @__PURE__ */ new Map();
	return getStrMap(meta.engines);
}
/** Get the dependencies from given package.json value */
function getDependencies(meta, kind) {
	if (!maybeMeta(meta)) return /* @__PURE__ */ new Map();
	return getStrMap(meta[kind]);
}
/** Get the map from given value */
function getStrMap(maybeObject) {
	const map = /* @__PURE__ */ new Map();
	if (typeof maybeObject !== "object" || !maybeObject || Array.isArray(maybeObject)) return map;
	for (const [key, val] of Object.entries(maybeObject)) if (val != null) map.set(key, `${val}`);
	return map;
}
/**
* Checks whether the given object is package.json meta data
*/
function maybeMeta(json) {
	if (typeof json !== "object" || !json || Array.isArray(json)) return false;
	return true;
}
/**
* Make directories
*/
function makeDirs(dir) {
	const dirs = [dir];
	while (!fs.existsSync(dirs[0])) dirs.unshift(path.dirname(dirs[0]));
	dirs.shift();
	for (const d of dirs) fs.mkdirSync(d);
}

//#endregion
//#region lib/rules/compat-engines.ts
var EnginesContext = class EnginesContext {
	engines;
	unprocessedEngines = /* @__PURE__ */ new Set();
	invalidEngines = /* @__PURE__ */ new Map();
	validEngines = /* @__PURE__ */ new Set();
	validDependencies = /* @__PURE__ */ new Set();
	constructor(engineNames, validDependencies = /* @__PURE__ */ new Set()) {
		this.engines = new Set(engineNames);
		this.unprocessedEngines = new Set(this.engines);
		this.validDependencies = validDependencies;
	}
	nextContext() {
		return new EnginesContext(this.unprocessedEngines, this.validDependencies);
	}
	markAsProcessed(module) {
		this.unprocessedEngines.delete(module);
	}
	isAllProcessed() {
		return this.unprocessedEngines.size === 0;
	}
	markAsValid(module) {
		this.validEngines.add(module);
		this.invalidEngines.delete(module);
	}
	addInvalid(module, allowedVer) {
		if (this.validEngines.has(module)) return;
		const vers = this.invalidEngines.get(module);
		if (vers) vers.set(allowedVer.raw, allowedVer);
		else this.invalidEngines.set(module, new Map([[allowedVer.raw, allowedVer]]));
	}
	hasInvalid() {
		return this.invalidEngines.size > 0;
	}
	getInvalid() {
		return this.invalidEngines;
	}
	markAsValidDependency(name, ver) {
		this.validDependencies.add(`${name}@${ver}`);
	}
	isValidDependency(name, ver) {
		return this.validDependencies.has(`${name}@${ver}`);
	}
};
/**
* Build adjusted version range for self.
*/
function buildAdjustRangeForSelf(comparisonType, original) {
	const adjustVers = [];
	for (const cc of original.set) {
		if (cc.length === 1) {
			if (cc[0].operator === ">" || cc[0].operator === ">=") {
				adjustVers.push(`${cc[0].value} <${semver.inc(cc[0].semver.version, "premajor")}`);
				continue;
			}
		}
		adjustVers.push(cc.map((c) => c.value).join(" "));
	}
	const range = new semver.Range(adjustVers.join("||"));
	if (comparisonType === "normal") return range;
	if (comparisonType === "major") return range;
	throw new Error(`Illegal comparisonType: ${comparisonType}`);
}
/**
* Build adjusted version range for dependencies.
*/
function buildAdjustRangeForDeps(comparisonType, original) {
	if (comparisonType === "normal") return original;
	if (comparisonType === "major") {
		const majorVers = [];
		for (const cc of original.set) majorVers.push(cc.map((c) => {
			if (c.operator === ">" || c.operator === ">=") return `${c.operator}${c.semver.major}`;
			return c.value;
		}).join(" "));
		return new semver.Range(majorVers.join("||"));
	}
	throw new Error(`Illegal comparisonType: ${comparisonType}`);
}
/** Extract dependencies */
function extractDependencies(metaList) {
	const dependencies = /* @__PURE__ */ new Map();
	for (const meta of metaList) for (const [m, v] of [...getDependencies(meta, "dependencies"), ...getDependencies(meta, "peerDependencies")]) {
		const range = getSemverRange(v);
		if (!range) continue;
		const ranges = dependencies.get(m);
		if (ranges) ranges.push(range);
		else dependencies.set(m, [range]);
	}
	return [...dependencies].sort(([a], [b]) => a < b ? -1 : a > b ? 1 : 0);
}
var compat_engines_default = createRule("compat-engines", {
	meta: {
		docs: {
			description: "enforce the versions of the engines of the dependencies to be compatible.",
			category: "Possible Errors",
			recommended: true
		},
		schema: [{
			type: "object",
			properties: {
				deep: { type: "boolean" },
				comparisonType: { enum: ["normal", "major"] }
			},
			additionalProperties: false
		}],
		messages: {},
		type: "problem"
	},
	create(context) {
		if (!context.sourceCode.parserServices.isJSON) return {};
		const deep = context.options[0]?.deep !== false;
		const comparisonType = context.options[0]?.comparisonType ?? "normal";
		const selfEngines = /* @__PURE__ */ new Map();
		/**
		* Process meta data
		*/
		function processMeta(ctx, meta) {
			const depEngines = getEngines(meta);
			for (const module of ctx.engines) {
				const selfVer = selfEngines.get(module);
				const engineValue = depEngines.get(module);
				if (engineValue && engineValue !== "*") ctx.markAsProcessed(module);
				const depVer = getSemverRange(engineValue || "*");
				if (!depVer) continue;
				if (semver.subset(selfVer.adjust, buildAdjustRangeForDeps(comparisonType, depVer))) ctx.markAsValid(module);
				else ctx.addInvalid(module, depVer);
			}
		}
		/**
		* Process dependency module
		*/
		function processDependencyModule(ctx, name, ver, modules, node) {
			const currModules = [...modules, `${name}@${ver}`];
			const nodeModulesMeta = getMetaFromNodeModules(name, ver, { context });
			if (nodeModulesMeta) {
				processMeta(ctx, nodeModulesMeta);
				if (!ctx.hasInvalid() && ctx.isAllProcessed()) return;
			}
			const metaData = getMetaFromNpm(name, ver);
			for (const meta of metaData.cache) {
				processMeta(ctx, meta);
				if (!ctx.hasInvalid() && ctx.isAllProcessed()) return;
			}
			const metaList = metaData.get();
			if (!metaList) return;
			for (const meta of metaList) {
				processMeta(ctx, meta);
				if (!ctx.hasInvalid() && ctx.isAllProcessed()) return;
			}
			for (const [module, allowedVers] of ctx.getInvalid()) {
				const selfVer = selfEngines.get(module);
				const depVer = normalizeSemverRange(...allowedVers.values()) || [...allowedVers.values()].pop();
				if (semver.subset(selfVer.adjust, buildAdjustRangeForDeps(comparisonType, depVer))) continue;
				context.report({
					loc: node.loc,
					message: `${currModules.map((m) => `"${m}"`).join(" >> ")} is not compatible with "${module}@${normalizeVer(selfVer.original)}". Allowed is: "${module}@${normalizeVer(depVer)}"`
				});
			}
			if (ctx.isAllProcessed()) return;
			ctx.markAsValidDependency(name, ver);
			if (deep) for (const [n, ranges] of extractDependencies(metaList)) {
				const v = normalizeSemverRange(...ranges);
				if (v && !ctx.isValidDependency(n, v.raw)) processDependencyModule(ctx.nextContext(), n, v.raw, currModules, node);
			}
		}
		return compositingVisitors({ JSONExpressionStatement(node) {
			const expr = node.expression;
			if (expr.type !== "JSONObjectExpression") return;
			const enginesNode = expr.properties.find((p) => getKeyFromJSONProperty(p) === "engines");
			if (!enginesNode) return;
			for (const [key, val] of getEngines({ engines: getStaticJSONValue(enginesNode.value) })) {
				const selfVer = getSemverRange(val);
				if (!selfVer) continue;
				selfEngines.set(key, {
					adjust: buildAdjustRangeForSelf(comparisonType, selfVer),
					original: selfVer
				});
			}
		} }, defineJsonVisitor({ "dependencies, peerDependencies"(node) {
			if (selfEngines.size === 0) return;
			const name = getKeyFromJSONProperty(node);
			const ver = getStaticJSONValue(node.value);
			if (typeof name !== "string" || typeof ver !== "string") return;
			processDependencyModule(new EnginesContext(selfEngines.keys()), name, ver, [], node);
		} }));
	}
});

//#endregion
//#region lib/rules/no-deprecated.ts
var no_deprecated_default = createRule("no-deprecated", {
	meta: {
		docs: {
			description: "disallow having dependencies on deprecate packages.",
			category: "Best Practices",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				devDependencies: { type: "boolean" },
				allows: {
					type: "array",
					items: { type: "string" },
					uniqueItems: true
				}
			},
			additionalProperties: false
		}],
		messages: {},
		type: "suggestion"
	},
	create(context) {
		if (!context.sourceCode.parserServices.isJSON) return {};
		return defineJsonVisitor({ [Boolean(context.options[0]?.devDependencies) ? "dependencies, peerDependencies, devDependencies" : "dependencies, peerDependencies"](node) {
			const name = getKeyFromJSONProperty(node);
			const ver = getStaticJSONValue(node.value);
			if (typeof name !== "string" || typeof ver !== "string" || !ver) return;
			if (context.options[0]?.allows?.includes(name)) return;
			const meta = getMetaFromNpm(name, ver).get();
			const deprecated = meta && meta.length && meta[meta.length - 1].deprecated;
			if (deprecated) context.report({
				loc: node.loc,
				message: `${deprecated}`
			});
		} });
	}
});

//#endregion
//#region lib/rules/no-dupe-deps.ts
const DEPS$1 = [
	"dependencies",
	"peerDependencies",
	"optionalDependencies",
	"devDependencies"
];
var AllowDuplicates = class {
	edges = [];
	add(d1, d2) {
		this.edges.push([d1, d2]);
	}
	isAllowedDuplicate(dep1, dep2) {
		return this.edges.some(([d1, d2]) => d1 === dep1 && d2 === dep2 || d2 === dep1 && d1 === dep2);
	}
};
var no_dupe_deps_default = createRule("no-dupe-deps", {
	meta: {
		docs: {
			description: "disallow duplicate dependencies.",
			category: "Possible Errors",
			recommended: true
		},
		schema: [],
		messages: { duplicated: "Duplicated dependency '{{name}}'." },
		type: "problem"
	},
	create(context) {
		if (!context.sourceCode.parserServices.isJSON) return {};
		const allowDuplicates = new AllowDuplicates();
		allowDuplicates.add("devDependencies", "peerDependencies");
		allowDuplicates.add("devDependencies", "optionalDependencies");
		const maps = {
			dependencies: /* @__PURE__ */ new Map(),
			peerDependencies: /* @__PURE__ */ new Map(),
			optionalDependencies: /* @__PURE__ */ new Map(),
			devDependencies: /* @__PURE__ */ new Map()
		};
		const reported = /* @__PURE__ */ new Set();
		/** Report */
		function report(name, node) {
			if (reported.has(node)) return;
			reported.add(node);
			context.report({
				loc: node.key.loc,
				messageId: "duplicated",
				data: { name }
			});
		}
		/** Verify */
		function verify(depsName, name, node) {
			for (const dep of DEPS$1) {
				if (allowDuplicates.isAllowedDuplicate(dep, depsName)) continue;
				const dupeNode = maps[dep].get(name);
				if (dupeNode) {
					report(name, dupeNode);
					report(name, node);
				}
			}
		}
		/** Define dependency visitor */
		function defineVisitor(depsName) {
			return (node) => {
				const name = String(getKeyFromJSONProperty(node));
				verify(depsName, name, node);
				maps[depsName].set(name, node);
			};
		}
		return defineJsonVisitor({
			dependencies: defineVisitor("dependencies"),
			peerDependencies: defineVisitor("peerDependencies"),
			optionalDependencies: defineVisitor("optionalDependencies"),
			devDependencies: defineVisitor("devDependencies")
		});
	}
});

//#endregion
//#region lib/rules/no-restricted-deps.ts
const DEPS = [
	"dependencies",
	"peerDependencies",
	"optionalDependencies"
];
var Deps = class {
	map = Object.create(null);
	list = [];
	push(name, ver, ownerPackageJsonPath) {
		const range = getSemverRange(ver);
		if (range) {
			const data = this.map[name];
			if (data) {
				const newRange = normalizeSemverRange(data.range, range);
				this.map[name] = {
					range: newRange,
					ownerPackageJsonPath: ownerPackageJsonPath || data.ownerPackageJsonPath
				};
			} else this.map[name] = {
				range,
				ownerPackageJsonPath
			};
			return;
		}
		this.list.push({
			name,
			ver,
			ownerPackageJsonPath
		});
	}
	pop() {
		const resultForList = this.list.shift();
		if (resultForList) return resultForList;
		const [key] = Object.keys(this.map);
		if (key) {
			const data = this.map[key];
			delete this.map[key];
			return {
				name: key,
				ver: normalizeVer(data.range),
				ownerPackageJsonPath: data.ownerPackageJsonPath
			};
		}
		return null;
	}
};
var DeepValidateContext = class {
	deepValidatedCache = /* @__PURE__ */ new Map();
	context;
	validator;
	constructor(context, validator) {
		this.context = context;
		this.validator = validator;
	}
	buildDeepValidator(deepOption) {
		return (n, v) => this.deepDepsValidate(n, v, deepOption);
	}
	/**
	* Deep dependency validate
	*/
	deepDepsValidate(packageName, version, deepOption) {
		const { validator: validate, context } = this;
		const depsQueue = new Deps();
		depsQueue.push(packageName, version);
		let dep;
		while (dep = depsQueue.pop()) {
			const key = `${dep.name}@${dep.ver}`;
			if (this.deepValidatedCache.has(key)) {
				const result = this.deepValidatedCache.get(key);
				if (result) return result;
			} else {
				const result = validateWithoutCache(dep.name, dep.ver, dep.ownerPackageJsonPath);
				this.deepValidatedCache.set(key, result);
				if (result) return result;
			}
		}
		return null;
		/**
		* Dependency validate
		*/
		function validateWithoutCache(name, ver, ownerPackageJsonPath) {
			const result = validate(name, ver);
			if (result) return result;
			for (const { name: n, ver: v, packageJsonPath } of iterateDeps(name, ver, ownerPackageJsonPath)) {
				const r = validate(n, v);
				if (r) return r;
				depsQueue.push(n, v, packageJsonPath);
			}
			return null;
		}
		/** Iterate deps */
		function* iterateDeps(name, ver, ownerPackageJsonPath) {
			yield* iterateDepsForMeta(getMetaFromNodeModules(name, ver, {
				context,
				ownerPackageJsonPath
			}));
			if (deepOption === "server") {
				const metaData = getMetaFromNpm(name, ver);
				for (const meta of metaData.cache) yield* iterateDepsForMeta(meta);
				const metaList = metaData.get();
				if (metaList) for (const meta of metaList) yield* iterateDepsForMeta(meta);
			}
		}
		/** Iterate deps */
		function* iterateDepsForMeta(meta) {
			if (!meta) return;
			for (const depName of DEPS) {
				const deps = meta[depName];
				if (!deps) continue;
				for (const [n, v] of Object.entries(deps)) if (typeof v === "string") yield {
					name: n,
					ver: v,
					packageJsonPath: meta._where
				};
			}
		}
	}
};
var no_restricted_deps_default = createRule("no-restricted-deps", {
	meta: {
		docs: {
			description: "Disallows dependence on the specified package.",
			category: "Best Practices",
			recommended: false
		},
		schema: {
			type: "array",
			items: { oneOf: [{ type: "string" }, {
				type: "object",
				properties: {
					package: { type: "string" },
					version: { type: "string" },
					message: { type: "string" },
					deep: { enum: ["local", "server"] }
				},
				required: ["package"],
				additionalProperties: false
			}] },
			uniqueItems: true,
			minItems: 0
		},
		messages: { restricted: "{{message}}" },
		type: "suggestion"
	},
	create(context) {
		if (!context.sourceCode.parserServices.isJSON) return {};
		const validateForPackage = parseOptions(context.options);
		/** Define dependency visitor */
		function defineVisitor(_depsName) {
			return (node) => {
				const result = validateForPackage(String(getKeyFromJSONProperty(node)), String(getStaticJSONValue(node.value)));
				if (!result) return;
				context.report({
					loc: node.loc,
					messageId: "restricted",
					data: result
				});
			};
		}
		return defineJsonVisitor({
			dependencies: defineVisitor("dependencies"),
			peerDependencies: defineVisitor("peerDependencies"),
			optionalDependencies: defineVisitor("optionalDependencies"),
			devDependencies: defineVisitor("devDependencies")
		});
		/** Checks whether the given vers are match or not */
		function matchVersions(version, optionVersion) {
			if (!optionVersion) return true;
			const range = getSemverRange(version);
			return Boolean(range && intersects(range, optionVersion));
		}
		/**
		* Parse option
		*/
		function parseOption(option) {
			if (typeof option === "string") {
				const regexp = toRegExp(option);
				return (n, _v) => {
					if (regexp.test(n)) return { message: `Depend on '${option}' is not allowed.` };
					return null;
				};
			}
			const regexp = toRegExp(option.package);
			const version = option.version ? getSemverRange(option.version) : null;
			const validator = (n, v) => {
				if (regexp.test(n) && matchVersions(v, version)) return { message: option.message || buildDefaultMessage(option) };
				return null;
			};
			if (!option.deep) return validator;
			return new DeepValidateContext(context, validator).buildDeepValidator(option.deep);
			/** Build default message for object option */
			function buildDefaultMessage(objectOption) {
				const versionForMessage = objectOption.version ? `@${objectOption.version}` : "";
				if (objectOption.package.startsWith("/") && versionForMessage) return `Depend on '${objectOption.package} ${versionForMessage}' is not allowed.`;
				return `Depend on '${objectOption.package}${versionForMessage}' is not allowed.`;
			}
		}
		/**
		* Parse options
		*/
		function parseOptions(options) {
			const validators = options.map(parseOption);
			return (packageName, version) => {
				for (const validator of validators) {
					const result = validator(packageName, version);
					if (result) return result;
				}
				return null;
			};
		}
	}
});

//#endregion
//#region lib/utils/semver-range.ts
/**
* Iterate version ranges
*/
function* iterateSemverRanges(versionRanges) {
	let startOffset = 0;
	for (const strRange of versionRanges.split("||")) {
		const result = toRangeResult(strRange, startOffset);
		if (result) yield result;
		startOffset += strRange.length + 2;
	}
}
/**
* Build result object
*/
function toRangeResult(strRange, startOffset) {
	let start = 0;
	while (strRange.length > start && !strRange[start].trim()) start++;
	let end = strRange.length;
	while (end > start && !strRange[end - 1].trim()) end--;
	const value = strRange.slice(start, end);
	const range = getSemverRange(value);
	if (!range) return null;
	if (range.set.length !== 1) return null;
	return {
		value,
		comparators: range.set[0],
		range: [startOffset + start, startOffset + end]
	};
}

//#endregion
//#region lib/rules/prefer-caret-range-version.ts
var prefer_caret_range_version_default = createRule("prefer-caret-range-version", {
	meta: {
		docs: {
			description: "require caret(`^`) version instead of range version.",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "code",
		schema: [],
		messages: {},
		type: "suggestion"
	},
	create(context) {
		const sourceCode = context.sourceCode;
		if (!sourceCode.parserServices.isJSON) return {};
		/**
		* Convert to use caret range syntax.
		*/
		function convertToUseCaret(range) {
			if (range.comparators.length !== 2) return null;
			const start = range.comparators.find((c) => c.operator === ">=");
			const end = range.comparators.find((c) => c.operator === "<");
			if (!start || !end) return null;
			const caretRangeText = `^${start.semver.version}`;
			const caretRange = getSemverRange(caretRangeText);
			if (!caretRange) return null;
			const caretEnd = caretRange.set[0].find((c) => c.operator === "<");
			if (!caretEnd) return null;
			if (caretEnd.semver.compare(end.semver) !== 0) {
				const endPre = new SemVer(`${end.semver.version}-0`);
				if (caretEnd.semver.compare(endPre) !== 0) return null;
			}
			return caretRangeText;
		}
		/**
		* Verify for range
		*/
		function verifyRange(range, node) {
			const fixedRange = convertToUseCaret(range);
			if (!fixedRange) return;
			context.report({
				loc: {
					start: sourceCode.getLocFromIndex(node.range[0] + range.range[0]),
					end: sourceCode.getLocFromIndex(node.range[0] + range.range[1])
				},
				message: `Use '${fixedRange}' syntax instead.`,
				fix(fixer) {
					return fixer.replaceTextRange(node.range, JSON.stringify(node.value.slice(0, range.range[0]) + fixedRange + node.value.slice(range.range[1])));
				}
			});
		}
		/**
		* Verify for version
		*/
		function verifyVersion(node) {
			if (maybeDepId$1(node.value)) return;
			for (const range of iterateSemverRanges(node.value)) {
				const lowerRange = range.value.toLowerCase();
				if (!lowerRange.startsWith("~")) {
					if (lowerRange.startsWith("^") || /^\d+$/u.test(range.value) || (range.value.endsWith(".x") || range.value.endsWith(".*")) && !/\s+-\s+/u.test(range.value)) continue;
				}
				verifyRange(range, node);
			}
		}
		return defineJsonVisitor({ "engines, dependencies, peerDependencies, devDependencies, optionalDependencies"(node) {
			if (isJSONStringLiteral$1(node.value)) verifyVersion(node.value);
		} });
	}
});
/**
* Checks whether the given expression is string literal or not
*/
function isJSONStringLiteral$1(node) {
	return node.type === "JSONLiteral" && typeof node.value === "string";
}
/** Checks whether the given ver is dependencies identify */
function maybeDepId$1(ver) {
	return ver.includes("/") || ver.includes(":") || /^[-a-z]+$/.test(ver);
}

//#endregion
//#region lib/rules/prefer-tilde-range-version.ts
var prefer_tilde_range_version_default = createRule("prefer-tilde-range-version", {
	meta: {
		docs: {
			description: "require tilde(`~`) version instead of range version.",
			category: "Stylistic Issues",
			recommended: false
		},
		fixable: "code",
		schema: [],
		messages: {},
		type: "suggestion"
	},
	create(context) {
		const sourceCode = context.sourceCode;
		if (!sourceCode.parserServices.isJSON) return {};
		/**
		* Convert to use tilde range syntax.
		*/
		function convertToUseTilde(range) {
			if (range.comparators.length !== 2) return null;
			const start = range.comparators.find((c) => c.operator === ">=");
			const end = range.comparators.find((c) => c.operator === "<");
			if (!start || !end) return null;
			const tildeRangeText = `~${start.semver.version}`;
			const tildeRange = getSemverRange(tildeRangeText);
			if (!tildeRange) return null;
			const tildeEnd = tildeRange.set[0].find((c) => c.operator === "<");
			if (!tildeEnd) return null;
			if (tildeEnd.semver.compare(end.semver) !== 0) {
				const endPre = new SemVer(`${end.semver.version}-0`);
				if (tildeEnd.semver.compare(endPre) !== 0) return null;
			}
			return tildeRangeText;
		}
		/**
		* Verify for range
		*/
		function verifyRange(range, node) {
			const fixedRange = convertToUseTilde(range);
			if (!fixedRange) return;
			context.report({
				loc: {
					start: sourceCode.getLocFromIndex(node.range[0] + range.range[0]),
					end: sourceCode.getLocFromIndex(node.range[0] + range.range[1])
				},
				message: `Use '${fixedRange}' syntax instead.`,
				fix(fixer) {
					return fixer.replaceTextRange(node.range, JSON.stringify(node.value.slice(0, range.range[0]) + fixedRange + node.value.slice(range.range[1])));
				}
			});
		}
		/**
		* Verify for version
		*/
		function verifyVersion(node) {
			if (maybeDepId(node.value)) return;
			for (const range of iterateSemverRanges(node.value)) {
				const lowerRange = range.value.toLowerCase();
				if (!lowerRange.startsWith("^")) {
					if (lowerRange.startsWith("~") || /^\d+$/u.test(range.value) || /^\d+\.\d+$/u.test(range.value) || (range.value.endsWith(".x") || range.value.endsWith(".*")) && !/\s+-\s+/u.test(range.value)) continue;
				}
				verifyRange(range, node);
			}
		}
		return defineJsonVisitor({ "engines, dependencies, peerDependencies, devDependencies, optionalDependencies"(node) {
			if (isJSONStringLiteral(node.value)) verifyVersion(node.value);
		} });
	}
});
/**
* Checks whether the given expression is string literal or not
*/
function isJSONStringLiteral(node) {
	return node.type === "JSONLiteral" && typeof node.value === "string";
}
/** Checks whether the given ver is dependencies identify */
function maybeDepId(ver) {
	return ver.includes("/") || ver.includes(":") || /^[-a-z]+$/.test(ver);
}

//#endregion
//#region lib/rules/require-provenance-deps.ts
var require_provenance_deps_default = createRule("require-provenance-deps", {
	meta: {
		docs: {
			description: "Require provenance information for dependencies",
			category: "Best Practices",
			recommended: false
		},
		schema: [{
			type: "object",
			properties: {
				devDependencies: { type: "boolean" },
				allows: {
					type: "array",
					items: { type: "string" },
					uniqueItems: true
				}
			},
			additionalProperties: false
		}],
		messages: { missingProvenance: "Dependency \"{{name}}\" has versions without provenance information: {{versions}}." },
		type: "suggestion"
	},
	create(context) {
		if (!context.sourceCode.parserServices.isJSON) return {};
		const devDependencies = Boolean(context.options[0]?.devDependencies);
		/**
		* Extract version ranges without provenance information
		*/
		function extractNoProvenanceRanges(meta) {
			const noProvenanceRanges = [];
			let prev = null;
			for (let index = 0; index < meta.length; index++) {
				const m = meta[index];
				if (m.dist?.attestations?.provenance) {
					prev = null;
					continue;
				}
				if (prev == null) {
					prev = [m.version, m.version];
					noProvenanceRanges.push(prev);
				} else prev[1] = m.version;
			}
			return noProvenanceRanges;
		}
		return defineJsonVisitor({ [devDependencies ? "dependencies, peerDependencies, devDependencies" : "dependencies, peerDependencies"](node) {
			const name = getKeyFromJSONProperty(node);
			const ver = getStaticJSONValue(node.value);
			if (typeof name !== "string" || typeof ver !== "string" || !ver) return;
			if (context.options[0]?.allows?.includes(name)) return;
			const meta = getMetaFromNpm(name, ver).get();
			if (!meta || !meta.length) return;
			const noProvenanceRanges = extractNoProvenanceRanges(meta);
			if (noProvenanceRanges.length === 0) return;
			context.report({
				loc: node.loc,
				messageId: "missingProvenance",
				data: {
					name,
					versions: formatList(noProvenanceRanges.map(([from, to]) => from === to ? `${from}` : `${from} - ${to}`))
				}
			});
		} });
		/**
		* Format list of strings into a human-readable string
		*/
		function formatList(items) {
			return items.length <= 2 ? items.join(" and ") : `${items.slice(0, -1).join(", ")}, and ${items[items.length - 1]}`;
		}
	}
});

//#endregion
//#region lib/rules/valid-engines.ts
var valid_engines_default = createRule("valid-engines", {
	meta: {
		...compat_engines_default.meta,
		docs: { ...compat_engines_default.meta.docs },
		deprecated: true,
		replacedBy: ["compat-engines"]
	},
	create: compat_engines_default.create
});

//#endregion
//#region lib/rules/valid-semver.ts
var valid_semver_default = createRule("valid-semver", {
	meta: {
		docs: {
			description: "enforce versions that is valid as a semantic version.",
			category: "Possible Errors",
			recommended: true
		},
		schema: [],
		messages: {},
		type: "problem"
	},
	create(context) {
		if (!context.sourceCode.parserServices.isJSON) return {};
		return defineJsonVisitor({
			engines(node) {
				const ver = getStaticJSONValue(node.value);
				if (typeof ver !== "string" || ver == null) {
					context.report({
						loc: node.value.loc,
						message: `\`${JSON.stringify(ver)}\` is invalid.`
					});
					return;
				}
				if (getSemverRange(ver) == null) context.report({
					loc: node.value.loc,
					message: `"${ver}" is invalid.`
				});
			},
			"dependencies, peerDependencies, devDependencies, optionalDependencies"(node) {
				if (typeof getKeyFromJSONProperty(node) !== "string") return;
				const ver = getStaticJSONValue(node.value);
				if (typeof ver !== "string" || ver == null) {
					context.report({
						loc: node.value.loc,
						message: `\`${JSON.stringify(ver)}\` is invalid.`
					});
					return;
				}
				if (maybeNotRange(ver)) return;
				if (getSemverRange(ver) == null) context.report({
					loc: node.value.loc,
					message: `"${ver}" is invalid.`
				});
			}
		});
	}
});
/** Checks whether the given version string is not version range */
function maybeNotRange(ver) {
	if (ver.startsWith(".") || ver.startsWith("~") || ver.includes("/")) return true;
	if (ver.includes(":")) return true;
	if (/^[-a-z]+$/.test(ver)) return true;
	return false;
}

//#endregion
//#region lib/utils/rules.ts
const rules$1 = [
	absolute_version_default,
	compat_engines_default,
	no_deprecated_default,
	no_dupe_deps_default,
	no_restricted_deps_default,
	prefer_caret_range_version_default,
	prefer_tilde_range_version_default,
	require_provenance_deps_default,
	valid_engines_default,
	valid_semver_default
];

//#endregion
//#region lib/configs/rules/recommended.ts
var recommended_default = { rules: {
	"node-dependencies/compat-engines": "error",
	"node-dependencies/no-dupe-deps": "error",
	"node-dependencies/valid-semver": "error"
} };

//#endregion
//#region lib/configs/flat/recommended.ts
const recommendedConfig = [{ plugins: { get "node-dependencies"() {
	return lib_default;
} } }, {
	files: ["**/package.json", "package.json"],
	languageOptions: { parser: jsonParser },
	rules: recommended_default.rules
}];

//#endregion
//#region package.json
var package_default = {
	name: "eslint-plugin-node-dependencies",
	version: "2.1.0",
	type: "module",
	description: "ESLint plugin to check Node.js dependencies.",
	repository: "git+https://github.com/ota-meshi/eslint-plugin-node-dependencies.git",
	homepage: "https://github.com/ota-meshi/eslint-plugin-node-dependencies#readme",
	author: "Yosuke Ota (https://github.com/ota-meshi)",
	maintainers: ["JounQin <admin@1stg.me> (https://www.1stG.me)"],
	funding: ["https://github.com/sponsors/ota-meshi", "https://github.com/sponsors/JounQin"],
	license: "MIT",
	engines: { "node": "^20.19.0 || ^22.13.0 || >=24" },
	exports: {
		".": {
			"types": "./dist/index.d.mts",
			"import": "./dist/index.mjs",
			"default": "./dist/index.mjs"
		},
		"./package.json": "./package.json"
	},
	files: ["dist"],
	keywords: [
		"eslint",
		"eslintplugin",
		"eslint-plugin",
		"nodejs",
		"dependencies",
		"json"
	],
	scripts: {
		"build": "npm run build:ts",
		"build:ts": "tsdown",
		"clean": "node -e \"import('fs').then(fs=>['dist','coverage'].forEach(d=>{try{fs.rmSync(d,{recursive:true,force:true})}catch(e){}}))\"",
		"docs:build": "npm run build && env-cmd -e dev -- vitepress build docs",
		"docs:build-and-preview": "npm run docs:build && npx http-server docs/.vitepress/dist",
		"docs:watch": "npm run build && env-cmd -e dev -- vitepress dev docs",
		"eslint-fix": "npm run lint:eslint -- --fix",
		"lint": "npm run lint:eslint && npm run lint:tsc",
		"lint:eslint": "eslint . --ext .js,.vue,.ts,.json,.yaml,.yml",
		"lint:tsc": "tsc",
		"mocha": "npm run ts -- ./node_modules/mocha/bin/mocha.js",
		"new": "node --experimental-strip-types --experimental-transform-types  ./tools/new-rule.ts",
		"prebuild": "npm run -s clean",
		"preinstall": "npx only-allow npm",
		"prerelease": "npm run test && npm run build",
		"pretest": "npm run build",
		"preversion": "npm test && git add .",
		"release": "clean-pkg-json -r scripts.preinstall && changeset publish",
		"test": "npm run test:c8",
		"test:base": "npm run mocha -- \"tests/**/*.ts\" --reporter dot --timeout 60000",
		"test:c8": "c8 --reporter=lcov npm run test:base",
		"test:debug": "npm run mocha -- \"tests/**/*.ts\" --reporter dot --timeout 60000",
		"test:watch": "npm run test:base -- --watch",
		"ts": "node --import @oxc-node/core/register",
		"update": "npm run ts -- ./tools/update.ts && npm run eslint-fix",
		"version": "env-cmd -e version -- npm run update && git add .",
		"version:ci": "changeset version && env-cmd -e version-ci -- npm run update && git add --all"
	},
	peerDependencies: { "eslint": ">=9.38.0" },
	dependencies: {
		"eslint-json-compat-utils": "^0.2.2",
		"jsonc-eslint-parser": "^3.1.0",
		"npm-package-arg": "^13.0.2",
		"package-json": "^10.0.1",
		"semver": "^7.7.4",
		"synckit": "^0.11.12",
		"undici": "^7.22.0"
	},
	devDependencies: {
		"@changesets/changelog-github": "^0.5.0",
		"@changesets/cli": "^2.24.2",
		"@eslint-community/eslint-utils": "^4.6.1",
		"@ota-meshi/eslint-plugin": "^0.20.0",
		"@oxc-node/core": "^0.0.35",
		"@shikijs/vitepress-twoslash": "^3.0.0",
		"@swc-node/register": "^1.10.10",
		"@types/chai": "^5.0.0",
		"@types/eslint-scope": "^9.0.0",
		"@types/estree": "^1.0.0",
		"@types/global-agent": "^3.0.0",
		"@types/mocha": "^10.0.0",
		"@types/node": "^24.0.0",
		"@types/npm-package-arg": "^6.1.1",
		"@types/semver": "^7.3.8",
		"c8": "^10.0.0",
		"chai": "^6.0.0",
		"clean-pkg-json": "^1.3.0",
		"env-cmd": "^11.0.0",
		"eslint": "^10.0.0",
		"eslint-config-prettier": "^10.0.0",
		"eslint-plugin-eslint-comments": "^3.2.0",
		"eslint-plugin-eslint-plugin": "^7.0.0",
		"eslint-plugin-jsdoc": "^62.0.0",
		"eslint-plugin-json-schema-validator": "^6.0.0",
		"eslint-plugin-jsonc": "^3.0.0",
		"eslint-plugin-n": "^17.0.0",
		"eslint-plugin-node-dependencies": ".",
		"eslint-plugin-prettier": "^5.0.0",
		"eslint-plugin-regexp": "^3.0.0",
		"eslint-plugin-vue": "^10.0.0",
		"eslint-plugin-yml": "^3.0.0",
		"mocha": "^11.0.0",
		"only-allow": "^1.2.1",
		"prettier": "^3.0.0",
		"prettier-plugin-pkg": "^0.21.0",
		"stylelint": "^17.0.0",
		"stylelint-config-recommended-vue": "^1.0.0",
		"stylelint-config-standard": "^40.0.0",
		"stylelint-config-standard-vue": "^1.0.0",
		"stylelint-stylus": "^1.0.0",
		"tsdown": "^0.20.3",
		"twoslash-eslint": "^0.3.0",
		"typescript": "^5.0.0",
		"typescript-eslint": "^8.31.0",
		"vitepress": "^1.0.1"
	},
	overrides: { "@shikijs/types": "^3.0.0" },
	publishConfig: { "access": "public" }
};

//#endregion
//#region lib/meta.ts
var meta_exports = /* @__PURE__ */ __exportAll({
	name: () => name,
	version: () => version
});
const { name, version } = package_default;

//#endregion
//#region lib/index.ts
const configs = {
	recommended: recommendedConfig,
	"flat/recommended": recommendedConfig
};
const rules = rules$1.reduce((obj, r) => {
	obj[r.meta.docs.ruleName] = r;
	return obj;
}, {});
var lib_default = {
	meta: meta_exports,
	configs,
	rules
};

//#endregion
export { configs, lib_default as default, meta_exports as meta, rules };