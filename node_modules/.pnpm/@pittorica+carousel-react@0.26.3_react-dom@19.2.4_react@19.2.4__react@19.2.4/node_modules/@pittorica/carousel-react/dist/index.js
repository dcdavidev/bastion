import { jsx as D, Fragment as ho, jsxs as Jt } from "react/jsx-runtime";
import * as oe from "react";
import { forwardRef as rs, createElement as Ht, createContext as xt, useRef as W, useLayoutEffect as os, useEffect as en, useId as ae, useContext as $, useInsertionEffect as nn, useMemo as Z, useCallback as as, Children as ls, isValidElement as cs, useState as Mt, Fragment as us, Component as fo } from "react";
function hs(t) {
  var e, n, i = "";
  if (typeof t == "string" || typeof t == "number") i += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = hs(t[e])) && (i && (i += " "), i += n);
  } else for (n in t) t[n] && (i && (i += " "), i += n);
  return i;
}
function sn() {
  for (var t, e, n = 0, i = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = hs(t)) && (i && (i += " "), i += e);
  return i;
}
/**
 * @license @tabler/icons-react v3.36.1 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
var po = {
  outline: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  },
  filled: {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "currentColor",
    stroke: "none"
  }
};
/**
 * @license @tabler/icons-react v3.36.1 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
const mo = (t, e, n, i) => {
  const s = rs(
    ({ color: o = "currentColor", size: r = 24, stroke: a = 2, title: l, className: u, children: c, ...h }, f) => Ht(
      "svg",
      {
        ref: f,
        ...po[t],
        width: r,
        height: r,
        className: ["tabler-icon", `tabler-icon-${e}`, u].join(" "),
        strokeWidth: a,
        stroke: o,
        ...h
      },
      [
        l && Ht("title", { key: "svg-title" }, l),
        ...i.map(([d, p]) => Ht(d, p)),
        ...Array.isArray(c) ? c : [c]
      ]
    )
  );
  return s.displayName = `${n}`, s;
};
/**
 * @license @tabler/icons-react v3.36.1 - MIT
 *
 * This source code is licensed under the MIT license.
 * See the LICENSE file in the root directory of this source tree.
 */
const go = [["path", { d: "M18 6l-12 12", key: "svg-0" }], ["path", { d: "M6 6l12 12", key: "svg-1" }]], yo = mo("outline", "x", "X", go), rn = xt({});
function on(t) {
  const e = W(null);
  return e.current === null && (e.current = t()), e.current;
}
const fs = typeof window < "u", ds = fs ? os : en, le = /* @__PURE__ */ xt(null);
function an(t, e) {
  t.indexOf(e) === -1 && t.push(e);
}
function ln(t, e) {
  const n = t.indexOf(e);
  n > -1 && t.splice(n, 1);
}
const q = (t, e, n) => n > e ? e : n < t ? t : n;
function Me(t, e) {
  return e ? `${t}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${e}` : t;
}
let Tt = () => {
}, J = () => {
};
var ss;
typeof process < "u" && ((ss = process.env) == null ? void 0 : ss.NODE_ENV) !== "production" && (Tt = (t, e, n) => {
  !t && typeof console < "u" && console.warn(Me(e, n));
}, J = (t, e, n) => {
  if (!t)
    throw new Error(Me(e, n));
});
const Q = {}, ps = (t) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(t);
function ms(t) {
  return typeof t == "object" && t !== null;
}
const gs = (t) => /^0[^.\s]+$/u.test(t);
// @__NO_SIDE_EFFECTS__
function cn(t) {
  let e;
  return () => (e === void 0 && (e = t()), e);
}
const G = /* @__NO_SIDE_EFFECTS__ */ (t) => t, vo = (t, e) => (n) => e(t(n)), Ot = (...t) => t.reduce(vo), kt = /* @__NO_SIDE_EFFECTS__ */ (t, e, n) => {
  const i = e - t;
  return i === 0 ? 1 : (n - t) / i;
};
class un {
  constructor() {
    this.subscriptions = [];
  }
  add(e) {
    return an(this.subscriptions, e), () => ln(this.subscriptions, e);
  }
  notify(e, n, i) {
    const s = this.subscriptions.length;
    if (s)
      if (s === 1)
        this.subscriptions[0](e, n, i);
      else
        for (let o = 0; o < s; o++) {
          const r = this.subscriptions[o];
          r && r(e, n, i);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const X = /* @__NO_SIDE_EFFECTS__ */ (t) => t * 1e3, z = /* @__NO_SIDE_EFFECTS__ */ (t) => t / 1e3;
function ys(t, e) {
  return e ? t * (1e3 / e) : 0;
}
const On = /* @__PURE__ */ new Set();
function hn(t, e, n) {
  t || On.has(e) || (console.warn(Me(e, n)), On.add(e));
}
const vs = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, xo = 1e-7, To = 12;
function wo(t, e, n, i, s) {
  let o, r, a = 0;
  do
    r = e + (n - e) / 2, o = vs(r, i, s) - t, o > 0 ? n = r : e = r;
  while (Math.abs(o) > xo && ++a < To);
  return r;
}
function jt(t, e, n, i) {
  if (t === e && n === i)
    return G;
  const s = (o) => wo(o, 0, 1, t, n);
  return (o) => o === 0 || o === 1 ? o : vs(s(o), e, i);
}
const xs = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, Ts = (t) => (e) => 1 - t(1 - e), ws = /* @__PURE__ */ jt(0.33, 1.53, 0.69, 0.99), fn = /* @__PURE__ */ Ts(ws), bs = /* @__PURE__ */ xs(fn), Ss = (t) => (t *= 2) < 1 ? 0.5 * fn(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), dn = (t) => 1 - Math.sin(Math.acos(t)), As = Ts(dn), Ps = xs(dn), bo = /* @__PURE__ */ jt(0.42, 0, 1, 1), So = /* @__PURE__ */ jt(0, 0, 0.58, 1), Vs = /* @__PURE__ */ jt(0.42, 0, 0.58, 1), Ao = (t) => Array.isArray(t) && typeof t[0] != "number", Cs = (t) => Array.isArray(t) && typeof t[0] == "number", jn = {
  linear: G,
  easeIn: bo,
  easeInOut: Vs,
  easeOut: So,
  circIn: dn,
  circInOut: Ps,
  circOut: As,
  backIn: fn,
  backInOut: bs,
  backOut: ws,
  anticipate: Ss
}, Po = (t) => typeof t == "string", Wn = (t) => {
  if (Cs(t)) {
    J(t.length === 4, "Cubic bezier arrays must contain four numerical values.", "cubic-bezier-length");
    const [e, n, i, s] = t;
    return jt(e, n, i, s);
  } else if (Po(t))
    return J(jn[t] !== void 0, `Invalid easing type '${t}'`, "invalid-easing-type"), jn[t];
  return t;
}, Kt = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];
function Vo(t, e) {
  let n = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), s = !1, o = !1;
  const r = /* @__PURE__ */ new WeakSet();
  let a = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  };
  function l(c) {
    r.has(c) && (u.schedule(c), t()), c(a);
  }
  const u = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (c, h = !1, f = !1) => {
      const p = f && s ? n : i;
      return h && r.add(c), p.has(c) || p.add(c), c;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (c) => {
      i.delete(c), r.delete(c);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (c) => {
      if (a = c, s) {
        o = !0;
        return;
      }
      s = !0, [n, i] = [i, n], n.forEach(l), n.clear(), s = !1, o && (o = !1, u.process(c));
    }
  };
  return u;
}
const Co = 40;
function Ds(t, e) {
  let n = !1, i = !0;
  const s = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, o = () => n = !0, r = Kt.reduce((y, w) => (y[w] = Vo(o), y), {}), { setup: a, read: l, resolveKeyframes: u, preUpdate: c, update: h, preRender: f, render: d, postRender: p } = r, g = () => {
    const y = Q.useManualTiming ? s.timestamp : performance.now();
    n = !1, Q.useManualTiming || (s.delta = i ? 1e3 / 60 : Math.max(Math.min(y - s.timestamp, Co), 1)), s.timestamp = y, s.isProcessing = !0, a.process(s), l.process(s), u.process(s), c.process(s), h.process(s), f.process(s), d.process(s), p.process(s), s.isProcessing = !1, n && e && (i = !1, t(g));
  }, x = () => {
    n = !0, i = !0, s.isProcessing || t(g);
  };
  return { schedule: Kt.reduce((y, w) => {
    const b = r[w];
    return y[w] = (P, C = !1, A = !1) => (n || x(), b.schedule(P, C, A)), y;
  }, {}), cancel: (y) => {
    for (let w = 0; w < Kt.length; w++)
      r[Kt[w]].cancel(y);
  }, state: s, steps: r };
}
const { schedule: M, cancel: nt, state: F, steps: de } = /* @__PURE__ */ Ds(typeof requestAnimationFrame < "u" ? requestAnimationFrame : G, !0);
let Xt;
function Do() {
  Xt = void 0;
}
const O = {
  now: () => (Xt === void 0 && O.set(F.isProcessing || Q.useManualTiming ? F.timestamp : performance.now()), Xt),
  set: (t) => {
    Xt = t, queueMicrotask(Do);
  }
}, Ms = (t) => (e) => typeof e == "string" && e.startsWith(t), Rs = /* @__PURE__ */ Ms("--"), Mo = /* @__PURE__ */ Ms("var(--"), pn = (t) => Mo(t) ? Ro.test(t.split("/*")[0].trim()) : !1, Ro = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;
function Un(t) {
  return typeof t != "string" ? !1 : t.split("/*")[0].includes("var(--");
}
const wt = {
  test: (t) => typeof t == "number",
  parse: parseFloat,
  transform: (t) => t
}, Bt = {
  ...wt,
  transform: (t) => q(0, 1, t)
}, zt = {
  ...wt,
  default: 1
}, Rt = (t) => Math.round(t * 1e5) / 1e5, mn = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function Eo(t) {
  return t == null;
}
const Lo = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, gn = (t, e) => (n) => !!(typeof n == "string" && Lo.test(n) && n.startsWith(t) || e && !Eo(n) && Object.prototype.hasOwnProperty.call(n, e)), Es = (t, e, n) => (i) => {
  if (typeof i != "string")
    return i;
  const [s, o, r, a] = i.match(mn);
  return {
    [t]: parseFloat(s),
    [e]: parseFloat(o),
    [n]: parseFloat(r),
    alpha: a !== void 0 ? parseFloat(a) : 1
  };
}, ko = (t) => q(0, 255, t), pe = {
  ...wt,
  transform: (t) => Math.round(ko(t))
}, lt = {
  test: /* @__PURE__ */ gn("rgb", "red"),
  parse: /* @__PURE__ */ Es("red", "green", "blue"),
  transform: ({ red: t, green: e, blue: n, alpha: i = 1 }) => "rgba(" + pe.transform(t) + ", " + pe.transform(e) + ", " + pe.transform(n) + ", " + Rt(Bt.transform(i)) + ")"
};
function Bo(t) {
  let e = "", n = "", i = "", s = "";
  return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), i = t.substring(5, 7), s = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), i = t.substring(3, 4), s = t.substring(4, 5), e += e, n += n, i += i, s += s), {
    red: parseInt(e, 16),
    green: parseInt(n, 16),
    blue: parseInt(i, 16),
    alpha: s ? parseInt(s, 16) / 255 : 1
  };
}
const Re = {
  test: /* @__PURE__ */ gn("#"),
  parse: Bo,
  transform: lt.transform
}, Wt = /* @__NO_SIDE_EFFECTS__ */ (t) => ({
  test: (e) => typeof e == "string" && e.endsWith(t) && e.split(" ").length === 1,
  parse: parseFloat,
  transform: (e) => `${e}${t}`
}), tt = /* @__PURE__ */ Wt("deg"), Y = /* @__PURE__ */ Wt("%"), S = /* @__PURE__ */ Wt("px"), Io = /* @__PURE__ */ Wt("vh"), Fo = /* @__PURE__ */ Wt("vw"), Kn = {
  ...Y,
  parse: (t) => Y.parse(t) / 100,
  transform: (t) => Y.transform(t * 100)
}, ft = {
  test: /* @__PURE__ */ gn("hsl", "hue"),
  parse: /* @__PURE__ */ Es("hue", "saturation", "lightness"),
  transform: ({ hue: t, saturation: e, lightness: n, alpha: i = 1 }) => "hsla(" + Math.round(t) + ", " + Y.transform(Rt(e)) + ", " + Y.transform(Rt(n)) + ", " + Rt(Bt.transform(i)) + ")"
}, L = {
  test: (t) => lt.test(t) || Re.test(t) || ft.test(t),
  parse: (t) => lt.test(t) ? lt.parse(t) : ft.test(t) ? ft.parse(t) : Re.parse(t),
  transform: (t) => typeof t == "string" ? t : t.hasOwnProperty("red") ? lt.transform(t) : ft.transform(t),
  getAnimatableNone: (t) => {
    const e = L.parse(t);
    return e.alpha = 0, L.transform(e);
  }
}, $o = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function No(t) {
  var e, n;
  return isNaN(t) && typeof t == "string" && (((e = t.match(mn)) == null ? void 0 : e.length) || 0) + (((n = t.match($o)) == null ? void 0 : n.length) || 0) > 0;
}
const Ls = "number", ks = "color", Oo = "var", jo = "var(", zn = "${}", Wo = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function It(t) {
  const e = t.toString(), n = [], i = {
    color: [],
    number: [],
    var: []
  }, s = [];
  let o = 0;
  const a = e.replace(Wo, (l) => (L.test(l) ? (i.color.push(o), s.push(ks), n.push(L.parse(l))) : l.startsWith(jo) ? (i.var.push(o), s.push(Oo), n.push(l)) : (i.number.push(o), s.push(Ls), n.push(parseFloat(l))), ++o, zn)).split(zn);
  return { values: n, split: a, indexes: i, types: s };
}
function Bs(t) {
  return It(t).values;
}
function Is(t) {
  const { split: e, types: n } = It(t), i = e.length;
  return (s) => {
    let o = "";
    for (let r = 0; r < i; r++)
      if (o += e[r], s[r] !== void 0) {
        const a = n[r];
        a === Ls ? o += Rt(s[r]) : a === ks ? o += L.transform(s[r]) : o += s[r];
      }
    return o;
  };
}
const Uo = (t) => typeof t == "number" ? 0 : L.test(t) ? L.getAnimatableNone(t) : t;
function Ko(t) {
  const e = Bs(t);
  return Is(t)(e.map(Uo));
}
const it = {
  test: No,
  parse: Bs,
  createTransformer: Is,
  getAnimatableNone: Ko
};
function me(t, e, n) {
  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;
}
function zo({ hue: t, saturation: e, lightness: n, alpha: i }) {
  t /= 360, e /= 100, n /= 100;
  let s = 0, o = 0, r = 0;
  if (!e)
    s = o = r = n;
  else {
    const a = n < 0.5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a;
    s = me(l, a, t + 1 / 3), o = me(l, a, t), r = me(l, a, t - 1 / 3);
  }
  return {
    red: Math.round(s * 255),
    green: Math.round(o * 255),
    blue: Math.round(r * 255),
    alpha: i
  };
}
function Qt(t, e) {
  return (n) => n > 0 ? e : t;
}
const E = (t, e, n) => t + (e - t) * n, ge = (t, e, n) => {
  const i = t * t, s = n * (e * e - i) + i;
  return s < 0 ? 0 : Math.sqrt(s);
}, Go = [Re, lt, ft], _o = (t) => Go.find((e) => e.test(t));
function Gn(t) {
  const e = _o(t);
  if (Tt(!!e, `'${t}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable"), !e)
    return !1;
  let n = e.parse(t);
  return e === ft && (n = zo(n)), n;
}
const _n = (t, e) => {
  const n = Gn(t), i = Gn(e);
  if (!n || !i)
    return Qt(t, e);
  const s = { ...n };
  return (o) => (s.red = ge(n.red, i.red, o), s.green = ge(n.green, i.green, o), s.blue = ge(n.blue, i.blue, o), s.alpha = E(n.alpha, i.alpha, o), lt.transform(s));
}, Ee = /* @__PURE__ */ new Set(["none", "hidden"]);
function Ho(t, e) {
  return Ee.has(t) ? (n) => n <= 0 ? t : e : (n) => n >= 1 ? e : t;
}
function Xo(t, e) {
  return (n) => E(t, e, n);
}
function yn(t) {
  return typeof t == "number" ? Xo : typeof t == "string" ? pn(t) ? Qt : L.test(t) ? _n : Zo : Array.isArray(t) ? Fs : typeof t == "object" ? L.test(t) ? _n : Yo : Qt;
}
function Fs(t, e) {
  const n = [...t], i = n.length, s = t.map((o, r) => yn(o)(o, e[r]));
  return (o) => {
    for (let r = 0; r < i; r++)
      n[r] = s[r](o);
    return n;
  };
}
function Yo(t, e) {
  const n = { ...t, ...e }, i = {};
  for (const s in n)
    t[s] !== void 0 && e[s] !== void 0 && (i[s] = yn(t[s])(t[s], e[s]));
  return (s) => {
    for (const o in i)
      n[o] = i[o](s);
    return n;
  };
}
function qo(t, e) {
  const n = [], i = { color: 0, var: 0, number: 0 };
  for (let s = 0; s < e.values.length; s++) {
    const o = e.types[s], r = t.indexes[o][i[o]], a = t.values[r] ?? 0;
    n[s] = a, i[o]++;
  }
  return n;
}
const Zo = (t, e) => {
  const n = it.createTransformer(e), i = It(t), s = It(e);
  return i.indexes.var.length === s.indexes.var.length && i.indexes.color.length === s.indexes.color.length && i.indexes.number.length >= s.indexes.number.length ? Ee.has(t) && !s.values.length || Ee.has(e) && !i.values.length ? Ho(t, e) : Ot(Fs(qo(i, s), s.values), n) : (Tt(!0, `Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different"), Qt(t, e));
};
function $s(t, e, n) {
  return typeof t == "number" && typeof e == "number" && typeof n == "number" ? E(t, e, n) : yn(t)(t, e);
}
const Jo = (t) => {
  const e = ({ timestamp: n }) => t(n);
  return {
    start: (n = !0) => M.update(e, n),
    stop: () => nt(e),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => F.isProcessing ? F.timestamp : O.now()
  };
}, Ns = (t, e, n = 10) => {
  let i = "";
  const s = Math.max(Math.round(e / n), 2);
  for (let o = 0; o < s; o++)
    i += Math.round(t(o / (s - 1)) * 1e4) / 1e4 + ", ";
  return `linear(${i.substring(0, i.length - 2)})`;
}, te = 2e4;
function vn(t) {
  let e = 0;
  const n = 50;
  let i = t.next(e);
  for (; !i.done && e < te; )
    e += n, i = t.next(e);
  return e >= te ? 1 / 0 : e;
}
function Qo(t, e = 100, n) {
  const i = n({ ...t, keyframes: [0, e] }), s = Math.min(vn(i), te);
  return {
    type: "keyframes",
    ease: (o) => i.next(s * o).value / e,
    duration: /* @__PURE__ */ z(s)
  };
}
const ta = 5;
function Os(t, e, n) {
  const i = Math.max(e - ta, 0);
  return ys(n - t(i), e - i);
}
const R = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
}, ye = 1e-3;
function ea({ duration: t = R.duration, bounce: e = R.bounce, velocity: n = R.velocity, mass: i = R.mass }) {
  let s, o;
  Tt(t <= /* @__PURE__ */ X(R.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit");
  let r = 1 - e;
  r = q(R.minDamping, R.maxDamping, r), t = q(R.minDuration, R.maxDuration, /* @__PURE__ */ z(t)), r < 1 ? (s = (u) => {
    const c = u * r, h = c * t, f = c - n, d = Le(u, r), p = Math.exp(-h);
    return ye - f / d * p;
  }, o = (u) => {
    const h = u * r * t, f = h * n + n, d = Math.pow(r, 2) * Math.pow(u, 2) * t, p = Math.exp(-h), g = Le(Math.pow(u, 2), r);
    return (-s(u) + ye > 0 ? -1 : 1) * ((f - d) * p) / g;
  }) : (s = (u) => {
    const c = Math.exp(-u * t), h = (u - n) * t + 1;
    return -ye + c * h;
  }, o = (u) => {
    const c = Math.exp(-u * t), h = (n - u) * (t * t);
    return c * h;
  });
  const a = 5 / t, l = ia(s, o, a);
  if (t = /* @__PURE__ */ X(t), isNaN(l))
    return {
      stiffness: R.stiffness,
      damping: R.damping,
      duration: t
    };
  {
    const u = Math.pow(l, 2) * i;
    return {
      stiffness: u,
      damping: r * 2 * Math.sqrt(i * u),
      duration: t
    };
  }
}
const na = 12;
function ia(t, e, n) {
  let i = n;
  for (let s = 1; s < na; s++)
    i = i - t(i) / e(i);
  return i;
}
function Le(t, e) {
  return t * Math.sqrt(1 - e * e);
}
const sa = ["duration", "bounce"], ra = ["stiffness", "damping", "mass"];
function Hn(t, e) {
  return e.some((n) => t[n] !== void 0);
}
function oa(t) {
  let e = {
    velocity: R.velocity,
    stiffness: R.stiffness,
    damping: R.damping,
    mass: R.mass,
    isResolvedFromDuration: !1,
    ...t
  };
  if (!Hn(t, ra) && Hn(t, sa))
    if (t.visualDuration) {
      const n = t.visualDuration, i = 2 * Math.PI / (n * 1.2), s = i * i, o = 2 * q(0.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(s);
      e = {
        ...e,
        mass: R.mass,
        stiffness: s,
        damping: o
      };
    } else {
      const n = ea(t);
      e = {
        ...e,
        ...n,
        mass: R.mass
      }, e.isResolvedFromDuration = !0;
    }
  return e;
}
function ee(t = R.visualDuration, e = R.bounce) {
  const n = typeof t != "object" ? {
    visualDuration: t,
    keyframes: [0, 1],
    bounce: e
  } : t;
  let { restSpeed: i, restDelta: s } = n;
  const o = n.keyframes[0], r = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: o }, { stiffness: l, damping: u, mass: c, duration: h, velocity: f, isResolvedFromDuration: d } = oa({
    ...n,
    velocity: -/* @__PURE__ */ z(n.velocity || 0)
  }), p = f || 0, g = u / (2 * Math.sqrt(l * c)), x = r - o, v = /* @__PURE__ */ z(Math.sqrt(l / c)), T = Math.abs(x) < 5;
  i || (i = T ? R.restSpeed.granular : R.restSpeed.default), s || (s = T ? R.restDelta.granular : R.restDelta.default);
  let y;
  if (g < 1) {
    const b = Le(v, g);
    y = (P) => {
      const C = Math.exp(-g * v * P);
      return r - C * ((p + g * v * x) / b * Math.sin(b * P) + x * Math.cos(b * P));
    };
  } else if (g === 1)
    y = (b) => r - Math.exp(-v * b) * (x + (p + v * x) * b);
  else {
    const b = v * Math.sqrt(g * g - 1);
    y = (P) => {
      const C = Math.exp(-g * v * P), A = Math.min(b * P, 300);
      return r - C * ((p + g * v * x) * Math.sinh(A) + b * x * Math.cosh(A)) / b;
    };
  }
  const w = {
    calculatedDuration: d && h || null,
    next: (b) => {
      const P = y(b);
      if (d)
        a.done = b >= h;
      else {
        let C = b === 0 ? p : 0;
        g < 1 && (C = b === 0 ? /* @__PURE__ */ X(p) : Os(y, b, P));
        const A = Math.abs(C) <= i, V = Math.abs(r - P) <= s;
        a.done = A && V;
      }
      return a.value = a.done ? r : P, a;
    },
    toString: () => {
      const b = Math.min(vn(w), te), P = Ns((C) => w.next(b * C).value, b, 30);
      return b + "ms " + P;
    },
    toTransition: () => {
    }
  };
  return w;
}
ee.applyToOptions = (t) => {
  const e = Qo(t, 100, ee);
  return t.ease = e.ease, t.duration = /* @__PURE__ */ X(e.duration), t.type = "keyframes", t;
};
function ke({ keyframes: t, velocity: e = 0, power: n = 0.8, timeConstant: i = 325, bounceDamping: s = 10, bounceStiffness: o = 500, modifyTarget: r, min: a, max: l, restDelta: u = 0.5, restSpeed: c }) {
  const h = t[0], f = {
    done: !1,
    value: h
  }, d = (A) => a !== void 0 && A < a || l !== void 0 && A > l, p = (A) => a === void 0 ? l : l === void 0 || Math.abs(a - A) < Math.abs(l - A) ? a : l;
  let g = n * e;
  const x = h + g, v = r === void 0 ? x : r(x);
  v !== x && (g = v - h);
  const T = (A) => -g * Math.exp(-A / i), y = (A) => v + T(A), w = (A) => {
    const V = T(A), m = y(A);
    f.done = Math.abs(V) <= u, f.value = f.done ? v : m;
  };
  let b, P;
  const C = (A) => {
    d(f.value) && (b = A, P = ee({
      keyframes: [f.value, p(f.value)],
      velocity: Os(y, A, f.value),
      // TODO: This should be passing * 1000
      damping: s,
      stiffness: o,
      restDelta: u,
      restSpeed: c
    }));
  };
  return C(0), {
    calculatedDuration: null,
    next: (A) => {
      let V = !1;
      return !P && b === void 0 && (V = !0, w(A), C(A)), b !== void 0 && A >= b ? P.next(A - b) : (!V && w(A), f);
    }
  };
}
function aa(t, e, n) {
  const i = [], s = n || Q.mix || $s, o = t.length - 1;
  for (let r = 0; r < o; r++) {
    let a = s(t[r], t[r + 1]);
    if (e) {
      const l = Array.isArray(e) ? e[r] || G : e;
      a = Ot(l, a);
    }
    i.push(a);
  }
  return i;
}
function la(t, e, { clamp: n = !0, ease: i, mixer: s } = {}) {
  const o = t.length;
  if (J(o === e.length, "Both input and output ranges must be the same length", "range-length"), o === 1)
    return () => e[0];
  if (o === 2 && e[0] === e[1])
    return () => e[1];
  const r = t[0] === t[1];
  t[0] > t[o - 1] && (t = [...t].reverse(), e = [...e].reverse());
  const a = aa(e, i, s), l = a.length, u = (c) => {
    if (r && c < t[0])
      return e[0];
    let h = 0;
    if (l > 1)
      for (; h < t.length - 2 && !(c < t[h + 1]); h++)
        ;
    const f = /* @__PURE__ */ kt(t[h], t[h + 1], c);
    return a[h](f);
  };
  return n ? (c) => u(q(t[0], t[o - 1], c)) : u;
}
function ca(t, e) {
  const n = t[t.length - 1];
  for (let i = 1; i <= e; i++) {
    const s = /* @__PURE__ */ kt(0, e, i);
    t.push(E(n, 1, s));
  }
}
function ua(t) {
  const e = [0];
  return ca(e, t.length - 1), e;
}
function ha(t, e) {
  return t.map((n) => n * e);
}
function fa(t, e) {
  return t.map(() => e || Vs).splice(0, t.length - 1);
}
function dt({ duration: t = 300, keyframes: e, times: n, ease: i = "easeInOut" }) {
  const s = Ao(i) ? i.map(Wn) : Wn(i), o = {
    done: !1,
    value: e[0]
  }, r = ha(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    n && n.length === e.length ? n : ua(e),
    t
  ), a = la(r, e, {
    ease: Array.isArray(s) ? s : fa(e, s)
  });
  return {
    calculatedDuration: t,
    next: (l) => (o.value = a(l), o.done = l >= t, o)
  };
}
const da = (t) => t !== null;
function xn(t, { repeat: e, repeatType: n = "loop" }, i, s = 1) {
  const o = t.filter(da), a = s < 0 || e && n !== "loop" && e % 2 === 1 ? 0 : o.length - 1;
  return !a || i === void 0 ? o[a] : i;
}
const pa = {
  decay: ke,
  inertia: ke,
  tween: dt,
  keyframes: dt,
  spring: ee
};
function js(t) {
  typeof t.type == "string" && (t.type = pa[t.type]);
}
class Tn {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((e) => {
      this.resolve = e;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(e, n) {
    return this.finished.then(e, n);
  }
}
const ma = (t) => t / 100;
class wn extends Tn {
  constructor(e) {
    super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
      var i, s;
      const { motionValue: n } = this.options;
      n && n.updatedAt !== O.now() && this.tick(O.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (s = (i = this.options).onStop) == null || s.call(i));
    }, this.options = e, this.initAnimation(), this.play(), e.autoplay === !1 && this.pause();
  }
  initAnimation() {
    const { options: e } = this;
    js(e);
    const { type: n = dt, repeat: i = 0, repeatDelay: s = 0, repeatType: o, velocity: r = 0 } = e;
    let { keyframes: a } = e;
    const l = n || dt;
    process.env.NODE_ENV !== "production" && l !== dt && J(a.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${a}`, "spring-two-frames"), l !== dt && typeof a[0] != "number" && (this.mixKeyframes = Ot(ma, $s(a[0], a[1])), a = [0, 100]);
    const u = l({ ...e, keyframes: a });
    o === "mirror" && (this.mirroredGenerator = l({
      ...e,
      keyframes: [...a].reverse(),
      velocity: -r
    })), u.calculatedDuration === null && (u.calculatedDuration = vn(u));
    const { calculatedDuration: c } = u;
    this.calculatedDuration = c, this.resolvedDuration = c + s, this.totalDuration = this.resolvedDuration * (i + 1) - s, this.generator = u;
  }
  updateTime(e) {
    const n = Math.round(e - this.startTime) * this.playbackSpeed;
    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;
  }
  tick(e, n = !1) {
    const { generator: i, totalDuration: s, mixKeyframes: o, mirroredGenerator: r, resolvedDuration: a, calculatedDuration: l } = this;
    if (this.startTime === null)
      return i.next(0);
    const { delay: u = 0, keyframes: c, repeat: h, repeatType: f, repeatDelay: d, type: p, onUpdate: g, finalKeyframe: x } = this.options;
    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - s / this.speed, this.startTime)), n ? this.currentTime = e : this.updateTime(e);
    const v = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1), T = this.playbackSpeed >= 0 ? v < 0 : v > s;
    this.currentTime = Math.max(v, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = s);
    let y = this.currentTime, w = i;
    if (h) {
      const A = Math.min(this.currentTime, s) / a;
      let V = Math.floor(A), m = A % 1;
      !m && A >= 1 && (m = 1), m === 1 && V--, V = Math.min(V, h + 1), !!(V % 2) && (f === "reverse" ? (m = 1 - m, d && (m -= d / a)) : f === "mirror" && (w = r)), y = q(0, 1, m) * a;
    }
    const b = T ? { done: !1, value: c[0] } : w.next(y);
    o && (b.value = o(b.value));
    let { done: P } = b;
    !T && l !== null && (P = this.playbackSpeed >= 0 ? this.currentTime >= s : this.currentTime <= 0);
    const C = this.holdTime === null && (this.state === "finished" || this.state === "running" && P);
    return C && p !== ke && (b.value = xn(c, this.options, x, this.speed)), g && g(b.value), C && this.finish(), b;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(e, n) {
    return this.finished.then(e, n);
  }
  get duration() {
    return /* @__PURE__ */ z(this.calculatedDuration);
  }
  get iterationDuration() {
    const { delay: e = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ z(e);
  }
  get time() {
    return /* @__PURE__ */ z(this.currentTime);
  }
  set time(e) {
    var n;
    e = /* @__PURE__ */ X(e), this.currentTime = e, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.playbackSpeed), (n = this.driver) == null || n.start(!1);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(e) {
    this.updateTime(O.now());
    const n = this.playbackSpeed !== e;
    this.playbackSpeed = e, n && (this.time = /* @__PURE__ */ z(this.currentTime));
  }
  play() {
    var s, o;
    if (this.isStopped)
      return;
    const { driver: e = Jo, startTime: n } = this.options;
    this.driver || (this.driver = e((r) => this.tick(r))), (o = (s = this.options).onPlay) == null || o.call(s);
    const i = this.driver.now();
    this.state === "finished" ? (this.updateFinished(), this.startTime = i) : this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime || (this.startTime = n ?? i), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start();
  }
  pause() {
    this.state = "paused", this.updateTime(O.now()), this.holdTime = this.currentTime;
  }
  complete() {
    this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null;
  }
  finish() {
    var e, n;
    this.notifyFinished(), this.teardown(), this.state = "finished", (n = (e = this.options).onComplete) == null || n.call(e);
  }
  cancel() {
    var e, n;
    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (e = this.options).onCancel) == null || n.call(e);
  }
  teardown() {
    this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null;
  }
  stopDriver() {
    this.driver && (this.driver.stop(), this.driver = void 0);
  }
  sample(e) {
    return this.startTime = 0, this.tick(e, !0);
  }
  attachTimeline(e) {
    var n;
    return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), e.observe(this);
  }
}
function ga(t) {
  for (let e = 1; e < t.length; e++)
    t[e] ?? (t[e] = t[e - 1]);
}
const ct = (t) => t * 180 / Math.PI, Be = (t) => {
  const e = ct(Math.atan2(t[1], t[0]));
  return Ie(e);
}, ya = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (t) => (Math.abs(t[0]) + Math.abs(t[3])) / 2,
  rotate: Be,
  rotateZ: Be,
  skewX: (t) => ct(Math.atan(t[1])),
  skewY: (t) => ct(Math.atan(t[2])),
  skew: (t) => (Math.abs(t[1]) + Math.abs(t[2])) / 2
}, Ie = (t) => (t = t % 360, t < 0 && (t += 360), t), Xn = Be, Yn = (t) => Math.sqrt(t[0] * t[0] + t[1] * t[1]), qn = (t) => Math.sqrt(t[4] * t[4] + t[5] * t[5]), va = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX: Yn,
  scaleY: qn,
  scale: (t) => (Yn(t) + qn(t)) / 2,
  rotateX: (t) => Ie(ct(Math.atan2(t[6], t[5]))),
  rotateY: (t) => Ie(ct(Math.atan2(-t[2], t[0]))),
  rotateZ: Xn,
  rotate: Xn,
  skewX: (t) => ct(Math.atan(t[4])),
  skewY: (t) => ct(Math.atan(t[1])),
  skew: (t) => (Math.abs(t[1]) + Math.abs(t[4])) / 2
};
function Fe(t) {
  return t.includes("scale") ? 1 : 0;
}
function $e(t, e) {
  if (!t || t === "none")
    return Fe(e);
  const n = t.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let i, s;
  if (n)
    i = va, s = n;
  else {
    const a = t.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    i = ya, s = a;
  }
  if (!s)
    return Fe(e);
  const o = i[e], r = s[1].split(",").map(Ta);
  return typeof o == "function" ? o(r) : r[o];
}
const xa = (t, e) => {
  const { transform: n = "none" } = getComputedStyle(t);
  return $e(n, e);
};
function Ta(t) {
  return parseFloat(t.trim());
}
const bt = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], St = new Set(bt), Zn = (t) => t === wt || t === S, wa = /* @__PURE__ */ new Set(["x", "y", "z"]), ba = bt.filter((t) => !wa.has(t));
function Sa(t) {
  const e = [];
  return ba.forEach((n) => {
    const i = t.getValue(n);
    i !== void 0 && (e.push([n, i.get()]), i.set(n.startsWith("scale") ? 1 : 0));
  }), e;
}
const et = {
  // Dimensions
  width: ({ x: t }, { paddingLeft: e = "0", paddingRight: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  height: ({ y: t }, { paddingTop: e = "0", paddingBottom: n = "0" }) => t.max - t.min - parseFloat(e) - parseFloat(n),
  top: (t, { top: e }) => parseFloat(e),
  left: (t, { left: e }) => parseFloat(e),
  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),
  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),
  // Transform
  x: (t, { transform: e }) => $e(e, "x"),
  y: (t, { transform: e }) => $e(e, "y")
};
et.translateX = et.x;
et.translateY = et.y;
const ut = /* @__PURE__ */ new Set();
let Ne = !1, Oe = !1, je = !1;
function Ws() {
  if (Oe) {
    const t = Array.from(ut).filter((i) => i.needsMeasurement), e = new Set(t.map((i) => i.element)), n = /* @__PURE__ */ new Map();
    e.forEach((i) => {
      const s = Sa(i);
      s.length && (n.set(i, s), i.render());
    }), t.forEach((i) => i.measureInitialState()), e.forEach((i) => {
      i.render();
      const s = n.get(i);
      s && s.forEach(([o, r]) => {
        var a;
        (a = i.getValue(o)) == null || a.set(r);
      });
    }), t.forEach((i) => i.measureEndState()), t.forEach((i) => {
      i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY);
    });
  }
  Oe = !1, Ne = !1, ut.forEach((t) => t.complete(je)), ut.clear();
}
function Us() {
  ut.forEach((t) => {
    t.readKeyframes(), t.needsMeasurement && (Oe = !0);
  });
}
function Aa() {
  je = !0, Us(), Ws(), je = !1;
}
class bn {
  constructor(e, n, i, s, o, r = !1) {
    this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = i, this.motionValue = s, this.element = o, this.isAsync = r;
  }
  scheduleResolve() {
    this.state = "scheduled", this.isAsync ? (ut.add(this), Ne || (Ne = !0, M.read(Us), M.resolveKeyframes(Ws))) : (this.readKeyframes(), this.complete());
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, name: n, element: i, motionValue: s } = this;
    if (e[0] === null) {
      const o = s == null ? void 0 : s.get(), r = e[e.length - 1];
      if (o !== void 0)
        e[0] = o;
      else if (i && n) {
        const a = i.readValue(n, r);
        a != null && (e[0] = a);
      }
      e[0] === void 0 && (e[0] = r), s && o === void 0 && s.set(e[0]);
    }
    ga(e);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(e = !1) {
    this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e), ut.delete(this);
  }
  cancel() {
    this.state === "scheduled" && (ut.delete(this), this.state = "pending");
  }
  resume() {
    this.state === "pending" && this.scheduleResolve();
  }
}
const Pa = (t) => t.startsWith("--");
function Va(t, e, n) {
  Pa(e) ? t.style.setProperty(e, n) : t.style[e] = n;
}
const Ca = /* @__PURE__ */ cn(() => window.ScrollTimeline !== void 0), Da = {};
function Ma(t, e) {
  const n = /* @__PURE__ */ cn(t);
  return () => Da[e] ?? n();
}
const Ks = /* @__PURE__ */ Ma(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch {
    return !1;
  }
  return !0;
}, "linearEasing"), Ct = ([t, e, n, i]) => `cubic-bezier(${t}, ${e}, ${n}, ${i})`, Jn = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: /* @__PURE__ */ Ct([0, 0.65, 0.55, 1]),
  circOut: /* @__PURE__ */ Ct([0.55, 0, 1, 0.45]),
  backIn: /* @__PURE__ */ Ct([0.31, 0.01, 0.66, -0.59]),
  backOut: /* @__PURE__ */ Ct([0.33, 1.53, 0.69, 0.99])
};
function zs(t, e) {
  if (t)
    return typeof t == "function" ? Ks() ? Ns(t, e) : "ease-out" : Cs(t) ? Ct(t) : Array.isArray(t) ? t.map((n) => zs(n, e) || Jn.easeOut) : Jn[t];
}
function Ra(t, e, n, { delay: i = 0, duration: s = 300, repeat: o = 0, repeatType: r = "loop", ease: a = "easeOut", times: l } = {}, u = void 0) {
  const c = {
    [e]: n
  };
  l && (c.offset = l);
  const h = zs(a, s);
  Array.isArray(h) && (c.easing = h);
  const f = {
    delay: i,
    duration: s,
    easing: Array.isArray(h) ? "linear" : h,
    fill: "both",
    iterations: o + 1,
    direction: r === "reverse" ? "alternate" : "normal"
  };
  return u && (f.pseudoElement = u), t.animate(c, f);
}
function Gs(t) {
  return typeof t == "function" && "applyToOptions" in t;
}
function Ea({ type: t, ...e }) {
  return Gs(t) && Ks() ? t.applyToOptions(e) : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = "easeOut"), e);
}
class La extends Tn {
  constructor(e) {
    if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !e)
      return;
    const { element: n, name: i, keyframes: s, pseudoElement: o, allowFlatten: r = !1, finalKeyframe: a, onComplete: l } = e;
    this.isPseudoElement = !!o, this.allowFlatten = r, this.options = e, J(typeof e.type != "string", `Mini animate() doesn't support "type" as a string.`, "mini-spring");
    const u = Ea(e);
    this.animation = Ra(n, i, s, u, o), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
      if (this.finishedTime = this.time, !o) {
        const c = xn(s, this.options, a, this.speed);
        this.updateMotionValue ? this.updateMotionValue(c) : Va(n, i, c), this.animation.cancel();
      }
      l == null || l(), this.notifyFinished();
    };
  }
  play() {
    this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished());
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var e, n;
    (n = (e = this.animation).finish) == null || n.call(e);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = !0;
    const { state: e } = this;
    e === "idle" || e === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var n, i, s;
    const e = (n = this.options) == null ? void 0 : n.element;
    !this.isPseudoElement && (e != null && e.isConnected) && ((s = (i = this.animation).commitStyles) == null || s.call(i));
  }
  get duration() {
    var n, i;
    const e = ((i = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null ? void 0 : i.call(n).duration) || 0;
    return /* @__PURE__ */ z(Number(e));
  }
  get iterationDuration() {
    const { delay: e = 0 } = this.options || {};
    return this.duration + /* @__PURE__ */ z(e);
  }
  get time() {
    return /* @__PURE__ */ z(Number(this.animation.currentTime) || 0);
  }
  set time(e) {
    this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ X(e);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(e) {
    e < 0 && (this.finishedTime = null), this.animation.playbackRate = e;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return this.manualStartTime ?? Number(this.animation.startTime);
  }
  set startTime(e) {
    this.manualStartTime = this.animation.startTime = e;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline: e, observe: n }) {
    var i;
    return this.allowFlatten && ((i = this.animation.effect) == null || i.updateTiming({ easing: "linear" })), this.animation.onfinish = null, e && Ca() ? (this.animation.timeline = e, G) : n(this);
  }
}
const _s = {
  anticipate: Ss,
  backInOut: bs,
  circInOut: Ps
};
function ka(t) {
  return t in _s;
}
function Ba(t) {
  typeof t.ease == "string" && ka(t.ease) && (t.ease = _s[t.ease]);
}
const ve = 10;
class Ia extends La {
  constructor(e) {
    Ba(e), js(e), super(e), e.startTime !== void 0 && (this.startTime = e.startTime), this.options = e;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read committed styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(e) {
    const { motionValue: n, onUpdate: i, onComplete: s, element: o, ...r } = this.options;
    if (!n)
      return;
    if (e !== void 0) {
      n.set(e);
      return;
    }
    const a = new wn({
      ...r,
      autoplay: !1
    }), l = Math.max(ve, O.now() - this.startTime), u = q(0, ve, l - ve);
    n.setWithVelocity(a.sample(Math.max(0, l - u)).value, a.sample(l).value, u), a.stop();
  }
}
const Qn = (t, e) => e === "zIndex" ? !1 : !!(typeof t == "number" || Array.isArray(t) || typeof t == "string" && // It's animatable if we have a string
(it.test(t) || t === "0") && // And it contains numbers and/or colors
!t.startsWith("url("));
function Fa(t) {
  const e = t[0];
  if (t.length === 1)
    return !0;
  for (let n = 0; n < t.length; n++)
    if (t[n] !== e)
      return !0;
}
function $a(t, e, n, i) {
  const s = t[0];
  if (s === null)
    return !1;
  if (e === "display" || e === "visibility")
    return !0;
  const o = t[t.length - 1], r = Qn(s, e), a = Qn(o, e);
  return Tt(r === a, `You are trying to animate ${e} from "${s}" to "${o}". "${r ? o : s}" is not an animatable value.`, "value-not-animatable"), !r || !a ? !1 : Fa(t) || (n === "spring" || Gs(n)) && i;
}
function We(t) {
  t.duration = 0, t.type = "keyframes";
}
const Na = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]), Oa = /* @__PURE__ */ cn(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function ja(t) {
  var c;
  const { motionValue: e, name: n, repeatDelay: i, repeatType: s, damping: o, type: r } = t;
  if (!(((c = e == null ? void 0 : e.owner) == null ? void 0 : c.current) instanceof HTMLElement))
    return !1;
  const { onUpdate: l, transformTemplate: u } = e.owner.getProps();
  return Oa() && n && Na.has(n) && (n !== "transform" || !u) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !l && !i && s !== "mirror" && o !== 0 && r !== "inertia";
}
const Wa = 40;
class Ua extends Tn {
  constructor({ autoplay: e = !0, delay: n = 0, type: i = "keyframes", repeat: s = 0, repeatDelay: o = 0, repeatType: r = "loop", keyframes: a, name: l, motionValue: u, element: c, ...h }) {
    var p;
    super(), this.stop = () => {
      var g, x;
      this._animation && (this._animation.stop(), (g = this.stopTimeline) == null || g.call(this)), (x = this.keyframeResolver) == null || x.cancel();
    }, this.createdAt = O.now();
    const f = {
      autoplay: e,
      delay: n,
      type: i,
      repeat: s,
      repeatDelay: o,
      repeatType: r,
      name: l,
      motionValue: u,
      element: c,
      ...h
    }, d = (c == null ? void 0 : c.KeyframeResolver) || bn;
    this.keyframeResolver = new d(a, (g, x, v) => this.onKeyframesResolved(g, x, f, !v), l, u, c), (p = this.keyframeResolver) == null || p.scheduleResolve();
  }
  onKeyframesResolved(e, n, i, s) {
    var x, v;
    this.keyframeResolver = void 0;
    const { name: o, type: r, velocity: a, delay: l, isHandoff: u, onUpdate: c } = i;
    this.resolvedAt = O.now(), $a(e, o, r, a) || ((Q.instantAnimations || !l) && (c == null || c(xn(e, i, n))), e[0] = e[e.length - 1], We(i), i.repeat = 0);
    const f = {
      startTime: s ? this.resolvedAt ? this.resolvedAt - this.createdAt > Wa ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
      finalKeyframe: n,
      ...i,
      keyframes: e
    }, d = !u && ja(f), p = (v = (x = f.motionValue) == null ? void 0 : x.owner) == null ? void 0 : v.current, g = d ? new Ia({
      ...f,
      element: p
    }) : new wn(f);
    g.finished.then(() => {
      this.notifyFinished();
    }).catch(G), this.pendingTimeline && (this.stopTimeline = g.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = g;
  }
  get finished() {
    return this._animation ? this.animation.finished : this._finished;
  }
  then(e, n) {
    return this.finished.finally(e).then(() => {
    });
  }
  get animation() {
    var e;
    return this._animation || ((e = this.keyframeResolver) == null || e.resume(), Aa()), this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get iterationDuration() {
    return this.animation.iterationDuration;
  }
  get time() {
    return this.animation.time;
  }
  set time(e) {
    this.animation.time = e;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(e) {
    this.animation.speed = e;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(e) {
    return this._animation ? this.stopTimeline = this.animation.attachTimeline(e) : this.pendingTimeline = e, () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var e;
    this._animation && this.animation.cancel(), (e = this.keyframeResolver) == null || e.cancel();
  }
}
function Hs(t, e, n, i = 0, s = 1) {
  const o = Array.from(t).sort((u, c) => u.sortNodePosition(c)).indexOf(e), r = t.size, a = (r - 1) * i;
  return typeof n == "function" ? n(o, r) : s === 1 ? o * i : a - o * i;
}
const Ka = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function za(t) {
  const e = Ka.exec(t);
  if (!e)
    return [,];
  const [, n, i, s] = e;
  return [`--${n ?? i}`, s];
}
const Ga = 4;
function Xs(t, e, n = 1) {
  J(n <= Ga, `Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`, "max-css-var-depth");
  const [i, s] = za(t);
  if (!i)
    return;
  const o = window.getComputedStyle(e).getPropertyValue(i);
  if (o) {
    const r = o.trim();
    return ps(r) ? parseFloat(r) : r;
  }
  return pn(s) ? Xs(s, e, n + 1) : s;
}
const _a = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, Ha = (t) => ({
  type: "spring",
  stiffness: 550,
  damping: t === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), Xa = {
  type: "keyframes",
  duration: 0.8
}, Ya = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, qa = (t, { keyframes: e }) => e.length > 2 ? Xa : St.has(t) ? t.startsWith("scale") ? Ha(e[1]) : _a : Ya, Za = (t) => t !== null;
function Ja(t, { repeat: e, repeatType: n = "loop" }, i) {
  const s = t.filter(Za), o = e && n !== "loop" && e % 2 === 1 ? 0 : s.length - 1;
  return s[o];
}
function Sn(t, e) {
  return (t == null ? void 0 : t[e]) ?? (t == null ? void 0 : t.default) ?? t;
}
function Qa({ when: t, delay: e, delayChildren: n, staggerChildren: i, staggerDirection: s, repeat: o, repeatType: r, repeatDelay: a, from: l, elapsed: u, ...c }) {
  return !!Object.keys(c).length;
}
const An = (t, e, n, i = {}, s, o) => (r) => {
  const a = Sn(i, t) || {}, l = a.delay || i.delay || 0;
  let { elapsed: u = 0 } = i;
  u = u - /* @__PURE__ */ X(l);
  const c = {
    keyframes: Array.isArray(n) ? n : [null, n],
    ease: "easeOut",
    velocity: e.getVelocity(),
    ...a,
    delay: -u,
    onUpdate: (f) => {
      e.set(f), a.onUpdate && a.onUpdate(f);
    },
    onComplete: () => {
      r(), a.onComplete && a.onComplete();
    },
    name: t,
    motionValue: e,
    element: o ? void 0 : s
  };
  Qa(a) || Object.assign(c, qa(t, c)), c.duration && (c.duration = /* @__PURE__ */ X(c.duration)), c.repeatDelay && (c.repeatDelay = /* @__PURE__ */ X(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from);
  let h = !1;
  if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (We(c), c.delay === 0 && (h = !0)), (Q.instantAnimations || Q.skipAnimations || s != null && s.shouldSkipAnimations) && (h = !0, We(c), c.delay = 0), c.allowFlatten = !a.type && !a.ease, h && !o && e.get() !== void 0) {
    const f = Ja(c.keyframes, a);
    if (f !== void 0) {
      M.update(() => {
        c.onUpdate(f), c.onComplete();
      });
      return;
    }
  }
  return a.isSync ? new wn(c) : new Ua(c);
};
function ti(t) {
  const e = [{}, {}];
  return t == null || t.values.forEach((n, i) => {
    e[0][i] = n.get(), e[1][i] = n.getVelocity();
  }), e;
}
function Pn(t, e, n, i) {
  if (typeof e == "function") {
    const [s, o] = ti(i);
    e = e(n !== void 0 ? n : t.custom, s, o);
  }
  if (typeof e == "string" && (e = t.variants && t.variants[e]), typeof e == "function") {
    const [s, o] = ti(i);
    e = e(n !== void 0 ? n : t.custom, s, o);
  }
  return e;
}
function yt(t, e, n) {
  const i = t.getProps();
  return Pn(i, e, n !== void 0 ? n : i.custom, t);
}
const Ys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...bt
]), ei = 30, tl = (t) => !isNaN(parseFloat(t));
class el {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(e, n = {}) {
    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (i) => {
      var o;
      const s = O.now();
      if (this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(i), this.current !== this.prev && ((o = this.events.change) == null || o.notify(this.current), this.dependents))
        for (const r of this.dependents)
          r.dirty();
    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner;
  }
  setCurrent(e) {
    this.current = e, this.updatedAt = O.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = tl(this.current));
  }
  setPrevFrameValue(e = this.current) {
    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(e) {
    return process.env.NODE_ENV !== "production" && hn(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", e);
  }
  on(e, n) {
    this.events[e] || (this.events[e] = new un());
    const i = this.events[e].add(n);
    return e === "change" ? () => {
      i(), M.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : i;
  }
  clearListeners() {
    for (const e in this.events)
      this.events[e].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(e, n) {
    this.passiveEffect = e, this.stopPassiveEffect = n;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(e) {
    this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e);
  }
  setWithVelocity(e, n, i) {
    this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - i;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(e, n = !0) {
    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  dirty() {
    var e;
    (e = this.events.change) == null || e.notify(this.current);
  }
  addDependent(e) {
    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(e);
  }
  removeDependent(e) {
    this.dependents && this.dependents.delete(e);
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const e = O.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > ei)
      return 0;
    const n = Math.min(this.updatedAt - this.prevUpdatedAt, ei);
    return ys(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(e) {
    return this.stop(), new Promise((n) => {
      this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var e, n;
    (e = this.dependents) == null || e.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function vt(t, e) {
  return new el(t, e);
}
const Ue = (t) => Array.isArray(t);
function nl(t, e, n) {
  t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, vt(n));
}
function il(t) {
  return Ue(t) ? t[t.length - 1] || 0 : t;
}
function sl(t, e) {
  const n = yt(t, e);
  let { transitionEnd: i = {}, transition: s = {}, ...o } = n || {};
  o = { ...o, ...i };
  for (const r in o) {
    const a = il(o[r]);
    nl(t, r, a);
  }
}
const N = (t) => !!(t && t.getVelocity);
function rl(t) {
  return !!(N(t) && t.add);
}
function Ke(t, e) {
  const n = t.getValue("willChange");
  if (rl(n))
    return n.add(e);
  if (!n && Q.WillChange) {
    const i = new Q.WillChange("auto");
    t.addValue("willChange", i), i.add(e);
  }
}
function Vn(t) {
  return t.replace(/([A-Z])/g, (e) => `-${e.toLowerCase()}`);
}
const ol = "framerAppearId", qs = "data-" + Vn(ol);
function Zs(t) {
  return t.props[qs];
}
function al({ protectedKeys: t, needsAnimating: e }, n) {
  const i = t.hasOwnProperty(n) && e[n] !== !0;
  return e[n] = !1, i;
}
function Js(t, e, { delay: n = 0, transitionOverride: i, type: s } = {}) {
  let { transition: o = t.getDefaultTransition(), transitionEnd: r, ...a } = e;
  const l = o == null ? void 0 : o.reduceMotion;
  i && (o = i);
  const u = [], c = s && t.animationState && t.animationState.getState()[s];
  for (const h in a) {
    const f = t.getValue(h, t.latestValues[h] ?? null), d = a[h];
    if (d === void 0 || c && al(c, h))
      continue;
    const p = {
      delay: n,
      ...Sn(o || {}, h)
    }, g = f.get();
    if (g !== void 0 && !f.isAnimating && !Array.isArray(d) && d === g && !p.velocity)
      continue;
    let x = !1;
    if (window.MotionHandoffAnimation) {
      const y = Zs(t);
      if (y) {
        const w = window.MotionHandoffAnimation(y, h, M);
        w !== null && (p.startTime = w, x = !0);
      }
    }
    Ke(t, h);
    const v = l ?? t.shouldReduceMotion;
    f.start(An(h, f, d, v && Ys.has(h) ? { type: !1 } : p, t, x));
    const T = f.animation;
    T && u.push(T);
  }
  return r && Promise.all(u).then(() => {
    M.update(() => {
      r && sl(t, r);
    });
  }), u;
}
function ze(t, e, n = {}) {
  var l;
  const i = yt(t, e, n.type === "exit" ? (l = t.presenceContext) == null ? void 0 : l.custom : void 0);
  let { transition: s = t.getDefaultTransition() || {} } = i || {};
  n.transitionOverride && (s = n.transitionOverride);
  const o = i ? () => Promise.all(Js(t, i, n)) : () => Promise.resolve(), r = t.variantChildren && t.variantChildren.size ? (u = 0) => {
    const { delayChildren: c = 0, staggerChildren: h, staggerDirection: f } = s;
    return ll(t, e, u, c, h, f, n);
  } : () => Promise.resolve(), { when: a } = s;
  if (a) {
    const [u, c] = a === "beforeChildren" ? [o, r] : [r, o];
    return u().then(() => c());
  } else
    return Promise.all([o(), r(n.delay)]);
}
function ll(t, e, n = 0, i = 0, s = 0, o = 1, r) {
  const a = [];
  for (const l of t.variantChildren)
    l.notify("AnimationStart", e), a.push(ze(l, e, {
      ...r,
      delay: n + (typeof i == "function" ? 0 : i) + Hs(t.variantChildren, l, i, s, o)
    }).then(() => l.notify("AnimationComplete", e)));
  return Promise.all(a);
}
function cl(t, e, n = {}) {
  t.notify("AnimationStart", e);
  let i;
  if (Array.isArray(e)) {
    const s = e.map((o) => ze(t, o, n));
    i = Promise.all(s);
  } else if (typeof e == "string")
    i = ze(t, e, n);
  else {
    const s = typeof e == "function" ? yt(t, e, n.custom) : e;
    i = Promise.all(Js(t, s, n));
  }
  return i.then(() => {
    t.notify("AnimationComplete", e);
  });
}
const ul = {
  test: (t) => t === "auto",
  parse: (t) => t
}, Qs = (t) => (e) => e.test(t), tr = [wt, S, Y, tt, Fo, Io, ul], ni = (t) => tr.find(Qs(t));
function hl(t) {
  return typeof t == "number" ? t === 0 : t !== null ? t === "none" || t === "0" || gs(t) : !0;
}
const fl = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function dl(t) {
  const [e, n] = t.slice(0, -1).split("(");
  if (e === "drop-shadow")
    return t;
  const [i] = n.match(mn) || [];
  if (!i)
    return t;
  const s = n.replace(i, "");
  let o = fl.has(e) ? 1 : 0;
  return i !== n && (o *= 100), e + "(" + o + s + ")";
}
const pl = /\b([a-z-]*)\(.*?\)/gu, Ge = {
  ...it,
  getAnimatableNone: (t) => {
    const e = t.match(pl);
    return e ? e.map(dl).join(" ") : t;
  }
}, ii = {
  ...wt,
  transform: Math.round
}, ml = {
  rotate: tt,
  rotateX: tt,
  rotateY: tt,
  rotateZ: tt,
  scale: zt,
  scaleX: zt,
  scaleY: zt,
  scaleZ: zt,
  skew: tt,
  skewX: tt,
  skewY: tt,
  distance: S,
  translateX: S,
  translateY: S,
  translateZ: S,
  x: S,
  y: S,
  z: S,
  perspective: S,
  transformPerspective: S,
  opacity: Bt,
  originX: Kn,
  originY: Kn,
  originZ: S
}, Cn = {
  // Border props
  borderWidth: S,
  borderTopWidth: S,
  borderRightWidth: S,
  borderBottomWidth: S,
  borderLeftWidth: S,
  borderRadius: S,
  borderTopLeftRadius: S,
  borderTopRightRadius: S,
  borderBottomRightRadius: S,
  borderBottomLeftRadius: S,
  // Positioning props
  width: S,
  maxWidth: S,
  height: S,
  maxHeight: S,
  top: S,
  right: S,
  bottom: S,
  left: S,
  inset: S,
  insetBlock: S,
  insetBlockStart: S,
  insetBlockEnd: S,
  insetInline: S,
  insetInlineStart: S,
  insetInlineEnd: S,
  // Spacing props
  padding: S,
  paddingTop: S,
  paddingRight: S,
  paddingBottom: S,
  paddingLeft: S,
  paddingBlock: S,
  paddingBlockStart: S,
  paddingBlockEnd: S,
  paddingInline: S,
  paddingInlineStart: S,
  paddingInlineEnd: S,
  margin: S,
  marginTop: S,
  marginRight: S,
  marginBottom: S,
  marginLeft: S,
  marginBlock: S,
  marginBlockStart: S,
  marginBlockEnd: S,
  marginInline: S,
  marginInlineStart: S,
  marginInlineEnd: S,
  // Typography
  fontSize: S,
  // Misc
  backgroundPositionX: S,
  backgroundPositionY: S,
  ...ml,
  zIndex: ii,
  // SVG
  fillOpacity: Bt,
  strokeOpacity: Bt,
  numOctaves: ii
}, gl = {
  ...Cn,
  // Color props
  color: L,
  backgroundColor: L,
  outlineColor: L,
  fill: L,
  stroke: L,
  // Border props
  borderColor: L,
  borderTopColor: L,
  borderRightColor: L,
  borderBottomColor: L,
  borderLeftColor: L,
  filter: Ge,
  WebkitFilter: Ge
}, er = (t) => gl[t];
function nr(t, e) {
  let n = er(t);
  return n !== Ge && (n = it), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0;
}
const yl = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function vl(t, e, n) {
  let i = 0, s;
  for (; i < t.length && !s; ) {
    const o = t[i];
    typeof o == "string" && !yl.has(o) && It(o).values.length && (s = t[i]), i++;
  }
  if (s && n)
    for (const o of e)
      t[o] = nr(n, s);
}
class xl extends bn {
  constructor(e, n, i, s, o) {
    super(e, n, i, s, o, !0);
  }
  readKeyframes() {
    const { unresolvedKeyframes: e, element: n, name: i } = this;
    if (!n || !n.current)
      return;
    super.readKeyframes();
    for (let c = 0; c < e.length; c++) {
      let h = e[c];
      if (typeof h == "string" && (h = h.trim(), pn(h))) {
        const f = Xs(h, n.current);
        f !== void 0 && (e[c] = f), c === e.length - 1 && (this.finalKeyframe = h);
      }
    }
    if (this.resolveNoneKeyframes(), !Ys.has(i) || e.length !== 2)
      return;
    const [s, o] = e, r = ni(s), a = ni(o), l = Un(s), u = Un(o);
    if (l !== u && et[i]) {
      this.needsMeasurement = !0;
      return;
    }
    if (r !== a)
      if (Zn(r) && Zn(a))
        for (let c = 0; c < e.length; c++) {
          const h = e[c];
          typeof h == "string" && (e[c] = parseFloat(h));
        }
      else et[i] && (this.needsMeasurement = !0);
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes: e, name: n } = this, i = [];
    for (let s = 0; s < e.length; s++)
      (e[s] === null || hl(e[s])) && i.push(s);
    i.length && vl(e, i, n);
  }
  measureInitialState() {
    const { element: e, unresolvedKeyframes: n, name: i } = this;
    if (!e || !e.current)
      return;
    i === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = et[i](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin;
    const s = n[n.length - 1];
    s !== void 0 && e.getValue(i, s).jump(s, !1);
  }
  measureEndState() {
    var a;
    const { element: e, name: n, unresolvedKeyframes: i } = this;
    if (!e || !e.current)
      return;
    const s = e.getValue(n);
    s && s.jump(this.measuredOrigin, !1);
    const o = i.length - 1, r = i[o];
    i[o] = et[n](e.measureViewportBox(), window.getComputedStyle(e.current)), r !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = r), (a = this.removedTransforms) != null && a.length && this.removedTransforms.forEach(([l, u]) => {
      e.getValue(l).set(u);
    }), this.resolveNoneKeyframes();
  }
}
function Tl(t, e, n) {
  if (t == null)
    return [];
  if (t instanceof EventTarget)
    return [t];
  if (typeof t == "string") {
    let i = document;
    const s = (n == null ? void 0 : n[t]) ?? i.querySelectorAll(t);
    return s ? Array.from(s) : [];
  }
  return Array.from(t).filter((i) => i != null);
}
const ir = (t, e) => e && typeof t == "number" ? e.transform(t) : t;
function _e(t) {
  return ms(t) && "offsetHeight" in t;
}
const { schedule: Dn } = /* @__PURE__ */ Ds(queueMicrotask, !1), H = {
  x: !1,
  y: !1
};
function sr() {
  return H.x || H.y;
}
function wl(t) {
  return t === "x" || t === "y" ? H[t] ? null : (H[t] = !0, () => {
    H[t] = !1;
  }) : H.x || H.y ? null : (H.x = H.y = !0, () => {
    H.x = H.y = !1;
  });
}
function rr(t, e) {
  const n = Tl(t), i = new AbortController(), s = {
    passive: !0,
    ...e,
    signal: i.signal
  };
  return [n, s, () => i.abort()];
}
function si(t) {
  return !(t.pointerType === "touch" || sr());
}
function bl(t, e, n = {}) {
  const [i, s, o] = rr(t, n), r = (a) => {
    if (!si(a))
      return;
    const { target: l } = a, u = e(l, a);
    if (typeof u != "function" || !l)
      return;
    const c = (h) => {
      si(h) && (u(h), l.removeEventListener("pointerleave", c));
    };
    l.addEventListener("pointerleave", c, s);
  };
  return i.forEach((a) => {
    a.addEventListener("pointerenter", r, s);
  }), o;
}
const or = (t, e) => e ? t === e ? !0 : or(t, e.parentElement) : !1, Mn = (t) => t.pointerType === "mouse" ? typeof t.button != "number" || t.button <= 0 : t.isPrimary !== !1, Sl = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function ar(t) {
  return Sl.has(t.tagName) || t.isContentEditable === !0;
}
const Yt = /* @__PURE__ */ new WeakSet();
function ri(t) {
  return (e) => {
    e.key === "Enter" && t(e);
  };
}
function xe(t, e) {
  t.dispatchEvent(new PointerEvent("pointer" + e, { isPrimary: !0, bubbles: !0 }));
}
const Al = (t, e) => {
  const n = t.currentTarget;
  if (!n)
    return;
  const i = ri(() => {
    if (Yt.has(n))
      return;
    xe(n, "down");
    const s = ri(() => {
      xe(n, "up");
    }), o = () => xe(n, "cancel");
    n.addEventListener("keyup", s, e), n.addEventListener("blur", o, e);
  });
  n.addEventListener("keydown", i, e), n.addEventListener("blur", () => n.removeEventListener("keydown", i), e);
};
function oi(t) {
  return Mn(t) && !sr();
}
function Pl(t, e, n = {}) {
  const [i, s, o] = rr(t, n), r = (a) => {
    const l = a.currentTarget;
    if (!oi(a))
      return;
    Yt.add(l);
    const u = e(l, a), c = (d, p) => {
      window.removeEventListener("pointerup", h), window.removeEventListener("pointercancel", f), Yt.has(l) && Yt.delete(l), oi(d) && typeof u == "function" && u(d, { success: p });
    }, h = (d) => {
      c(d, l === window || l === document || n.useGlobalTarget || or(l, d.target));
    }, f = (d) => {
      c(d, !1);
    };
    window.addEventListener("pointerup", h, s), window.addEventListener("pointercancel", f, s);
  };
  return i.forEach((a) => {
    (n.useGlobalTarget ? window : a).addEventListener("pointerdown", r, s), _e(a) && (a.addEventListener("focus", (u) => Al(u, s)), !ar(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0));
  }), o;
}
function lr(t) {
  return ms(t) && "ownerSVGElement" in t;
}
function Vl(t) {
  return lr(t) && t.tagName === "svg";
}
const Cl = [...tr, L, it], Dl = (t) => Cl.find(Qs(t)), ai = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), pt = () => ({
  x: ai(),
  y: ai()
}), li = () => ({ min: 0, max: 0 }), k = () => ({
  x: li(),
  y: li()
}), He = { current: null }, cr = { current: !1 }, Ml = typeof window < "u";
function Rl() {
  if (cr.current = !0, !!Ml)
    if (window.matchMedia) {
      const t = window.matchMedia("(prefers-reduced-motion)"), e = () => He.current = t.matches;
      t.addEventListener("change", e), e();
    } else
      He.current = !1;
}
const El = /* @__PURE__ */ new WeakMap();
function ce(t) {
  return t !== null && typeof t == "object" && typeof t.start == "function";
}
function Ft(t) {
  return typeof t == "string" || Array.isArray(t);
}
const Rn = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], En = ["initial", ...Rn];
function ue(t) {
  return ce(t.animate) || En.some((e) => Ft(t[e]));
}
function ur(t) {
  return !!(ue(t) || t.variants);
}
function Ll(t, e, n) {
  for (const i in e) {
    const s = e[i], o = n[i];
    if (N(s))
      t.addValue(i, s);
    else if (N(o))
      t.addValue(i, vt(s, { owner: t }));
    else if (o !== s)
      if (t.hasValue(i)) {
        const r = t.getValue(i);
        r.liveStyle === !0 ? r.jump(s) : r.hasAnimated || r.set(s);
      } else {
        const r = t.getStaticValue(i);
        t.addValue(i, vt(r !== void 0 ? r : s, { owner: t }));
      }
  }
  for (const i in n)
    e[i] === void 0 && t.removeValue(i);
  return e;
}
const ci = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
let ne = {};
function hr(t) {
  ne = t;
}
function kl() {
  return ne;
}
class Bl {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(e, n, i) {
    return {};
  }
  constructor({ parent: e, props: n, presenceContext: i, reducedMotionConfig: s, skipAnimations: o, blockInitialAnimation: r, visualState: a }, l = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.shouldSkipAnimations = !1, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = bn, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.renderScheduledAt = 0, this.scheduleRender = () => {
      const d = O.now();
      this.renderScheduledAt < d && (this.renderScheduledAt = d, M.render(this.render, !1, !0));
    };
    const { latestValues: u, renderState: c } = a;
    this.latestValues = u, this.baseTarget = { ...u }, this.initialValues = n.initial ? { ...u } : {}, this.renderState = c, this.parent = e, this.props = n, this.presenceContext = i, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = s, this.skipAnimationsConfig = o, this.options = l, this.blockInitialAnimation = !!r, this.isControllingVariants = ue(n), this.isVariantNode = ur(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);
    const { willChange: h, ...f } = this.scrapeMotionValuesFromProps(n, {}, this);
    for (const d in f) {
      const p = f[d];
      u[d] !== void 0 && N(p) && p.set(u[d]);
    }
  }
  mount(e) {
    var n;
    this.current = e, El.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((i, s) => this.bindToMotionValue(s, i)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (cr.current || Rl(), this.shouldReduceMotion = He.current), process.env.NODE_ENV !== "production" && hn(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected.", "reduced-motion-disabled"), this.shouldSkipAnimations = this.skipAnimationsConfig ?? !1, (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    var e;
    this.projection && this.projection.unmount(), nt(this.notifyUpdate), nt(this.render), this.valueSubscriptions.forEach((n) => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (e = this.parent) == null || e.removeChild(this);
    for (const n in this.events)
      this.events[n].clear();
    for (const n in this.features) {
      const i = this.features[n];
      i && (i.unmount(), i.isMounted = !1);
    }
    this.current = null;
  }
  addChild(e) {
    this.children.add(e), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(e);
  }
  removeChild(e) {
    this.children.delete(e), this.enteringChildren && this.enteringChildren.delete(e);
  }
  bindToMotionValue(e, n) {
    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
    const i = St.has(e);
    i && this.onBindTransform && this.onBindTransform();
    const s = n.on("change", (r) => {
      this.latestValues[e] = r, this.props.onUpdate && M.preRender(this.notifyUpdate), i && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();
    });
    let o;
    typeof window < "u" && window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => {
      s(), o && o(), n.owner && n.stop();
    });
  }
  sortNodePosition(e) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);
  }
  updateFeatures() {
    let e = "animation";
    for (e in ne) {
      const n = ne[e];
      if (!n)
        continue;
      const { isEnabled: i, Feature: s } = n;
      if (!this.features[e] && s && i(this.props) && (this.features[e] = new s(this)), this.features[e]) {
        const o = this.features[e];
        o.isMounted ? o.update() : (o.mount(), o.isMounted = !0);
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : k();
  }
  getStaticValue(e) {
    return this.latestValues[e];
  }
  setStaticValue(e, n) {
    this.latestValues[e] = n;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(e, n) {
    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;
    for (let i = 0; i < ci.length; i++) {
      const s = ci[i];
      this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]);
      const o = "on" + s, r = e[o];
      r && (this.propEventSubscriptions[s] = this.on(s, r));
    }
    this.prevMotionValues = Ll(this, this.scrapeMotionValuesFromProps(e, this.prevProps || {}, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(e) {
    return this.props.variants ? this.props.variants[e] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(e) {
    const n = this.getClosestVariantNode();
    if (n)
      return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(e, n) {
    const i = this.values.get(e);
    n !== i && (i && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get());
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(e) {
    this.values.delete(e);
    const n = this.valueSubscriptions.get(e);
    n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(e) {
    return this.values.has(e);
  }
  getValue(e, n) {
    if (this.props.values && this.props.values[e])
      return this.props.values[e];
    let i = this.values.get(e);
    return i === void 0 && n !== void 0 && (i = vt(n === null ? void 0 : n, { owner: this }), this.addValue(e, i)), i;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(e, n) {
    let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.getBaseTargetFromProps(this.props, e) ?? this.readValueFromInstance(this.current, e, this.options);
    return i != null && (typeof i == "string" && (ps(i) || gs(i)) ? i = parseFloat(i) : !Dl(i) && it.test(n) && (i = nr(e, n)), this.setBaseTarget(e, N(i) ? i.get() : i)), N(i) ? i.get() : i;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(e, n) {
    this.baseTarget[e] = n;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(e) {
    var o;
    const { initial: n } = this.props;
    let i;
    if (typeof n == "string" || typeof n == "object") {
      const r = Pn(this.props, n, (o = this.presenceContext) == null ? void 0 : o.custom);
      r && (i = r[e]);
    }
    if (n && i !== void 0)
      return i;
    const s = this.getBaseTargetFromProps(this.props, e);
    return s !== void 0 && !N(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e];
  }
  on(e, n) {
    return this.events[e] || (this.events[e] = new un()), this.events[e].add(n);
  }
  notify(e, ...n) {
    this.events[e] && this.events[e].notify(...n);
  }
  scheduleRenderMicrotask() {
    Dn.render(this.render);
  }
}
class fr extends Bl {
  constructor() {
    super(...arguments), this.KeyframeResolver = xl;
  }
  sortInstanceNodePosition(e, n) {
    return e.compareDocumentPosition(n) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(e, n) {
    const i = e.style;
    return i ? i[n] : void 0;
  }
  removeValueFromRenderState(e, { vars: n, style: i }) {
    delete n[e], delete i[e];
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children: e } = this.props;
    N(e) && (this.childSubscription = e.on("change", (n) => {
      this.current && (this.current.textContent = `${n}`);
    }));
  }
}
class st {
  constructor(e) {
    this.isMounted = !1, this.node = e;
  }
  update() {
  }
}
function dr({ top: t, left: e, right: n, bottom: i }) {
  return {
    x: { min: e, max: n },
    y: { min: t, max: i }
  };
}
function Il({ x: t, y: e }) {
  return { top: e.min, right: t.max, bottom: e.max, left: t.min };
}
function Fl(t, e) {
  if (!e)
    return t;
  const n = e({ x: t.left, y: t.top }), i = e({ x: t.right, y: t.bottom });
  return {
    top: n.y,
    left: n.x,
    bottom: i.y,
    right: i.x
  };
}
function Te(t) {
  return t === void 0 || t === 1;
}
function Xe({ scale: t, scaleX: e, scaleY: n }) {
  return !Te(t) || !Te(e) || !Te(n);
}
function at(t) {
  return Xe(t) || pr(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;
}
function pr(t) {
  return ui(t.x) || ui(t.y);
}
function ui(t) {
  return t && t !== "0%";
}
function ie(t, e, n) {
  const i = t - n, s = e * i;
  return n + s;
}
function hi(t, e, n, i, s) {
  return s !== void 0 && (t = ie(t, s, i)), ie(t, n, i) + e;
}
function Ye(t, e = 0, n = 1, i, s) {
  t.min = hi(t.min, e, n, i, s), t.max = hi(t.max, e, n, i, s);
}
function mr(t, { x: e, y: n }) {
  Ye(t.x, e.translate, e.scale, e.originPoint), Ye(t.y, n.translate, n.scale, n.originPoint);
}
const fi = 0.999999999999, di = 1.0000000000001;
function $l(t, e, n, i = !1) {
  const s = n.length;
  if (!s)
    return;
  e.x = e.y = 1;
  let o, r;
  for (let a = 0; a < s; a++) {
    o = n[a], r = o.projectionDelta;
    const { visualElement: l } = o.options;
    l && l.props.style && l.props.style.display === "contents" || (i && o.options.layoutScroll && o.scroll && o !== o.root && gt(t, {
      x: -o.scroll.offset.x,
      y: -o.scroll.offset.y
    }), r && (e.x *= r.x.scale, e.y *= r.y.scale, mr(t, r)), i && at(o.latestValues) && gt(t, o.latestValues));
  }
  e.x < di && e.x > fi && (e.x = 1), e.y < di && e.y > fi && (e.y = 1);
}
function mt(t, e) {
  t.min = t.min + e, t.max = t.max + e;
}
function pi(t, e, n, i, s = 0.5) {
  const o = E(t.min, t.max, s);
  Ye(t, e, n, o, i);
}
function gt(t, e) {
  pi(t.x, e.x, e.scaleX, e.scale, e.originX), pi(t.y, e.y, e.scaleY, e.scale, e.originY);
}
function gr(t, e) {
  return dr(Fl(t.getBoundingClientRect(), e));
}
function Nl(t, e, n) {
  const i = gr(t, n), { scroll: s } = e;
  return s && (mt(i.x, s.offset.x), mt(i.y, s.offset.y)), i;
}
const Ol = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, jl = bt.length;
function Wl(t, e, n) {
  let i = "", s = !0;
  for (let o = 0; o < jl; o++) {
    const r = bt[o], a = t[r];
    if (a === void 0)
      continue;
    let l = !0;
    if (typeof a == "number")
      l = a === (r.startsWith("scale") ? 1 : 0);
    else {
      const u = parseFloat(a);
      l = r.startsWith("scale") ? u === 1 : u === 0;
    }
    if (!l || n) {
      const u = ir(a, Cn[r]);
      if (!l) {
        s = !1;
        const c = Ol[r] || r;
        i += `${c}(${u}) `;
      }
      n && (e[r] = u);
    }
  }
  return i = i.trim(), n ? i = n(e, s ? "" : i) : s && (i = "none"), i;
}
function Ln(t, e, n) {
  const { style: i, vars: s, transformOrigin: o } = t;
  let r = !1, a = !1;
  for (const l in e) {
    const u = e[l];
    if (St.has(l)) {
      r = !0;
      continue;
    } else if (Rs(l)) {
      s[l] = u;
      continue;
    } else {
      const c = ir(u, Cn[l]);
      l.startsWith("origin") ? (a = !0, o[l] = c) : i[l] = c;
    }
  }
  if (e.transform || (r || n ? i.transform = Wl(e, t.transform, n) : i.transform && (i.transform = "none")), a) {
    const { originX: l = "50%", originY: u = "50%", originZ: c = 0 } = o;
    i.transformOrigin = `${l} ${u} ${c}`;
  }
}
function yr(t, { style: e, vars: n }, i, s) {
  const o = t.style;
  let r;
  for (r in e)
    o[r] = e[r];
  s == null || s.applyProjectionStyles(o, i);
  for (r in n)
    o.setProperty(r, n[r]);
}
function mi(t, e) {
  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;
}
const Pt = {
  correct: (t, e) => {
    if (!e.target)
      return t;
    if (typeof t == "string")
      if (S.test(t))
        t = parseFloat(t);
      else
        return t;
    const n = mi(t, e.target.x), i = mi(t, e.target.y);
    return `${n}% ${i}%`;
  }
}, Ul = {
  correct: (t, { treeScale: e, projectionDelta: n }) => {
    const i = t, s = it.parse(t);
    if (s.length > 5)
      return i;
    const o = it.createTransformer(t), r = typeof s[0] != "number" ? 1 : 0, a = n.x.scale * e.x, l = n.y.scale * e.y;
    s[0 + r] /= a, s[1 + r] /= l;
    const u = E(a, l, 0.5);
    return typeof s[2 + r] == "number" && (s[2 + r] /= u), typeof s[3 + r] == "number" && (s[3 + r] /= u), o(s);
  }
}, qe = {
  borderRadius: {
    ...Pt,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: Pt,
  borderTopRightRadius: Pt,
  borderBottomLeftRadius: Pt,
  borderBottomRightRadius: Pt,
  boxShadow: Ul
};
function vr(t, { layout: e, layoutId: n }) {
  return St.has(t) || t.startsWith("origin") || (e || n !== void 0) && (!!qe[t] || t === "opacity");
}
function kn(t, e, n) {
  var r;
  const i = t.style, s = e == null ? void 0 : e.style, o = {};
  if (!i)
    return o;
  for (const a in i)
    (N(i[a]) || s && N(s[a]) || vr(a, t) || ((r = n == null ? void 0 : n.getValue(a)) == null ? void 0 : r.liveStyle) !== void 0) && (o[a] = i[a]);
  return o;
}
function Kl(t) {
  return window.getComputedStyle(t);
}
class zl extends fr {
  constructor() {
    super(...arguments), this.type = "html", this.renderInstance = yr;
  }
  readValueFromInstance(e, n) {
    var i;
    if (St.has(n))
      return (i = this.projection) != null && i.isProjecting ? Fe(n) : xa(e, n);
    {
      const s = Kl(e), o = (Rs(n) ? s.getPropertyValue(n) : s[n]) || 0;
      return typeof o == "string" ? o.trim() : o;
    }
  }
  measureInstanceViewportBox(e, { transformPagePoint: n }) {
    return gr(e, n);
  }
  build(e, n, i) {
    Ln(e, n, i.transformTemplate);
  }
  scrapeMotionValuesFromProps(e, n, i) {
    return kn(e, n, i);
  }
}
const Gl = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, _l = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function Hl(t, e, n = 1, i = 0, s = !0) {
  t.pathLength = 1;
  const o = s ? Gl : _l;
  t[o.offset] = `${-i}`, t[o.array] = `${e} ${n}`;
}
const Xl = [
  "offsetDistance",
  "offsetPath",
  "offsetRotate",
  "offsetAnchor"
];
function xr(t, {
  attrX: e,
  attrY: n,
  attrScale: i,
  pathLength: s,
  pathSpacing: o = 1,
  pathOffset: r = 0,
  // This is object creation, which we try to avoid per-frame.
  ...a
}, l, u, c) {
  if (Ln(t, a, u), l) {
    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);
    return;
  }
  t.attrs = t.style, t.style = {};
  const { attrs: h, style: f } = t;
  h.transform && (f.transform = h.transform, delete h.transform), (f.transform || h.transformOrigin) && (f.transformOrigin = h.transformOrigin ?? "50% 50%", delete h.transformOrigin), f.transform && (f.transformBox = (c == null ? void 0 : c.transformBox) ?? "fill-box", delete h.transformBox);
  for (const d of Xl)
    h[d] !== void 0 && (f[d] = h[d], delete h[d]);
  e !== void 0 && (h.x = e), n !== void 0 && (h.y = n), i !== void 0 && (h.scale = i), s !== void 0 && Hl(h, s, o, r, !1);
}
const Tr = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]), wr = (t) => typeof t == "string" && t.toLowerCase() === "svg";
function Yl(t, e, n, i) {
  yr(t, e, void 0, i);
  for (const s in e.attrs)
    t.setAttribute(Tr.has(s) ? s : Vn(s), e.attrs[s]);
}
function br(t, e, n) {
  const i = kn(t, e, n);
  for (const s in t)
    if (N(t[s]) || N(e[s])) {
      const o = bt.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s;
      i[o] = t[s];
    }
  return i;
}
class ql extends fr {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = k;
  }
  getBaseTargetFromProps(e, n) {
    return e[n];
  }
  readValueFromInstance(e, n) {
    if (St.has(n)) {
      const i = er(n);
      return i && i.default || 0;
    }
    return n = Tr.has(n) ? n : Vn(n), e.getAttribute(n);
  }
  scrapeMotionValuesFromProps(e, n, i) {
    return br(e, n, i);
  }
  build(e, n, i) {
    xr(e, n, this.isSVGTag, i.transformTemplate, i.style);
  }
  renderInstance(e, n, i, s) {
    Yl(e, n, i, s);
  }
  mount(e) {
    this.isSVGTag = wr(e.tagName), super.mount(e);
  }
}
const Zl = En.length;
function Sr(t) {
  if (!t)
    return;
  if (!t.isControllingVariants) {
    const n = t.parent ? Sr(t.parent) || {} : {};
    return t.props.initial !== void 0 && (n.initial = t.props.initial), n;
  }
  const e = {};
  for (let n = 0; n < Zl; n++) {
    const i = En[n], s = t.props[i];
    (Ft(s) || s === !1) && (e[i] = s);
  }
  return e;
}
function Ar(t, e) {
  if (!Array.isArray(e))
    return !1;
  const n = e.length;
  if (n !== t.length)
    return !1;
  for (let i = 0; i < n; i++)
    if (e[i] !== t[i])
      return !1;
  return !0;
}
const Jl = [...Rn].reverse(), Ql = Rn.length;
function tc(t) {
  return (e) => Promise.all(e.map(({ animation: n, options: i }) => cl(t, n, i)));
}
function ec(t) {
  let e = tc(t), n = gi(), i = !0;
  const s = (l) => (u, c) => {
    var f;
    const h = yt(t, c, l === "exit" ? (f = t.presenceContext) == null ? void 0 : f.custom : void 0);
    if (h) {
      const { transition: d, transitionEnd: p, ...g } = h;
      u = { ...u, ...g, ...p };
    }
    return u;
  };
  function o(l) {
    e = l(t);
  }
  function r(l) {
    const { props: u } = t, c = Sr(t.parent) || {}, h = [], f = /* @__PURE__ */ new Set();
    let d = {}, p = 1 / 0;
    for (let x = 0; x < Ql; x++) {
      const v = Jl[x], T = n[v], y = u[v] !== void 0 ? u[v] : c[v], w = Ft(y), b = v === l ? T.isActive : null;
      b === !1 && (p = x);
      let P = y === c[v] && y !== u[v] && w;
      if (P && i && t.manuallyAnimateOnMount && (P = !1), T.protectedKeys = { ...d }, // If it isn't active and hasn't *just* been set as inactive
      !T.isActive && b === null || // If we didn't and don't have any defined prop for this animation type
      !y && !T.prevProp || // Or if the prop doesn't define an animation
      ce(y) || typeof y == "boolean")
        continue;
      const C = nc(T.prevProp, y);
      let A = C || // If we're making this variant active, we want to always make it active
      v === l && T.isActive && !P && w || // If we removed a higher-priority variant (i is in reverse order)
      x > p && w, V = !1;
      const m = Array.isArray(y) ? y : [y];
      let B = m.reduce(s(v), {});
      b === !1 && (B = {});
      const { prevResolvedValues: At = {} } = T, fe = {
        ...At,
        ...B
      }, $n = (I) => {
        A = !0, f.has(I) && (V = !0, f.delete(I)), T.needsAnimating[I] = !0;
        const U = t.getValue(I);
        U && (U.liveStyle = !1);
      };
      for (const I in fe) {
        const U = B[I], rt = At[I];
        if (d.hasOwnProperty(I))
          continue;
        let ht = !1;
        Ue(U) && Ue(rt) ? ht = !Ar(U, rt) : ht = U !== rt, ht ? U != null ? $n(I) : f.add(I) : U !== void 0 && f.has(I) ? $n(I) : T.protectedKeys[I] = !0;
      }
      T.prevProp = y, T.prevResolvedValues = B, T.isActive && (d = { ...d, ...B }), i && t.blockInitialAnimation && (A = !1);
      const Nn = P && C;
      A && (!Nn || V) && h.push(...m.map((I) => {
        const U = { type: v };
        if (typeof I == "string" && i && !Nn && t.manuallyAnimateOnMount && t.parent) {
          const { parent: rt } = t, ht = yt(rt, I);
          if (rt.enteringChildren && ht) {
            const { delayChildren: uo } = ht.transition || {};
            U.delay = Hs(rt.enteringChildren, t, uo);
          }
        }
        return {
          animation: I,
          options: U
        };
      }));
    }
    if (f.size) {
      const x = {};
      if (typeof u.initial != "boolean") {
        const v = yt(t, Array.isArray(u.initial) ? u.initial[0] : u.initial);
        v && v.transition && (x.transition = v.transition);
      }
      f.forEach((v) => {
        const T = t.getBaseTarget(v), y = t.getValue(v);
        y && (y.liveStyle = !0), x[v] = T ?? null;
      }), h.push({ animation: x });
    }
    let g = !!h.length;
    return i && (u.initial === !1 || u.initial === u.animate) && !t.manuallyAnimateOnMount && (g = !1), i = !1, g ? e(h) : Promise.resolve();
  }
  function a(l, u) {
    var h;
    if (n[l].isActive === u)
      return Promise.resolve();
    (h = t.variantChildren) == null || h.forEach((f) => {
      var d;
      return (d = f.animationState) == null ? void 0 : d.setActive(l, u);
    }), n[l].isActive = u;
    const c = r(l);
    for (const f in n)
      n[f].protectedKeys = {};
    return c;
  }
  return {
    animateChanges: r,
    setActive: a,
    setAnimateFunction: o,
    getState: () => n,
    reset: () => {
      n = gi();
    }
  };
}
function nc(t, e) {
  return typeof e == "string" ? e !== t : Array.isArray(e) ? !Ar(e, t) : !1;
}
function ot(t = !1) {
  return {
    isActive: t,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function gi() {
  return {
    animate: ot(!0),
    whileInView: ot(),
    whileHover: ot(),
    whileTap: ot(),
    whileDrag: ot(),
    whileFocus: ot(),
    exit: ot()
  };
}
function yi(t, e) {
  t.min = e.min, t.max = e.max;
}
function _(t, e) {
  yi(t.x, e.x), yi(t.y, e.y);
}
function vi(t, e) {
  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;
}
const Pr = 1e-4, ic = 1 - Pr, sc = 1 + Pr, Vr = 0.01, rc = 0 - Vr, oc = 0 + Vr;
function j(t) {
  return t.max - t.min;
}
function ac(t, e, n) {
  return Math.abs(t - e) <= n;
}
function xi(t, e, n, i = 0.5) {
  t.origin = i, t.originPoint = E(e.min, e.max, t.origin), t.scale = j(n) / j(e), t.translate = E(n.min, n.max, t.origin) - t.originPoint, (t.scale >= ic && t.scale <= sc || isNaN(t.scale)) && (t.scale = 1), (t.translate >= rc && t.translate <= oc || isNaN(t.translate)) && (t.translate = 0);
}
function Et(t, e, n, i) {
  xi(t.x, e.x, n.x, i ? i.originX : void 0), xi(t.y, e.y, n.y, i ? i.originY : void 0);
}
function Ti(t, e, n) {
  t.min = n.min + e.min, t.max = t.min + j(e);
}
function lc(t, e, n) {
  Ti(t.x, e.x, n.x), Ti(t.y, e.y, n.y);
}
function wi(t, e, n) {
  t.min = e.min - n.min, t.max = t.min + j(e);
}
function se(t, e, n) {
  wi(t.x, e.x, n.x), wi(t.y, e.y, n.y);
}
function bi(t, e, n, i, s) {
  return t -= e, t = ie(t, 1 / n, i), s !== void 0 && (t = ie(t, 1 / s, i)), t;
}
function cc(t, e = 0, n = 1, i = 0.5, s, o = t, r = t) {
  if (Y.test(e) && (e = parseFloat(e), e = E(r.min, r.max, e / 100) - r.min), typeof e != "number")
    return;
  let a = E(o.min, o.max, i);
  t === o && (a -= e), t.min = bi(t.min, e, n, a, s), t.max = bi(t.max, e, n, a, s);
}
function Si(t, e, [n, i, s], o, r) {
  cc(t, e[n], e[i], e[s], e.scale, o, r);
}
const uc = ["x", "scaleX", "originX"], hc = ["y", "scaleY", "originY"];
function Ai(t, e, n, i) {
  Si(t.x, e, uc, n ? n.x : void 0, i ? i.x : void 0), Si(t.y, e, hc, n ? n.y : void 0, i ? i.y : void 0);
}
function Pi(t) {
  return t.translate === 0 && t.scale === 1;
}
function Cr(t) {
  return Pi(t.x) && Pi(t.y);
}
function Vi(t, e) {
  return t.min === e.min && t.max === e.max;
}
function fc(t, e) {
  return Vi(t.x, e.x) && Vi(t.y, e.y);
}
function Ci(t, e) {
  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);
}
function Dr(t, e) {
  return Ci(t.x, e.x) && Ci(t.y, e.y);
}
function Di(t) {
  return j(t.x) / j(t.y);
}
function Mi(t, e) {
  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;
}
function K(t) {
  return [t("x"), t("y")];
}
function dc(t, e, n) {
  let i = "";
  const s = t.x.translate / e.x, o = t.y.translate / e.y, r = (n == null ? void 0 : n.z) || 0;
  if ((s || o || r) && (i = `translate3d(${s}px, ${o}px, ${r}px) `), (e.x !== 1 || e.y !== 1) && (i += `scale(${1 / e.x}, ${1 / e.y}) `), n) {
    const { transformPerspective: u, rotate: c, rotateX: h, rotateY: f, skewX: d, skewY: p } = n;
    u && (i = `perspective(${u}px) ${i}`), c && (i += `rotate(${c}deg) `), h && (i += `rotateX(${h}deg) `), f && (i += `rotateY(${f}deg) `), d && (i += `skewX(${d}deg) `), p && (i += `skewY(${p}deg) `);
  }
  const a = t.x.scale * e.x, l = t.y.scale * e.y;
  return (a !== 1 || l !== 1) && (i += `scale(${a}, ${l})`), i || "none";
}
const Mr = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], pc = Mr.length, Ri = (t) => typeof t == "string" ? parseFloat(t) : t, Ei = (t) => typeof t == "number" || S.test(t);
function mc(t, e, n, i, s, o) {
  s ? (t.opacity = E(0, n.opacity ?? 1, gc(i)), t.opacityExit = E(e.opacity ?? 1, 0, yc(i))) : o && (t.opacity = E(e.opacity ?? 1, n.opacity ?? 1, i));
  for (let r = 0; r < pc; r++) {
    const a = `border${Mr[r]}Radius`;
    let l = Li(e, a), u = Li(n, a);
    if (l === void 0 && u === void 0)
      continue;
    l || (l = 0), u || (u = 0), l === 0 || u === 0 || Ei(l) === Ei(u) ? (t[a] = Math.max(E(Ri(l), Ri(u), i), 0), (Y.test(u) || Y.test(l)) && (t[a] += "%")) : t[a] = u;
  }
  (e.rotate || n.rotate) && (t.rotate = E(e.rotate || 0, n.rotate || 0, i));
}
function Li(t, e) {
  return t[e] !== void 0 ? t[e] : t.borderRadius;
}
const gc = /* @__PURE__ */ Rr(0, 0.5, As), yc = /* @__PURE__ */ Rr(0.5, 0.95, G);
function Rr(t, e, n) {
  return (i) => i < t ? 0 : i > e ? 1 : n(/* @__PURE__ */ kt(t, e, i));
}
function vc(t, e, n) {
  const i = N(t) ? t : vt(t);
  return i.start(An("", i, e, n)), i.animation;
}
function $t(t, e, n, i = { passive: !0 }) {
  return t.addEventListener(e, n, i), () => t.removeEventListener(e, n);
}
const xc = (t, e) => t.depth - e.depth;
class Tc {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(e) {
    an(this.children, e), this.isDirty = !0;
  }
  remove(e) {
    ln(this.children, e), this.isDirty = !0;
  }
  forEach(e) {
    this.isDirty && this.children.sort(xc), this.isDirty = !1, this.children.forEach(e);
  }
}
function wc(t, e) {
  const n = O.now(), i = ({ timestamp: s }) => {
    const o = s - n;
    o >= e && (nt(i), t(o - e));
  };
  return M.setup(i, !0), () => nt(i);
}
function qt(t) {
  return N(t) ? t.get() : t;
}
class bc {
  constructor() {
    this.members = [];
  }
  add(e) {
    an(this.members, e), e.scheduleRender();
  }
  remove(e) {
    if (ln(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
      const n = this.members[this.members.length - 1];
      n && this.promote(n);
    }
  }
  relegate(e) {
    const n = this.members.findIndex((s) => e === s);
    if (n === 0)
      return !1;
    let i;
    for (let s = n; s >= 0; s--) {
      const o = this.members[s];
      if (o.isPresent !== !1) {
        i = o;
        break;
      }
    }
    return i ? (this.promote(i), !0) : !1;
  }
  promote(e, n) {
    const i = this.lead;
    if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) {
      i.instance && i.scheduleRender(), e.scheduleRender();
      const s = i.options.layoutDependency, o = e.options.layoutDependency;
      s !== void 0 && o !== void 0 && s === o || (e.resumeFrom = i, n && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0));
      const { crossfade: a } = e.options;
      a === !1 && i.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((e) => {
      const { options: n, resumingFrom: i } = e;
      n.onExitComplete && n.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((e) => {
      e.instance && e.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
const Zt = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
}, we = ["", "X", "Y", "Z"], Sc = 1e3;
let Ac = 0;
function be(t, e, n, i) {
  const { latestValues: s } = e;
  s[t] && (n[t] = s[t], e.setStaticValue(t, 0), i && (i[t] = 0));
}
function Er(t) {
  if (t.hasCheckedOptimisedAppear = !0, t.root === t)
    return;
  const { visualElement: e } = t.options;
  if (!e)
    return;
  const n = Zs(e);
  if (window.MotionHasOptimisedAnimation(n, "transform")) {
    const { layout: s, layoutId: o } = t.options;
    window.MotionCancelOptimisedAnimation(n, "transform", M, !(s || o));
  }
  const { parent: i } = t;
  i && !i.hasCheckedOptimisedAppear && Er(i);
}
function Lr({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: i, resetTransform: s }) {
  return class {
    constructor(r = {}, a = e == null ? void 0 : e()) {
      this.id = Ac++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, this.nodes.forEach(Cc), this.nodes.forEach(Ec), this.nodes.forEach(Lc), this.nodes.forEach(Dc);
      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = r, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
      for (let l = 0; l < this.path.length; l++)
        this.path[l].shouldResetTransform = !0;
      this.root === this && (this.nodes = new Tc());
    }
    addEventListener(r, a) {
      return this.eventHandlers.has(r) || this.eventHandlers.set(r, new un()), this.eventHandlers.get(r).add(a);
    }
    notifyListeners(r, ...a) {
      const l = this.eventHandlers.get(r);
      l && l.notify(...a);
    }
    hasListeners(r) {
      return this.eventHandlers.has(r);
    }
    /**
     * Lifecycles
     */
    mount(r) {
      if (this.instance)
        return;
      this.isSVG = lr(r) && !Vl(r), this.instance = r;
      const { layoutId: a, layout: l, visualElement: u } = this.options;
      if (u && !u.current && u.mount(r), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0), t) {
        let c, h = 0;
        const f = () => this.root.updateBlockedByResize = !1;
        M.read(() => {
          h = window.innerWidth;
        }), t(r, () => {
          const d = window.innerWidth;
          d !== h && (h = d, this.root.updateBlockedByResize = !0, c && c(), c = wc(f, 250), Zt.hasAnimatedSinceResize && (Zt.hasAnimatedSinceResize = !1, this.nodes.forEach(Ii)));
        });
      }
      a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && u && (a || l) && this.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: h, hasRelativeLayoutChanged: f, layout: d }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const p = this.options.transition || u.getDefaultTransition() || $c, { onLayoutAnimationStart: g, onLayoutAnimationComplete: x } = u.getProps(), v = !this.targetLayout || !Dr(this.targetLayout, d), T = !h && f;
        if (this.options.layoutRoot || this.resumeFrom || T || h && (v || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
          const y = {
            ...Sn(p, "layout"),
            onPlay: g,
            onComplete: x
          };
          (u.shouldReduceMotion || this.options.layoutRoot) && (y.delay = 0, y.type = !1), this.startAnimation(y), this.setAnimationOrigin(c, T);
        } else
          h || Ii(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = d;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const r = this.getStack();
      r && r.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), nt(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(kc), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement: r } = this.options;
      return r && r.getProps().transformTemplate;
    }
    willUpdate(r = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && Er(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let c = 0; c < this.path.length; c++) {
        const h = this.path[c];
        h.shouldResetTransform = !0, h.updateScroll("snapshot"), h.options.layoutRoot && h.willUpdate(!1);
      }
      const { layoutId: a, layout: l } = this.options;
      if (a === void 0 && !l)
        return;
      const u = this.getTransformTemplate();
      this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), r && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(ki);
        return;
      }
      if (this.animationId <= this.animationCommitId) {
        this.nodes.forEach(Bi);
        return;
      }
      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(Rc), this.nodes.forEach(Pc), this.nodes.forEach(Vc)) : this.nodes.forEach(Bi), this.clearAllSnapshots();
      const a = O.now();
      F.delta = q(0, 1e3 / 60, a - F.timestamp), F.timestamp = a, F.isProcessing = !0, de.update.process(F), de.preRender.process(F), de.render.process(F), F.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, Dn.read(this.scheduleUpdate));
    }
    clearAllSnapshots() {
      this.nodes.forEach(Mc), this.sharedNodes.forEach(Bc);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, M.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      M.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !j(this.snapshot.measuredBox.x) && !j(this.snapshot.measuredBox.y) && (this.snapshot = void 0));
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let l = 0; l < this.path.length; l++)
          this.path[l].updateScroll();
      const r = this.layout;
      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = k(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement: a } = this.options;
      a && a.notify("LayoutMeasure", this.layout.layoutBox, r ? r.layoutBox : void 0);
    }
    updateScroll(r = "measure") {
      let a = !!(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === r && (a = !1), a && this.instance) {
        const l = i(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase: r,
          isRoot: l,
          offset: n(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : l
        };
      }
    }
    resetTransform() {
      if (!s)
        return;
      const r = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !Cr(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, "") : void 0, c = u !== this.prevTransformTemplateValue;
      r && this.instance && (a || at(this.latestValues) || c) && (s(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(r = !0) {
      const a = this.measurePageBox();
      let l = this.removeElementScroll(a);
      return r && (l = this.removeTransform(l)), Nc(l), {
        animationId: this.root.animationId,
        measuredBox: a,
        layoutBox: l,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var u;
      const { visualElement: r } = this.options;
      if (!r)
        return k();
      const a = r.measureViewportBox();
      if (!(((u = this.scroll) == null ? void 0 : u.wasRoot) || this.path.some(Oc))) {
        const { scroll: c } = this.root;
        c && (mt(a.x, c.offset.x), mt(a.y, c.offset.y));
      }
      return a;
    }
    removeElementScroll(r) {
      var l;
      const a = k();
      if (_(a, r), (l = this.scroll) != null && l.wasRoot)
        return a;
      for (let u = 0; u < this.path.length; u++) {
        const c = this.path[u], { scroll: h, options: f } = c;
        c !== this.root && h && f.layoutScroll && (h.wasRoot && _(a, r), mt(a.x, h.offset.x), mt(a.y, h.offset.y));
      }
      return a;
    }
    applyTransform(r, a = !1) {
      const l = k();
      _(l, r);
      for (let u = 0; u < this.path.length; u++) {
        const c = this.path[u];
        !a && c.options.layoutScroll && c.scroll && c !== c.root && gt(l, {
          x: -c.scroll.offset.x,
          y: -c.scroll.offset.y
        }), at(c.latestValues) && gt(l, c.latestValues);
      }
      return at(this.latestValues) && gt(l, this.latestValues), l;
    }
    removeTransform(r) {
      const a = k();
      _(a, r);
      for (let l = 0; l < this.path.length; l++) {
        const u = this.path[l];
        if (!u.instance || !at(u.latestValues))
          continue;
        Xe(u.latestValues) && u.updateSnapshot();
        const c = k(), h = u.measurePageBox();
        _(c, h), Ai(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c);
      }
      return at(this.latestValues) && Ai(a, this.latestValues), a;
    }
    setTargetDelta(r) {
      this.targetDelta = r, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(r) {
      this.options = {
        ...this.options,
        ...r,
        crossfade: r.crossfade !== void 0 ? r.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== F.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(r = !1) {
      var d;
      const a = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty);
      const l = !!this.resumingFrom || this !== a;
      if (!(r || l && this.isSharedProjectionDirty || this.isProjectionDirty || (d = this.parent) != null && d.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))
        return;
      const { layout: c, layoutId: h } = this.options;
      if (!this.layout || !(c || h))
        return;
      this.resolvedRelativeTargetAt = F.timestamp;
      const f = this.getClosestProjectingParent();
      f && this.linkedParentVersion !== f.layoutVersion && !f.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (f && f.layout ? this.createRelativeTarget(f, this.layout.layoutBox, f.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = k(), this.targetWithTransforms = k()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), lc(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : _(this.target, this.layout.layoutBox), mr(this.target, this.targetDelta)) : _(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, f && !!f.resumingFrom == !!this.resumingFrom && !f.options.layoutScroll && f.target && this.animationProgress !== 1 ? this.createRelativeTarget(f, this.target, f.target) : this.relativeParent = this.relativeTarget = void 0));
    }
    getClosestProjectingParent() {
      if (!(!this.parent || Xe(this.parent.latestValues) || pr(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    createRelativeTarget(r, a, l) {
      this.relativeParent = r, this.linkedParentVersion = r.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = k(), this.relativeTargetOrigin = k(), se(this.relativeTargetOrigin, a, l), _(this.relativeTarget, this.relativeTargetOrigin);
    }
    removeRelativeTarget() {
      this.relativeParent = this.relativeTarget = void 0;
    }
    calcProjection() {
      var p;
      const r = this.getLead(), a = !!this.resumingFrom || this !== r;
      let l = !0;
      if ((this.isProjectionDirty || (p = this.parent) != null && p.isProjectionDirty) && (l = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === F.timestamp && (l = !1), l)
        return;
      const { layout: u, layoutId: c } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || c))
        return;
      _(this.layoutCorrected, this.layout.layoutBox);
      const h = this.treeScale.x, f = this.treeScale.y;
      $l(this.layoutCorrected, this.treeScale, this.path, a), r.layout && !r.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (r.target = r.layout.layoutBox, r.targetWithTransforms = k());
      const { target: d } = r;
      if (!d) {
        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
        return;
      }
      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (vi(this.prevProjectionDelta.x, this.projectionDelta.x), vi(this.prevProjectionDelta.y, this.projectionDelta.y)), Et(this.projectionDelta, this.layoutCorrected, d, this.latestValues), (this.treeScale.x !== h || this.treeScale.y !== f || !Mi(this.projectionDelta.x, this.prevProjectionDelta.x) || !Mi(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", d));
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(r = !0) {
      var a;
      if ((a = this.options.visualElement) == null || a.scheduleRender(), r) {
        const l = this.getStack();
        l && l.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = pt(), this.projectionDelta = pt(), this.projectionDeltaWithTransform = pt();
    }
    setAnimationOrigin(r, a = !1) {
      const l = this.snapshot, u = l ? l.latestValues : {}, c = { ...this.latestValues }, h = pt();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
      const f = k(), d = l ? l.source : void 0, p = this.layout ? this.layout.source : void 0, g = d !== p, x = this.getStack(), v = !x || x.members.length <= 1, T = !!(g && !v && this.options.crossfade === !0 && !this.path.some(Fc));
      this.animationProgress = 0;
      let y;
      this.mixTargetDelta = (w) => {
        const b = w / 1e3;
        Fi(h.x, r.x, b), Fi(h.y, r.y, b), this.setTargetDelta(h), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (se(f, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Ic(this.relativeTarget, this.relativeTargetOrigin, f, b), y && fc(this.relativeTarget, y) && (this.isProjectionDirty = !1), y || (y = k()), _(y, this.relativeTarget)), g && (this.animationValues = c, mc(c, u, this.latestValues, b, T, v)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = b;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(r) {
      var a, l, u;
      this.notifyListeners("animationStart"), (a = this.currentAnimation) == null || a.stop(), (u = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || u.stop(), this.pendingAnimation && (nt(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = M.update(() => {
        Zt.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = vt(0)), this.currentAnimation = vc(this.motionValue, [0, 1e3], {
          ...r,
          velocity: 0,
          isSync: !0,
          onUpdate: (c) => {
            this.mixTargetDelta(c), r.onUpdate && r.onUpdate(c);
          },
          onStop: () => {
          },
          onComplete: () => {
            r.onComplete && r.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const r = this.getStack();
      r && r.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Sc), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const r = this.getLead();
      let { targetWithTransforms: a, target: l, layout: u, latestValues: c } = r;
      if (!(!a || !l || !u)) {
        if (this !== r && this.layout && u && kr(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {
          l = this.target || k();
          const h = j(this.layout.layoutBox.x);
          l.x.min = r.target.x.min, l.x.max = l.x.min + h;
          const f = j(this.layout.layoutBox.y);
          l.y.min = r.target.y.min, l.y.max = l.y.min + f;
        }
        _(a, l), gt(a, c), Et(this.projectionDeltaWithTransform, this.layoutCorrected, a, c);
      }
    }
    registerSharedNode(r, a) {
      this.sharedNodes.has(r) || this.sharedNodes.set(r, new bc()), this.sharedNodes.get(r).add(a);
      const u = a.options.initialPromotionConfig;
      a.promote({
        transition: u ? u.transition : void 0,
        preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0
      });
    }
    isLead() {
      const r = this.getStack();
      return r ? r.lead === this : !0;
    }
    getLead() {
      var a;
      const { layoutId: r } = this.options;
      return r ? ((a = this.getStack()) == null ? void 0 : a.lead) || this : this;
    }
    getPrevLead() {
      var a;
      const { layoutId: r } = this.options;
      return r ? (a = this.getStack()) == null ? void 0 : a.prevLead : void 0;
    }
    getStack() {
      const { layoutId: r } = this.options;
      if (r)
        return this.root.sharedNodes.get(r);
    }
    promote({ needsReset: r, transition: a, preserveFollowOpacity: l } = {}) {
      const u = this.getStack();
      u && u.promote(this, l), r && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });
    }
    relegate() {
      const r = this.getStack();
      return r ? r.relegate(this) : !1;
    }
    resetSkewAndRotation() {
      const { visualElement: r } = this.options;
      if (!r)
        return;
      let a = !1;
      const { latestValues: l } = r;
      if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a)
        return;
      const u = {};
      l.z && be("z", r, u, this.animationValues);
      for (let c = 0; c < we.length; c++)
        be(`rotate${we[c]}`, r, u, this.animationValues), be(`skew${we[c]}`, r, u, this.animationValues);
      r.render();
      for (const c in u)
        r.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]);
      r.scheduleRender();
    }
    applyProjectionStyles(r, a) {
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible) {
        r.visibility = "hidden";
        return;
      }
      const l = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = !1, r.visibility = "", r.opacity = "", r.pointerEvents = qt(a == null ? void 0 : a.pointerEvents) || "", r.transform = l ? l(this.latestValues, "") : "none";
        return;
      }
      const u = this.getLead();
      if (!this.projectionDelta || !this.layout || !u.target) {
        this.options.layoutId && (r.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, r.pointerEvents = qt(a == null ? void 0 : a.pointerEvents) || ""), this.hasProjected && !at(this.latestValues) && (r.transform = l ? l({}, "") : "none", this.hasProjected = !1);
        return;
      }
      r.visibility = "";
      const c = u.animationValues || u.latestValues;
      this.applyTransformsToTarget();
      let h = dc(this.projectionDeltaWithTransform, this.treeScale, c);
      l && (h = l(c, h)), r.transform = h;
      const { x: f, y: d } = this.projectionDelta;
      r.transformOrigin = `${f.origin * 100}% ${d.origin * 100}% 0`, u.animationValues ? r.opacity = u === this ? c.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : c.opacityExit : r.opacity = u === this ? c.opacity !== void 0 ? c.opacity : "" : c.opacityExit !== void 0 ? c.opacityExit : 0;
      for (const p in qe) {
        if (c[p] === void 0)
          continue;
        const { correct: g, applyTo: x, isCSSVariable: v } = qe[p], T = h === "none" ? c[p] : g(c[p], u);
        if (x) {
          const y = x.length;
          for (let w = 0; w < y; w++)
            r[x[w]] = T;
        } else
          v ? this.options.visualElement.renderState.vars[p] = T : r[p] = T;
      }
      this.options.layoutId && (r.pointerEvents = u === this ? qt(a == null ? void 0 : a.pointerEvents) || "" : "none");
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((r) => {
        var a;
        return (a = r.currentAnimation) == null ? void 0 : a.stop();
      }), this.root.nodes.forEach(ki), this.root.sharedNodes.clear();
    }
  };
}
function Pc(t) {
  t.updateLayout();
}
function Vc(t) {
  var n;
  const e = ((n = t.resumeFrom) == null ? void 0 : n.snapshot) || t.snapshot;
  if (t.isLead() && t.layout && e && t.hasListeners("didUpdate")) {
    const { layoutBox: i, measuredBox: s } = t.layout, { animationType: o } = t.options, r = e.source !== t.layout.source;
    o === "size" ? K((h) => {
      const f = r ? e.measuredBox[h] : e.layoutBox[h], d = j(f);
      f.min = i[h].min, f.max = f.min + d;
    }) : kr(o, e.layoutBox, i) && K((h) => {
      const f = r ? e.measuredBox[h] : e.layoutBox[h], d = j(i[h]);
      f.max = f.min + d, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[h].max = t.relativeTarget[h].min + d);
    });
    const a = pt();
    Et(a, i, e.layoutBox);
    const l = pt();
    r ? Et(l, t.applyTransform(s, !0), e.measuredBox) : Et(l, i, e.layoutBox);
    const u = !Cr(a);
    let c = !1;
    if (!t.resumeFrom) {
      const h = t.getClosestProjectingParent();
      if (h && !h.resumeFrom) {
        const { snapshot: f, layout: d } = h;
        if (f && d) {
          const p = k();
          se(p, e.layoutBox, f.layoutBox);
          const g = k();
          se(g, i, d.layoutBox), Dr(p, g) || (c = !0), h.options.layoutRoot && (t.relativeTarget = g, t.relativeTargetOrigin = p, t.relativeParent = h);
        }
      }
    }
    t.notifyListeners("didUpdate", {
      layout: i,
      snapshot: e,
      delta: l,
      layoutDelta: a,
      hasLayoutChanged: u,
      hasRelativeLayoutChanged: c
    });
  } else if (t.isLead()) {
    const { onExitComplete: i } = t.options;
    i && i();
  }
  t.options.transition = void 0;
}
function Cc(t) {
  t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));
}
function Dc(t) {
  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;
}
function Mc(t) {
  t.clearSnapshot();
}
function ki(t) {
  t.clearMeasurements();
}
function Bi(t) {
  t.isLayoutDirty = !1;
}
function Rc(t) {
  const { visualElement: e } = t.options;
  e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), t.resetTransform();
}
function Ii(t) {
  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;
}
function Ec(t) {
  t.resolveTargetDelta();
}
function Lc(t) {
  t.calcProjection();
}
function kc(t) {
  t.resetSkewAndRotation();
}
function Bc(t) {
  t.removeLeadSnapshot();
}
function Fi(t, e, n) {
  t.translate = E(e.translate, 0, n), t.scale = E(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;
}
function $i(t, e, n, i) {
  t.min = E(e.min, n.min, i), t.max = E(e.max, n.max, i);
}
function Ic(t, e, n, i) {
  $i(t.x, e.x, n.x, i), $i(t.y, e.y, n.y, i);
}
function Fc(t) {
  return t.animationValues && t.animationValues.opacityExit !== void 0;
}
const $c = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, Ni = (t) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), Oi = Ni("applewebkit/") && !Ni("chrome/") ? Math.round : G;
function ji(t) {
  t.min = Oi(t.min), t.max = Oi(t.max);
}
function Nc(t) {
  ji(t.x), ji(t.y);
}
function kr(t, e, n) {
  return t === "position" || t === "preserve-aspect" && !ac(Di(e), Di(n), 0.2);
}
function Oc(t) {
  var e;
  return t !== t.root && ((e = t.scroll) == null ? void 0 : e.wasRoot);
}
const jc = Lr({
  attachResizeListener: (t, e) => $t(t, "resize", e),
  measureScroll: () => {
    var t, e;
    return {
      x: document.documentElement.scrollLeft || ((t = document.body) == null ? void 0 : t.scrollLeft) || 0,
      y: document.documentElement.scrollTop || ((e = document.body) == null ? void 0 : e.scrollTop) || 0
    };
  },
  checkIsScrollRoot: () => !0
}), Se = {
  current: void 0
}, Br = Lr({
  measureScroll: (t) => ({
    x: t.scrollLeft,
    y: t.scrollTop
  }),
  defaultParent: () => {
    if (!Se.current) {
      const t = new jc({});
      t.mount(window), t.setOptions({ layoutScroll: !0 }), Se.current = t;
    }
    return Se.current;
  },
  resetTransform: (t, e) => {
    t.style.transform = e !== void 0 ? e : "none";
  },
  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === "fixed"
}), Bn = xt({
  transformPagePoint: (t) => t,
  isStatic: !1,
  reducedMotion: "never"
});
function Wi(t, e) {
  if (typeof t == "function")
    return t(e);
  t != null && (t.current = e);
}
function Wc(...t) {
  return (e) => {
    let n = !1;
    const i = t.map((s) => {
      const o = Wi(s, e);
      return !n && typeof o == "function" && (n = !0), o;
    });
    if (n)
      return () => {
        for (let s = 0; s < i.length; s++) {
          const o = i[s];
          typeof o == "function" ? o() : Wi(t[s], null);
        }
      };
  };
}
function Uc(...t) {
  return oe.useCallback(Wc(...t), t);
}
class Kc extends oe.Component {
  getSnapshotBeforeUpdate(e) {
    const n = this.props.childRef.current;
    if (n && e.isPresent && !this.props.isPresent) {
      const i = n.offsetParent, s = _e(i) && i.offsetWidth || 0, o = _e(i) && i.offsetHeight || 0, r = this.props.sizeRef.current;
      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft, r.right = s - r.width - r.left, r.bottom = o - r.height - r.top;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function zc({ children: t, isPresent: e, anchorX: n, anchorY: i, root: s }) {
  var h;
  const o = ae(), r = W(null), a = W({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  }), { nonce: l } = $(Bn), u = ((h = t.props) == null ? void 0 : h.ref) ?? (t == null ? void 0 : t.ref), c = Uc(r, u);
  return nn(() => {
    const { width: f, height: d, top: p, left: g, right: x, bottom: v } = a.current;
    if (e || !r.current || !f || !d)
      return;
    const T = n === "left" ? `left: ${g}` : `right: ${x}`, y = i === "bottom" ? `bottom: ${v}` : `top: ${p}`;
    r.current.dataset.motionPopId = o;
    const w = document.createElement("style");
    l && (w.nonce = l);
    const b = s ?? document.head;
    return b.appendChild(w), w.sheet && w.sheet.insertRule(`
          [data-motion-pop-id="${o}"] {
            position: absolute !important;
            width: ${f}px !important;
            height: ${d}px !important;
            ${T}px !important;
            ${y}px !important;
          }
        `), () => {
      b.contains(w) && b.removeChild(w);
    };
  }, [e]), D(Kc, { isPresent: e, childRef: r, sizeRef: a, children: oe.cloneElement(t, { ref: c }) });
}
const Gc = ({ children: t, initial: e, isPresent: n, onExitComplete: i, custom: s, presenceAffectsLayout: o, mode: r, anchorX: a, anchorY: l, root: u }) => {
  const c = on(_c), h = ae();
  let f = !0, d = Z(() => (f = !1, {
    id: h,
    initial: e,
    isPresent: n,
    custom: s,
    onExitComplete: (p) => {
      c.set(p, !0);
      for (const g of c.values())
        if (!g)
          return;
      i && i();
    },
    register: (p) => (c.set(p, !1), () => c.delete(p))
  }), [n, c, i]);
  return o && f && (d = { ...d }), Z(() => {
    c.forEach((p, g) => c.set(g, !1));
  }, [n]), oe.useEffect(() => {
    !n && !c.size && i && i();
  }, [n]), r === "popLayout" && (t = D(zc, { isPresent: n, anchorX: a, anchorY: l, root: u, children: t })), D(le.Provider, { value: d, children: t });
};
function _c() {
  return /* @__PURE__ */ new Map();
}
function Ir(t = !0) {
  const e = $(le);
  if (e === null)
    return [!0, null];
  const { isPresent: n, onExitComplete: i, register: s } = e, o = ae();
  en(() => {
    if (t)
      return s(o);
  }, [t]);
  const r = as(() => t && i && i(o), [o, i, t]);
  return !n && i ? [!1, r] : [!0];
}
const Gt = (t) => t.key || "";
function Ui(t) {
  const e = [];
  return ls.forEach(t, (n) => {
    cs(n) && e.push(n);
  }), e;
}
const Ki = ({ children: t, custom: e, initial: n = !0, onExitComplete: i, presenceAffectsLayout: s = !0, mode: o = "sync", propagate: r = !1, anchorX: a = "left", anchorY: l = "top", root: u }) => {
  const [c, h] = Ir(r), f = Z(() => Ui(t), [t]), d = r && !c ? [] : f.map(Gt), p = W(!0), g = W(f), x = on(() => /* @__PURE__ */ new Map()), v = W(/* @__PURE__ */ new Set()), [T, y] = Mt(f), [w, b] = Mt(f);
  ds(() => {
    p.current = !1, g.current = f;
    for (let A = 0; A < w.length; A++) {
      const V = Gt(w[A]);
      d.includes(V) ? (x.delete(V), v.current.delete(V)) : x.get(V) !== !0 && x.set(V, !1);
    }
  }, [w, d.length, d.join("-")]);
  const P = [];
  if (f !== T) {
    let A = [...f];
    for (let V = 0; V < w.length; V++) {
      const m = w[V], B = Gt(m);
      d.includes(B) || (A.splice(V, 0, m), P.push(m));
    }
    return o === "wait" && P.length && (A = P), b(Ui(A)), y(f), null;
  }
  process.env.NODE_ENV !== "production" && o === "wait" && w.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  const { forceRender: C } = $(rn);
  return D(ho, { children: w.map((A) => {
    const V = Gt(A), m = r && !c ? !1 : f === w || d.includes(V), B = () => {
      if (v.current.has(V))
        return;
      if (v.current.add(V), x.has(V))
        x.set(V, !0);
      else
        return;
      let At = !0;
      x.forEach((fe) => {
        fe || (At = !1);
      }), At && (C == null || C(), b(g.current), r && (h == null || h()), i && i());
    };
    return D(Gc, { isPresent: m, initial: !p.current || n ? void 0 : !1, custom: e, presenceAffectsLayout: s, mode: o, root: u, onExitComplete: m ? void 0 : B, anchorX: a, anchorY: l, children: A }, V);
  }) });
}, Fr = xt({ strict: !1 }), zi = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
let Gi = !1;
function Hc() {
  if (Gi)
    return;
  const t = {};
  for (const e in zi)
    t[e] = {
      isEnabled: (n) => zi[e].some((i) => !!n[i])
    };
  hr(t), Gi = !0;
}
function $r() {
  return Hc(), kl();
}
function Xc(t) {
  const e = $r();
  for (const n in t)
    e[n] = {
      ...e[n],
      ...t[n]
    };
  hr(e);
}
const Yc = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function re(t) {
  return t.startsWith("while") || t.startsWith("drag") && t !== "draggable" || t.startsWith("layout") || t.startsWith("onTap") || t.startsWith("onPan") || t.startsWith("onLayout") || Yc.has(t);
}
let Nr = (t) => !re(t);
function qc(t) {
  typeof t == "function" && (Nr = (e) => e.startsWith("on") ? !re(e) : t(e));
}
try {
  qc(require("@emotion/is-prop-valid").default);
} catch {
}
function Zc(t, e, n) {
  const i = {};
  for (const s in t)
    s === "values" && typeof t.values == "object" || (Nr(s) || n === !0 && re(s) || !e && !re(s) || // If trying to use native HTML drag events, forward drag listeners
    t.draggable && s.startsWith("onDrag")) && (i[s] = t[s]);
  return i;
}
const he = /* @__PURE__ */ xt({});
function Jc(t, e) {
  if (ue(t)) {
    const { initial: n, animate: i } = t;
    return {
      initial: n === !1 || Ft(n) ? n : void 0,
      animate: Ft(i) ? i : void 0
    };
  }
  return t.inherit !== !1 ? e : {};
}
function Qc(t) {
  const { initial: e, animate: n } = Jc(t, $(he));
  return Z(() => ({ initial: e, animate: n }), [_i(e), _i(n)]);
}
function _i(t) {
  return Array.isArray(t) ? t.join(" ") : t;
}
const In = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function Or(t, e, n) {
  for (const i in e)
    !N(e[i]) && !vr(i, n) && (t[i] = e[i]);
}
function tu({ transformTemplate: t }, e) {
  return Z(() => {
    const n = In();
    return Ln(n, e, t), Object.assign({}, n.vars, n.style);
  }, [e]);
}
function eu(t, e) {
  const n = t.style || {}, i = {};
  return Or(i, n, t), Object.assign(i, tu(t, e)), i;
}
function nu(t, e) {
  const n = {}, i = eu(t, e);
  return t.drag && t.dragListener !== !1 && (n.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = t.drag === !0 ? "none" : `pan-${t.drag === "x" ? "y" : "x"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = i, n;
}
const jr = () => ({
  ...In(),
  attrs: {}
});
function iu(t, e, n, i) {
  const s = Z(() => {
    const o = jr();
    return xr(o, e, wr(i), t.transformTemplate, t.style), {
      ...o.attrs,
      style: { ...o.style }
    };
  }, [e]);
  if (t.style) {
    const o = {};
    Or(o, t.style, t), s.style = { ...o, ...s.style };
  }
  return s;
}
const su = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function Fn(t) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof t != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    t.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(su.indexOf(t) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/u.test(t))
    )
  );
}
function ru(t, e, n, { latestValues: i }, s, o = !1, r) {
  const l = (r ?? Fn(t) ? iu : nu)(e, i, s, t), u = Zc(e, typeof t == "string", o), c = t !== us ? { ...u, ...l, ref: n } : {}, { children: h } = e, f = Z(() => N(h) ? h.get() : h, [h]);
  return Ht(t, {
    ...c,
    children: f
  });
}
function ou({ scrapeMotionValuesFromProps: t, createRenderState: e }, n, i, s) {
  return {
    latestValues: au(n, i, s, t),
    renderState: e()
  };
}
function au(t, e, n, i) {
  const s = {}, o = i(t, {});
  for (const f in o)
    s[f] = qt(o[f]);
  let { initial: r, animate: a } = t;
  const l = ue(t), u = ur(t);
  e && u && !l && t.inherit !== !1 && (r === void 0 && (r = e.initial), a === void 0 && (a = e.animate));
  let c = n ? n.initial === !1 : !1;
  c = c || r === !1;
  const h = c ? a : r;
  if (h && typeof h != "boolean" && !ce(h)) {
    const f = Array.isArray(h) ? h : [h];
    for (let d = 0; d < f.length; d++) {
      const p = Pn(t, f[d]);
      if (p) {
        const { transitionEnd: g, transition: x, ...v } = p;
        for (const T in v) {
          let y = v[T];
          if (Array.isArray(y)) {
            const w = c ? y.length - 1 : 0;
            y = y[w];
          }
          y !== null && (s[T] = y);
        }
        for (const T in g)
          s[T] = g[T];
      }
    }
  }
  return s;
}
const Wr = (t) => (e, n) => {
  const i = $(he), s = $(le), o = () => ou(t, e, i, s);
  return n ? o() : on(o);
}, lu = /* @__PURE__ */ Wr({
  scrapeMotionValuesFromProps: kn,
  createRenderState: In
}), cu = /* @__PURE__ */ Wr({
  scrapeMotionValuesFromProps: br,
  createRenderState: jr
}), uu = Symbol.for("motionComponentSymbol");
function hu(t, e, n) {
  const i = W(n);
  nn(() => {
    i.current = n;
  });
  const s = W(null);
  return as((o) => {
    var a;
    o && ((a = t.onMount) == null || a.call(t, o)), e && (o ? e.mount(o) : e.unmount());
    const r = i.current;
    if (typeof r == "function")
      if (o) {
        const l = r(o);
        typeof l == "function" && (s.current = l);
      } else s.current ? (s.current(), s.current = null) : r(o);
    else r && (r.current = o);
  }, [e]);
}
const Ur = xt({});
function Dt(t) {
  return t && typeof t == "object" && Object.prototype.hasOwnProperty.call(t, "current");
}
function fu(t, e, n, i, s, o) {
  var y, w;
  const { visualElement: r } = $(he), a = $(Fr), l = $(le), u = $(Bn), c = u.reducedMotion, h = u.skipAnimations, f = W(null), d = W(!1);
  i = i || a.renderer, !f.current && i && (f.current = i(t, {
    visualState: e,
    parent: r,
    props: n,
    presenceContext: l,
    blockInitialAnimation: l ? l.initial === !1 : !1,
    reducedMotionConfig: c,
    skipAnimations: h,
    isSVG: o
  }), d.current && f.current && (f.current.manuallyAnimateOnMount = !0));
  const p = f.current, g = $(Ur);
  p && !p.projection && s && (p.type === "html" || p.type === "svg") && du(f.current, n, s, g);
  const x = W(!1);
  nn(() => {
    p && x.current && p.update(n, l);
  });
  const v = n[qs], T = W(!!v && !((y = window.MotionHandoffIsComplete) != null && y.call(window, v)) && ((w = window.MotionHasOptimisedAnimation) == null ? void 0 : w.call(window, v)));
  return ds(() => {
    d.current = !0, p && (x.current = !0, window.MotionIsMounted = !0, p.updateFeatures(), p.scheduleRenderMicrotask(), T.current && p.animationState && p.animationState.animateChanges());
  }), en(() => {
    p && (!T.current && p.animationState && p.animationState.animateChanges(), T.current && (queueMicrotask(() => {
      var b;
      (b = window.MotionHandoffMarkAsComplete) == null || b.call(window, v);
    }), T.current = !1), p.enteringChildren = void 0);
  }), p;
}
function du(t, e, n, i) {
  const { layoutId: s, layout: o, drag: r, dragConstraints: a, layoutScroll: l, layoutRoot: u, layoutCrossfade: c } = e;
  t.projection = new n(t.latestValues, e["data-framer-portal-id"] ? void 0 : Kr(t.parent)), t.projection.setOptions({
    layoutId: s,
    layout: o,
    alwaysMeasureLayout: !!r || a && Dt(a),
    visualElement: t,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof o == "string" ? o : "both",
    initialPromotionConfig: i,
    crossfade: c,
    layoutScroll: l,
    layoutRoot: u
  });
}
function Kr(t) {
  if (t)
    return t.options.allowProjection !== !1 ? t.projection : Kr(t.parent);
}
function Ae(t, { forwardMotionProps: e = !1, type: n } = {}, i, s) {
  i && Xc(i);
  const o = n ? n === "svg" : Fn(t), r = o ? cu : lu;
  function a(u, c) {
    let h;
    const f = {
      ...$(Bn),
      ...u,
      layoutId: pu(u)
    }, { isStatic: d } = f, p = Qc(u), g = r(u, d);
    if (!d && fs) {
      mu(f, i);
      const x = gu(f);
      h = x.MeasureLayout, p.visualElement = fu(t, g, f, s, x.ProjectionNode, o);
    }
    return Jt(he.Provider, { value: p, children: [h && p.visualElement ? D(h, { visualElement: p.visualElement, ...f }) : null, ru(t, u, hu(g, p.visualElement, c), g, d, e, o)] });
  }
  a.displayName = `motion.${typeof t == "string" ? t : `create(${t.displayName ?? t.name ?? ""})`}`;
  const l = rs(a);
  return l[uu] = t, l;
}
function pu({ layoutId: t }) {
  const e = $(rn).id;
  return e && t !== void 0 ? e + "-" + t : t;
}
function mu(t, e) {
  const n = $(Fr).strict;
  if (process.env.NODE_ENV !== "production" && e && n) {
    const i = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    t.ignoreStrict ? Tt(!1, i, "lazy-strict-mode") : J(!1, i, "lazy-strict-mode");
  }
}
function gu(t) {
  const e = $r(), { drag: n, layout: i } = e;
  if (!n && !i)
    return {};
  const s = { ...n, ...i };
  return {
    MeasureLayout: n != null && n.isEnabled(t) || i != null && i.isEnabled(t) ? s.MeasureLayout : void 0,
    ProjectionNode: s.ProjectionNode
  };
}
function yu(t, e) {
  if (typeof Proxy > "u")
    return Ae;
  const n = /* @__PURE__ */ new Map(), i = (o, r) => Ae(o, r, t, e), s = (o, r) => (process.env.NODE_ENV !== "production" && hn(!1, "motion() is deprecated. Use motion.create() instead."), i(o, r));
  return new Proxy(s, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (o, r) => r === "create" ? i : (n.has(r) || n.set(r, Ae(r, void 0, t, e)), n.get(r))
  });
}
const vu = (t, e) => e.isSVG ?? Fn(t) ? new ql(e) : new zl(e, {
  allowProjection: t !== us
});
class xu extends st {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(e) {
    super(e), e.animationState || (e.animationState = ec(e));
  }
  updateAnimationControlsSubscription() {
    const { animate: e } = this.node.getProps();
    ce(e) && (this.unmountControls = e.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {};
    e !== n && this.updateAnimationControlsSubscription();
  }
  unmount() {
    var e;
    this.node.animationState.reset(), (e = this.unmountControls) == null || e.call(this);
  }
}
let Tu = 0;
class wu extends st {
  constructor() {
    super(...arguments), this.id = Tu++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: i } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || e === i)
      return;
    const s = this.node.animationState.setActive("exit", !e);
    n && !e && s.then(() => {
      n(this.id);
    });
  }
  mount() {
    const { register: e, onExitComplete: n } = this.node.presenceContext || {};
    n && n(this.id), e && (this.unmount = e(this.id));
  }
  unmount() {
  }
}
const bu = {
  animation: {
    Feature: xu
  },
  exit: {
    Feature: wu
  }
};
function Ut(t) {
  return {
    point: {
      x: t.pageX,
      y: t.pageY
    }
  };
}
const Su = (t) => (e) => Mn(e) && t(e, Ut(e));
function Lt(t, e, n, i) {
  return $t(t, e, Su(n), i);
}
const zr = ({ current: t }) => t ? t.ownerDocument.defaultView : null, Hi = (t, e) => Math.abs(t - e);
function Au(t, e) {
  const n = Hi(t.x, e.x), i = Hi(t.y, e.y);
  return Math.sqrt(n ** 2 + i ** 2);
}
const Xi = /* @__PURE__ */ new Set(["auto", "scroll"]);
class Gr {
  constructor(e, n, { transformPagePoint: i, contextWindow: s = window, dragSnapToOrigin: o = !1, distanceThreshold: r = 3, element: a } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = /* @__PURE__ */ new Map(), this.removeScrollListeners = null, this.onElementScroll = (d) => {
      this.handleScroll(d.target);
    }, this.onWindowScroll = () => {
      this.handleScroll(window);
    }, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const d = Ve(this.lastMoveEventInfo, this.history), p = this.startEvent !== null, g = Au(d.offset, { x: 0, y: 0 }) >= this.distanceThreshold;
      if (!p && !g)
        return;
      const { point: x } = d, { timestamp: v } = F;
      this.history.push({ ...x, timestamp: v });
      const { onStart: T, onMove: y } = this.handlers;
      p || (T && T(this.lastMoveEvent, d), this.startEvent = this.lastMoveEvent), y && y(this.lastMoveEvent, d);
    }, this.handlePointerMove = (d, p) => {
      this.lastMoveEvent = d, this.lastMoveEventInfo = Pe(p, this.transformPagePoint), M.update(this.updatePoint, !0);
    }, this.handlePointerUp = (d, p) => {
      this.end();
      const { onEnd: g, onSessionEnd: x, resumeAnimation: v } = this.handlers;
      if ((this.dragSnapToOrigin || !this.startEvent) && v && v(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const T = Ve(d.type === "pointercancel" ? this.lastMoveEventInfo : Pe(p, this.transformPagePoint), this.history);
      this.startEvent && g && g(d, T), x && x(d, T);
    }, !Mn(e))
      return;
    this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = i, this.distanceThreshold = r, this.contextWindow = s || window;
    const l = Ut(e), u = Pe(l, this.transformPagePoint), { point: c } = u, { timestamp: h } = F;
    this.history = [{ ...c, timestamp: h }];
    const { onSessionStart: f } = n;
    f && f(e, Ve(u, this.history)), this.removeListeners = Ot(Lt(this.contextWindow, "pointermove", this.handlePointerMove), Lt(this.contextWindow, "pointerup", this.handlePointerUp), Lt(this.contextWindow, "pointercancel", this.handlePointerUp)), a && this.startScrollTracking(a);
  }
  /**
   * Start tracking scroll on ancestors and window.
   */
  startScrollTracking(e) {
    let n = e.parentElement;
    for (; n; ) {
      const i = getComputedStyle(n);
      (Xi.has(i.overflowX) || Xi.has(i.overflowY)) && this.scrollPositions.set(n, {
        x: n.scrollLeft,
        y: n.scrollTop
      }), n = n.parentElement;
    }
    this.scrollPositions.set(window, {
      x: window.scrollX,
      y: window.scrollY
    }), window.addEventListener("scroll", this.onElementScroll, {
      capture: !0,
      passive: !0
    }), window.addEventListener("scroll", this.onWindowScroll, {
      passive: !0
    }), this.removeScrollListeners = () => {
      window.removeEventListener("scroll", this.onElementScroll, {
        capture: !0
      }), window.removeEventListener("scroll", this.onWindowScroll);
    };
  }
  /**
   * Handle scroll compensation during drag.
   *
   * For element scroll: adjusts history origin since pageX/pageY doesn't change.
   * For window scroll: adjusts lastMoveEventInfo since pageX/pageY would change.
   */
  handleScroll(e) {
    const n = this.scrollPositions.get(e);
    if (!n)
      return;
    const i = e === window, s = i ? { x: window.scrollX, y: window.scrollY } : {
      x: e.scrollLeft,
      y: e.scrollTop
    }, o = { x: s.x - n.x, y: s.y - n.y };
    o.x === 0 && o.y === 0 || (i ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += o.x, this.lastMoveEventInfo.point.y += o.y) : this.history.length > 0 && (this.history[0].x -= o.x, this.history[0].y -= o.y), this.scrollPositions.set(e, s), M.update(this.updatePoint, !0));
  }
  updateHandlers(e) {
    this.handlers = e;
  }
  end() {
    this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), nt(this.updatePoint);
  }
}
function Pe(t, e) {
  return e ? { point: e(t.point) } : t;
}
function Yi(t, e) {
  return { x: t.x - e.x, y: t.y - e.y };
}
function Ve({ point: t }, e) {
  return {
    point: t,
    delta: Yi(t, _r(e)),
    offset: Yi(t, Pu(e)),
    velocity: Vu(e, 0.1)
  };
}
function Pu(t) {
  return t[0];
}
function _r(t) {
  return t[t.length - 1];
}
function Vu(t, e) {
  if (t.length < 2)
    return { x: 0, y: 0 };
  let n = t.length - 1, i = null;
  const s = _r(t);
  for (; n >= 0 && (i = t[n], !(s.timestamp - i.timestamp > /* @__PURE__ */ X(e))); )
    n--;
  if (!i)
    return { x: 0, y: 0 };
  const o = /* @__PURE__ */ z(s.timestamp - i.timestamp);
  if (o === 0)
    return { x: 0, y: 0 };
  const r = {
    x: (s.x - i.x) / o,
    y: (s.y - i.y) / o
  };
  return r.x === 1 / 0 && (r.x = 0), r.y === 1 / 0 && (r.y = 0), r;
}
function Cu(t, { min: e, max: n }, i) {
  return e !== void 0 && t < e ? t = i ? E(e, t, i.min) : Math.max(t, e) : n !== void 0 && t > n && (t = i ? E(n, t, i.max) : Math.min(t, n)), t;
}
function qi(t, e, n) {
  return {
    min: e !== void 0 ? t.min + e : void 0,
    max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0
  };
}
function Du(t, { top: e, left: n, bottom: i, right: s }) {
  return {
    x: qi(t.x, n, s),
    y: qi(t.y, e, i)
  };
}
function Zi(t, e) {
  let n = e.min - t.min, i = e.max - t.max;
  return e.max - e.min < t.max - t.min && ([n, i] = [i, n]), { min: n, max: i };
}
function Mu(t, e) {
  return {
    x: Zi(t.x, e.x),
    y: Zi(t.y, e.y)
  };
}
function Ru(t, e) {
  let n = 0.5;
  const i = j(t), s = j(e);
  return s > i ? n = /* @__PURE__ */ kt(e.min, e.max - i, t.min) : i > s && (n = /* @__PURE__ */ kt(t.min, t.max - s, e.min)), q(0, 1, n);
}
function Eu(t, e) {
  const n = {};
  return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;
}
const Ze = 0.35;
function Lu(t = Ze) {
  return t === !1 ? t = 0 : t === !0 && (t = Ze), {
    x: Ji(t, "left", "right"),
    y: Ji(t, "top", "bottom")
  };
}
function Ji(t, e, n) {
  return {
    min: Qi(t, e),
    max: Qi(t, n)
  };
}
function Qi(t, e) {
  return typeof t == "number" ? t : t[e] || 0;
}
const ku = /* @__PURE__ */ new WeakMap();
class Bu {
  constructor(e) {
    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = k(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = e;
  }
  start(e, { snapToCursor: n = !1, distanceThreshold: i } = {}) {
    const { presenceContext: s } = this.visualElement;
    if (s && s.isPresent === !1)
      return;
    const o = (h) => {
      n ? (this.stopAnimation(), this.snapToCursor(Ut(h).point)) : this.pauseAnimation();
    }, r = (h, f) => {
      this.stopAnimation();
      const { drag: d, dragPropagation: p, onDragStart: g } = this.getProps();
      if (d && !p && (this.openDragLock && this.openDragLock(), this.openDragLock = wl(d), !this.openDragLock))
        return;
      this.latestPointerEvent = h, this.latestPanInfo = f, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), K((v) => {
        let T = this.getAxisMotionValue(v).get() || 0;
        if (Y.test(T)) {
          const { projection: y } = this.visualElement;
          if (y && y.layout) {
            const w = y.layout.layoutBox[v];
            w && (T = j(w) * (parseFloat(T) / 100));
          }
        }
        this.originPoint[v] = T;
      }), g && M.postRender(() => g(h, f)), Ke(this.visualElement, "transform");
      const { animationState: x } = this.visualElement;
      x && x.setActive("whileDrag", !0);
    }, a = (h, f) => {
      this.latestPointerEvent = h, this.latestPanInfo = f;
      const { dragPropagation: d, dragDirectionLock: p, onDirectionLock: g, onDrag: x } = this.getProps();
      if (!d && !this.openDragLock)
        return;
      const { offset: v } = f;
      if (p && this.currentDirection === null) {
        this.currentDirection = Iu(v), this.currentDirection !== null && g && g(this.currentDirection);
        return;
      }
      this.updateAxis("x", f.point, v), this.updateAxis("y", f.point, v), this.visualElement.render(), x && x(h, f);
    }, l = (h, f) => {
      this.latestPointerEvent = h, this.latestPanInfo = f, this.stop(h, f), this.latestPointerEvent = null, this.latestPanInfo = null;
    }, u = () => K((h) => {
      var f;
      return this.getAnimationState(h) === "paused" && ((f = this.getAxisMotionValue(h).animation) == null ? void 0 : f.play());
    }), { dragSnapToOrigin: c } = this.getProps();
    this.panSession = new Gr(e, {
      onSessionStart: o,
      onStart: r,
      onMove: a,
      onSessionEnd: l,
      resumeAnimation: u
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin: c,
      distanceThreshold: i,
      contextWindow: zr(this.visualElement),
      element: this.visualElement.current
    });
  }
  /**
   * @internal
   */
  stop(e, n) {
    const i = e || this.latestPointerEvent, s = n || this.latestPanInfo, o = this.isDragging;
    if (this.cancel(), !o || !s || !i)
      return;
    const { velocity: r } = s;
    this.startAnimation(r);
    const { onDragEnd: a } = this.getProps();
    a && M.postRender(() => a(i, s));
  }
  /**
   * @internal
   */
  cancel() {
    this.isDragging = !1;
    const { projection: e, animationState: n } = this.visualElement;
    e && (e.isAnimationBlocked = !1), this.endPanSession();
    const { dragPropagation: i } = this.getProps();
    !i && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1);
  }
  /**
   * Clean up the pan session without modifying other drag state.
   * This is used during unmount to ensure event listeners are removed
   * without affecting projection animations or drag locks.
   * @internal
   */
  endPanSession() {
    this.panSession && this.panSession.end(), this.panSession = void 0;
  }
  updateAxis(e, n, i) {
    const { drag: s } = this.getProps();
    if (!i || !_t(e, s, this.currentDirection))
      return;
    const o = this.getAxisMotionValue(e);
    let r = this.originPoint[e] + i[e];
    this.constraints && this.constraints[e] && (r = Cu(r, this.constraints[e], this.elastic[e])), o.set(r);
  }
  resolveConstraints() {
    var o;
    const { dragConstraints: e, dragElastic: n } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (o = this.visualElement.projection) == null ? void 0 : o.layout, s = this.constraints;
    e && Dt(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = Du(i.layoutBox, e) : this.constraints = !1, this.elastic = Lu(n), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && K((r) => {
      this.constraints !== !1 && this.getAxisMotionValue(r) && (this.constraints[r] = Eu(i.layoutBox[r], this.constraints[r]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps();
    if (!e || !Dt(e))
      return !1;
    const i = e.current;
    J(i !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref");
    const { projection: s } = this.visualElement;
    if (!s || !s.layout)
      return !1;
    const o = Nl(i, s.root, this.visualElement.getTransformPagePoint());
    let r = Mu(s.layout.layoutBox, o);
    if (n) {
      const a = n(Il(r));
      this.hasMutatedConstraints = !!a, a && (r = dr(a));
    }
    return r;
  }
  startAnimation(e) {
    const { drag: n, dragMomentum: i, dragElastic: s, dragTransition: o, dragSnapToOrigin: r, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = K((c) => {
      if (!_t(c, n, this.currentDirection))
        return;
      let h = l && l[c] || {};
      r && (h = { min: 0, max: 0 });
      const f = s ? 200 : 1e6, d = s ? 40 : 1e7, p = {
        type: "inertia",
        velocity: i ? e[c] : 0,
        bounceStiffness: f,
        bounceDamping: d,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...o,
        ...h
      };
      return this.startAxisValueAnimation(c, p);
    });
    return Promise.all(u).then(a);
  }
  startAxisValueAnimation(e, n) {
    const i = this.getAxisMotionValue(e);
    return Ke(this.visualElement, e), i.start(An(e, i, 0, n, this.visualElement, !1));
  }
  stopAnimation() {
    K((e) => this.getAxisMotionValue(e).stop());
  }
  pauseAnimation() {
    K((e) => {
      var n;
      return (n = this.getAxisMotionValue(e).animation) == null ? void 0 : n.pause();
    });
  }
  getAnimationState(e) {
    var n;
    return (n = this.getAxisMotionValue(e).animation) == null ? void 0 : n.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(e) {
    const n = `_drag${e.toUpperCase()}`, i = this.visualElement.getProps(), s = i[n];
    return s || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0);
  }
  snapToCursor(e) {
    K((n) => {
      const { drag: i } = this.getProps();
      if (!_t(n, i, this.currentDirection))
        return;
      const { projection: s } = this.visualElement, o = this.getAxisMotionValue(n);
      if (s && s.layout) {
        const { min: r, max: a } = s.layout.layoutBox[n], l = o.get() || 0;
        o.set(e[n] - E(r, a, 0.5) + l);
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: e, dragConstraints: n } = this.getProps(), { projection: i } = this.visualElement;
    if (!Dt(n) || !i || !this.constraints)
      return;
    this.stopAnimation();
    const s = { x: 0, y: 0 };
    K((r) => {
      const a = this.getAxisMotionValue(r);
      if (a && this.constraints !== !1) {
        const l = a.get();
        s[r] = Ru({ min: l, max: l }, this.constraints[r]);
      }
    });
    const { transformTemplate: o } = this.visualElement.getProps();
    this.visualElement.current.style.transform = o ? o({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), K((r) => {
      if (!_t(r, e, null))
        return;
      const a = this.getAxisMotionValue(r), { min: l, max: u } = this.constraints[r];
      a.set(E(l, u, s[r]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    ku.set(this.visualElement, this);
    const e = this.visualElement.current, n = Lt(e, "pointerdown", (l) => {
      const { drag: u, dragListener: c = !0 } = this.getProps(), h = l.target, f = h !== e && ar(h);
      u && c && !f && this.start(l);
    }), i = () => {
      const { dragConstraints: l } = this.getProps();
      Dt(l) && l.current && (this.constraints = this.resolveRefConstraints());
    }, { projection: s } = this.visualElement, o = s.addEventListener("measure", i);
    s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), M.read(i);
    const r = $t(window, "resize", () => this.scalePositionWithinConstraints()), a = s.addEventListener("didUpdate", (({ delta: l, hasLayoutChanged: u }) => {
      this.isDragging && u && (K((c) => {
        const h = this.getAxisMotionValue(c);
        h && (this.originPoint[c] += l[c].translate, h.set(h.get() + l[c].translate));
      }), this.visualElement.render());
    }));
    return () => {
      r(), n(), o(), a && a();
    };
  }
  getProps() {
    const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: i = !1, dragPropagation: s = !1, dragConstraints: o = !1, dragElastic: r = Ze, dragMomentum: a = !0 } = e;
    return {
      ...e,
      drag: n,
      dragDirectionLock: i,
      dragPropagation: s,
      dragConstraints: o,
      dragElastic: r,
      dragMomentum: a
    };
  }
}
function _t(t, e, n) {
  return (e === !0 || e === t) && (n === null || n === t);
}
function Iu(t, e = 10) {
  let n = null;
  return Math.abs(t.y) > e ? n = "y" : Math.abs(t.x) > e && (n = "x"), n;
}
class Fu extends st {
  constructor(e) {
    super(e), this.removeGroupControls = G, this.removeListeners = G, this.controls = new Bu(e);
  }
  mount() {
    const { dragControls: e } = this.node.getProps();
    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || G;
  }
  update() {
    const { dragControls: e } = this.node.getProps(), { dragControls: n } = this.node.prevProps || {};
    e !== n && (this.removeGroupControls(), e && (this.removeGroupControls = e.subscribe(this.controls)));
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners(), this.controls.isDragging || this.controls.endPanSession();
  }
}
const ts = (t) => (e, n) => {
  t && M.postRender(() => t(e, n));
};
class $u extends st {
  constructor() {
    super(...arguments), this.removePointerDownListener = G;
  }
  onPointerDown(e) {
    this.session = new Gr(e, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: zr(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart: e, onPanStart: n, onPan: i, onPanEnd: s } = this.node.getProps();
    return {
      onSessionStart: ts(e),
      onStart: ts(n),
      onMove: i,
      onEnd: (o, r) => {
        delete this.session, s && M.postRender(() => s(o, r));
      }
    };
  }
  mount() {
    this.removePointerDownListener = Lt(this.node.current, "pointerdown", (e) => this.onPointerDown(e));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
let Ce = !1;
class Nu extends fo {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: i, layoutId: s } = this.props, { projection: o } = e;
    o && (n.group && n.group.add(o), i && i.register && s && i.register(o), Ce && o.root.didUpdate(), o.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), o.setOptions({
      ...o.options,
      layoutDependency: this.props.layoutDependency,
      onExitComplete: () => this.safeToRemove()
    })), Zt.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(e) {
    const { layoutDependency: n, visualElement: i, drag: s, isPresent: o } = this.props, { projection: r } = i;
    return r && (r.isPresent = o, e.layoutDependency !== n && r.setOptions({
      ...r.options,
      layoutDependency: n
    }), Ce = !0, s || e.layoutDependency !== n || n === void 0 || e.isPresent !== o ? r.willUpdate() : this.safeToRemove(), e.isPresent !== o && (o ? r.promote() : r.relegate() || M.postRender(() => {
      const a = r.getStack();
      (!a || !a.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection: e } = this.props.visualElement;
    e && (e.root.didUpdate(), Dn.postRender(() => {
      !e.currentAnimation && e.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement: e, layoutGroup: n, switchLayoutGroup: i } = this.props, { projection: s } = e;
    Ce = !0, s && (s.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(s), i && i.deregister && i.deregister(s));
  }
  safeToRemove() {
    const { safeToRemove: e } = this.props;
    e && e();
  }
  render() {
    return null;
  }
}
function Hr(t) {
  const [e, n] = Ir(), i = $(rn);
  return D(Nu, { ...t, layoutGroup: i, switchLayoutGroup: $(Ur), isPresent: e, safeToRemove: n });
}
const Ou = {
  pan: {
    Feature: $u
  },
  drag: {
    Feature: Fu,
    ProjectionNode: Br,
    MeasureLayout: Hr
  }
};
function es(t, e, n) {
  const { props: i } = t;
  t.animationState && i.whileHover && t.animationState.setActive("whileHover", n === "Start");
  const s = "onHover" + n, o = i[s];
  o && M.postRender(() => o(e, Ut(e)));
}
class ju extends st {
  mount() {
    const { current: e } = this.node;
    e && (this.unmount = bl(e, (n, i) => (es(this.node, i, "Start"), (s) => es(this.node, s, "End"))));
  }
  unmount() {
  }
}
class Wu extends st {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let e = !1;
    try {
      e = this.node.current.matches(":focus-visible");
    } catch {
      e = !0;
    }
    !e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = Ot($t(this.node.current, "focus", () => this.onFocus()), $t(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
function ns(t, e, n) {
  const { props: i } = t;
  if (t.current instanceof HTMLButtonElement && t.current.disabled)
    return;
  t.animationState && i.whileTap && t.animationState.setActive("whileTap", n === "Start");
  const s = "onTap" + (n === "End" ? "" : n), o = i[s];
  o && M.postRender(() => o(e, Ut(e)));
}
class Uu extends st {
  mount() {
    const { current: e } = this.node;
    e && (this.unmount = Pl(e, (n, i) => (ns(this.node, i, "Start"), (s, { success: o }) => ns(this.node, s, o ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget }));
  }
  unmount() {
  }
}
const Je = /* @__PURE__ */ new WeakMap(), De = /* @__PURE__ */ new WeakMap(), Ku = (t) => {
  const e = Je.get(t.target);
  e && e(t);
}, zu = (t) => {
  t.forEach(Ku);
};
function Gu({ root: t, ...e }) {
  const n = t || document;
  De.has(n) || De.set(n, {});
  const i = De.get(n), s = JSON.stringify(e);
  return i[s] || (i[s] = new IntersectionObserver(zu, { root: t, ...e })), i[s];
}
function _u(t, e, n) {
  const i = Gu(e);
  return Je.set(t, n), i.observe(t), () => {
    Je.delete(t), i.unobserve(t);
  };
}
const Hu = {
  some: 0,
  all: 1
};
class Xu extends st {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport: e = {} } = this.node.getProps(), { root: n, margin: i, amount: s = "some", once: o } = e, r = {
      root: n ? n.current : void 0,
      rootMargin: i,
      threshold: typeof s == "number" ? s : Hu[s]
    }, a = (l) => {
      const { isIntersecting: u } = l;
      if (this.isInView === u || (this.isInView = u, o && !u && this.hasEnteredView))
        return;
      u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u);
      const { onViewportEnter: c, onViewportLeave: h } = this.node.getProps(), f = u ? c : h;
      f && f(l);
    };
    return _u(this.node.current, r, a);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props: e, prevProps: n } = this.node;
    ["amount", "margin", "root"].some(Yu(e, n)) && this.startObserver();
  }
  unmount() {
  }
}
function Yu({ viewport: t = {} }, { viewport: e = {} } = {}) {
  return (n) => t[n] !== e[n];
}
const qu = {
  inView: {
    Feature: Xu
  },
  tap: {
    Feature: Uu
  },
  focus: {
    Feature: Wu
  },
  hover: {
    Feature: ju
  }
}, Zu = {
  layout: {
    ProjectionNode: Br,
    MeasureLayout: Hr
  }
}, Ju = {
  ...bu,
  ...qu,
  ...Ou,
  ...Zu
}, Qe = /* @__PURE__ */ yu(Ju, vu);
function Xr(t) {
  var e, n, i = "";
  if (typeof t == "string" || typeof t == "number") i += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = Xr(t[e])) && (i && (i += " "), i += n);
  } else for (n in t) t[n] && (i && (i += " "), i += n);
  return i;
}
function Qu() {
  for (var t, e, n = 0, i = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = Xr(t)) && (i && (i += " "), i += e);
  return i;
}
const Nt = ({
  as: t,
  children: e,
  display: n,
  m: i,
  mt: s,
  mr: o,
  mb: r,
  ml: a,
  mx: l,
  my: u,
  p: c,
  pt: h,
  pr: f,
  pb: d,
  pl: p,
  px: g,
  py: x,
  width: v,
  height: T,
  position: y,
  style: w,
  className: b,
  disabled: P,
  required: C,
  ...A
}) => {
  const V = t || "div", m = {};
  n && (m.display = n), v && (m.width = v), T && (m.height = T), y && (m.position = y), i && (m.margin = `var(--pittorica-space-${i})`), s && (m.marginTop = `var(--pittorica-space-${s})`), o && (m.marginRight = `var(--pittorica-space-${o})`), r && (m.marginBottom = `var(--pittorica-space-${r})`), a && (m.marginLeft = `var(--pittorica-space-${a})`), l && (m.marginLeft = `var(--pittorica-space-${l})`, m.marginRight = `var(--pittorica-space-${l})`), u && (m.marginTop = `var(--pittorica-space-${u})`, m.marginBottom = `var(--pittorica-space-${u})`), c && (m.padding = `var(--pittorica-space-${c})`), h && (m.paddingTop = `var(--pittorica-space-${h})`), f && (m.paddingRight = `var(--pittorica-space-${f})`), d && (m.paddingBottom = `var(--pittorica-space-${d})`), p && (m.paddingLeft = `var(--pittorica-space-${p})`), g && (m.paddingLeft = `var(--pittorica-space-${g})`, m.paddingRight = `var(--pittorica-space-${g})`), x && (m.paddingTop = `var(--pittorica-space-${x})`, m.paddingBottom = `var(--pittorica-space-${x})`);
  const B = {
    ...w,
    ...m
  };
  return /* @__PURE__ */ D(
    V,
    {
      className: Qu("pittorica-box", b),
      style: B,
      disabled: P,
      required: C,
      ...A,
      children: e
    }
  );
};
Nt.displayName = "Box";
function Yr(t) {
  var e, n, i = "";
  if (typeof t == "string" || typeof t == "number") i += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = Yr(t[e])) && (i && (i += " "), i += n);
  } else for (n in t) t[n] && (i && (i += " "), i += n);
  return i;
}
function th() {
  for (var t, e, n = 0, i = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = Yr(t)) && (i && (i += " "), i += e);
  return i;
}
function qr(t) {
  var e, n, i = "";
  if (typeof t == "string" || typeof t == "number") i += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = qr(t[e])) && (i && (i += " "), i += n);
  } else for (n in t) t[n] && (i && (i += " "), i += n);
  return i;
}
function eh() {
  for (var t, e, n = 0, i = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = qr(t)) && (i && (i += " "), i += e);
  return i;
}
const Zr = ({
  as: t,
  children: e,
  display: n,
  m: i,
  mt: s,
  mr: o,
  mb: r,
  ml: a,
  mx: l,
  my: u,
  p: c,
  pt: h,
  pr: f,
  pb: d,
  pl: p,
  px: g,
  py: x,
  width: v,
  height: T,
  position: y,
  style: w,
  className: b,
  disabled: P,
  required: C,
  ...A
}) => {
  const V = t || "div", m = {};
  n && (m.display = n), v && (m.width = v), T && (m.height = T), y && (m.position = y), i && (m.margin = `var(--pittorica-space-${i})`), s && (m.marginTop = `var(--pittorica-space-${s})`), o && (m.marginRight = `var(--pittorica-space-${o})`), r && (m.marginBottom = `var(--pittorica-space-${r})`), a && (m.marginLeft = `var(--pittorica-space-${a})`), l && (m.marginLeft = `var(--pittorica-space-${l})`, m.marginRight = `var(--pittorica-space-${l})`), u && (m.marginTop = `var(--pittorica-space-${u})`, m.marginBottom = `var(--pittorica-space-${u})`), c && (m.padding = `var(--pittorica-space-${c})`), h && (m.paddingTop = `var(--pittorica-space-${h})`), f && (m.paddingRight = `var(--pittorica-space-${f})`), d && (m.paddingBottom = `var(--pittorica-space-${d})`), p && (m.paddingLeft = `var(--pittorica-space-${p})`), g && (m.paddingLeft = `var(--pittorica-space-${g})`, m.paddingRight = `var(--pittorica-space-${g})`), x && (m.paddingTop = `var(--pittorica-space-${x})`, m.paddingBottom = `var(--pittorica-space-${x})`);
  const B = {
    ...w,
    ...m
  };
  return /* @__PURE__ */ D(
    V,
    {
      className: eh("pittorica-box", b),
      style: B,
      disabled: P,
      required: C,
      ...A,
      children: e
    }
  );
};
Zr.displayName = "Box";
const tn = (t) => typeof t == "string" && t.startsWith("auto-");
function Vt(t, e) {
  return !e || tn(e) ? [] : typeof e == "string" ? [`pittorica-flex--${t}-${e}`] : Object.entries(e).filter(([, n]) => n !== void 0 && !tn(n)).map(
    ([n, i]) => n === "initial" ? `pittorica-flex--${t}-${i}` : `pittorica-flex--${n}-${t}-${i}`
  );
}
const Jr = ({
  children: t,
  direction: e,
  align: n,
  justify: i,
  wrap: s,
  gap: o,
  basis: r,
  className: a,
  style: l,
  as: u,
  ...c
}) => {
  const h = u || "div", f = [
    ...Vt("direction", e),
    ...Vt("align", n),
    ...Vt("justify", i),
    ...Vt("wrap", s),
    ...Vt("gap", o)
  ], d = { ...l };
  return tn(r) && (d["--pittorica-flex-basis"] = r.split("-")[1]), /* @__PURE__ */ D(
    Zr,
    {
      as: h,
      className: th("pittorica-flex", f, a),
      style: d,
      ...c,
      children: t
    }
  );
};
Jr.displayName = "Flex";
function Qr(t) {
  var e, n, i = "";
  if (typeof t == "string" || typeof t == "number") i += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = Qr(t[e])) && (i && (i += " "), i += n);
  } else for (n in t) t[n] && (i && (i += " "), i += n);
  return i;
}
function nh() {
  for (var t, e, n = 0, i = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = Qr(t)) && (i && (i += " "), i += e);
  return i;
}
function to(t) {
  var e, n, i = "";
  if (typeof t == "string" || typeof t == "number") i += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = to(t[e])) && (i && (i += " "), i += n);
  } else for (n in t) t[n] && (i && (i += " "), i += n);
  return i;
}
function ih() {
  for (var t, e, n = 0, i = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = to(t)) && (i && (i += " "), i += e);
  return i;
}
const eo = ({
  as: t,
  children: e,
  display: n,
  m: i,
  mt: s,
  mr: o,
  mb: r,
  ml: a,
  mx: l,
  my: u,
  p: c,
  pt: h,
  pr: f,
  pb: d,
  pl: p,
  px: g,
  py: x,
  width: v,
  height: T,
  position: y,
  style: w,
  className: b,
  disabled: P,
  required: C,
  ...A
}) => {
  const V = t || "div", m = {};
  n && (m.display = n), v && (m.width = v), T && (m.height = T), y && (m.position = y), i && (m.margin = `var(--pittorica-space-${i})`), s && (m.marginTop = `var(--pittorica-space-${s})`), o && (m.marginRight = `var(--pittorica-space-${o})`), r && (m.marginBottom = `var(--pittorica-space-${r})`), a && (m.marginLeft = `var(--pittorica-space-${a})`), l && (m.marginLeft = `var(--pittorica-space-${l})`, m.marginRight = `var(--pittorica-space-${l})`), u && (m.marginTop = `var(--pittorica-space-${u})`, m.marginBottom = `var(--pittorica-space-${u})`), c && (m.padding = `var(--pittorica-space-${c})`), h && (m.paddingTop = `var(--pittorica-space-${h})`), f && (m.paddingRight = `var(--pittorica-space-${f})`), d && (m.paddingBottom = `var(--pittorica-space-${d})`), p && (m.paddingLeft = `var(--pittorica-space-${p})`), g && (m.paddingLeft = `var(--pittorica-space-${g})`, m.paddingRight = `var(--pittorica-space-${g})`), x && (m.paddingTop = `var(--pittorica-space-${x})`, m.paddingBottom = `var(--pittorica-space-${x})`);
  const B = {
    ...w,
    ...m
  };
  return /* @__PURE__ */ D(
    V,
    {
      className: ih("pittorica-box", b),
      style: B,
      disabled: P,
      required: C,
      ...A,
      children: e
    }
  );
};
eo.displayName = "Box";
const no = ({
  children: t,
  variant: e = "filled",
  color: n = "source",
  size: i = "3",
  className: s,
  style: o,
  as: r,
  ...a
}) => {
  const l = n !== "inherit" && !(n != null && n.startsWith("#")) && !(n != null && n.startsWith("rgb")), u = {
    ...o,
    "--pittorica-source-color": l ? `var(--pittorica-${n}-9)` : n,
    "--pittorica-on-source-color": "#ffffff"
  }, c = r || (a.href ? "a" : "button");
  return /* @__PURE__ */ D(
    eo,
    {
      as: c,
      className: nh(
        "pittorica-icon-button",
        `pittorica-icon-button--${e}`,
        `pittorica-icon-button--${i}`,
        s
      ),
      style: u,
      ...a,
      children: t
    }
  );
};
no.displayName = "IconButton";
function io(t) {
  var e, n, i = "";
  if (typeof t == "string" || typeof t == "number") i += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = io(t[e])) && (i && (i += " "), i += n);
  } else for (n in t) t[n] && (i && (i += " "), i += n);
  return i;
}
function is() {
  for (var t, e, n = 0, i = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = io(t)) && (i && (i += " "), i += e);
  return i;
}
function so(t) {
  var e, n, i = "";
  if (typeof t == "string" || typeof t == "number") i += t;
  else if (typeof t == "object") if (Array.isArray(t)) {
    var s = t.length;
    for (e = 0; e < s; e++) t[e] && (n = so(t[e])) && (i && (i += " "), i += n);
  } else for (n in t) t[n] && (i && (i += " "), i += n);
  return i;
}
function sh() {
  for (var t, e, n = 0, i = "", s = arguments.length; n < s; n++) (t = arguments[n]) && (e = so(t)) && (i && (i += " "), i += e);
  return i;
}
const ro = ({
  as: t,
  children: e,
  display: n,
  m: i,
  mt: s,
  mr: o,
  mb: r,
  ml: a,
  mx: l,
  my: u,
  p: c,
  pt: h,
  pr: f,
  pb: d,
  pl: p,
  px: g,
  py: x,
  width: v,
  height: T,
  position: y,
  style: w,
  className: b,
  disabled: P,
  required: C,
  ...A
}) => {
  const V = t || "div", m = {};
  n && (m.display = n), v && (m.width = v), T && (m.height = T), y && (m.position = y), i && (m.margin = `var(--pittorica-space-${i})`), s && (m.marginTop = `var(--pittorica-space-${s})`), o && (m.marginRight = `var(--pittorica-space-${o})`), r && (m.marginBottom = `var(--pittorica-space-${r})`), a && (m.marginLeft = `var(--pittorica-space-${a})`), l && (m.marginLeft = `var(--pittorica-space-${l})`, m.marginRight = `var(--pittorica-space-${l})`), u && (m.marginTop = `var(--pittorica-space-${u})`, m.marginBottom = `var(--pittorica-space-${u})`), c && (m.padding = `var(--pittorica-space-${c})`), h && (m.paddingTop = `var(--pittorica-space-${h})`), f && (m.paddingRight = `var(--pittorica-space-${f})`), d && (m.paddingBottom = `var(--pittorica-space-${d})`), p && (m.paddingLeft = `var(--pittorica-space-${p})`), g && (m.paddingLeft = `var(--pittorica-space-${g})`, m.paddingRight = `var(--pittorica-space-${g})`), x && (m.paddingTop = `var(--pittorica-space-${x})`, m.paddingBottom = `var(--pittorica-space-${x})`);
  const B = {
    ...w,
    ...m
  };
  return /* @__PURE__ */ D(
    V,
    {
      className: sh("pittorica-box", b),
      style: B,
      disabled: P,
      required: C,
      ...A,
      children: e
    }
  );
};
ro.displayName = "Box";
const oo = ({
  children: t,
  as: e,
  size: n,
  weight: i = "regular",
  align: s,
  truncate: o = !1,
  color: r,
  className: a,
  style: l,
  ...u
}) => {
  const c = e || "span", h = (r == null ? void 0 : r.startsWith("#")) || (r == null ? void 0 : r.startsWith("rgb")) || (r == null ? void 0 : r.startsWith("hsl")), f = /* @__PURE__ */ new Set([
    "danger",
    "success",
    "error",
    "info",
    "indigo",
    "crimson",
    "teal",
    "amber",
    "slate",
    "blue",
    "red"
  ]), d = (() => {
    if (r)
      return r === "inherit" ? "inherit" : h ? r : f.has(r) ? `var(--pittorica-${r}-9)` : r;
  })(), p = n ? typeof n == "string" ? `pittorica-text--size-${n}` : is({
    [`pittorica-text--size-${n.initial}`]: n.initial,
    [`pittorica-text--xs-size-${n.xs}`]: n.xs,
    [`pittorica-text--sm-size-${n.sm}`]: n.sm,
    [`pittorica-text--md-size-${n.md}`]: n.md,
    [`pittorica-text--lg-size-${n.lg}`]: n.lg,
    [`pittorica-text--xl-size-${n.xl}`]: n.xl
  }) : null, g = {
    ...l,
    textAlign: s,
    color: d
  };
  return /* @__PURE__ */ D(
    ro,
    {
      as: c,
      className: is(
        "pittorica-text",
        p,
        { "pittorica-text--truncate": o },
        a
      ),
      "data-weight": i,
      style: g,
      ...u,
      children: t
    }
  );
};
oo.displayName = "Text";
const rh = ({
  children: t,
  sourceColor: e = "indigo",
  appearance: n = "light",
  radius: i = "medium",
  className: s,
  style: o,
  id: r
}) => {
  const a = e.startsWith("#") || e.startsWith("rgb"), l = {
    id: r,
    className: ["pittorica-theme", s].filter(Boolean).join(" "),
    "data-source-color": a ? "custom" : e,
    "data-appearance": n,
    "data-radius": i,
    style: {
      ...o,
      ...a ? { "--pittorica-source-color": e } : {}
    }
  };
  return /* @__PURE__ */ D("div", { ...l, children: t });
}, oh = ({
  total: t,
  active: e,
  carouselId: n
}) => /* @__PURE__ */ D(Jr, { gap: "2", justify: "center", className: "pittorica-carousel-pagination", children: Array.from({ length: t }).map((i, s) => /* @__PURE__ */ D(
  Qe.div,
  {
    layout: !0,
    style: {
      height: "8px",
      borderRadius: "4px",
      backgroundColor: s === e ? "var(--pittorica-slate-9)" : "var(--pittorica-slate-4)"
    },
    animate: {
      width: s === e ? "24px" : "8px",
      opacity: s === e ? 1 : 0.5
    },
    transition: { type: "spring", stiffness: 300, damping: 30 }
  },
  `${n}-dot-${s}`
)) }), ah = (t) => t === 0 ? { width: "60%", flex: "0 0 60%" } : t === 1 ? { width: "25%", flex: "0 0 25%" } : t === 2 ? { width: "15%", flex: "0 0 15%" } : { width: "0%", opacity: 0, flex: "0 0 0%" }, ao = ({
  children: t,
  className: e,
  defaultIndex: n = 0,
  appearance: i,
  as: s,
  ...o
}) => {
  const [r, a] = Mt(n), [l, u] = Mt(!1), [c, h] = Mt(), f = W(null), d = ae();
  os(() => {
    if (f.current) {
      const y = f.current.closest(
        ".pittorica-theme"
      );
      if (y) {
        const w = y.dataset.appearance;
        h(w || void 0);
      }
    }
  }, []);
  const p = Z(() => {
    const y = [];
    return ls.forEach(t, (w) => {
      cs(w) && y.push(w);
    }), y;
  }, [t]), g = Z(() => [
    ...p.slice(r),
    ...p.slice(0, r)
  ], [p, r]), x = (y, w, b) => {
    y.target.closest('button, a, input, [role="button"]') || (b === 0 ? u(!0) : a(w));
  }, v = s || "div", T = i === "inherit" ? c : i ?? c;
  return /* @__PURE__ */ D(
    Nt,
    {
      as: v,
      ref: f,
      className: sn("pittorica-carousel-root", e),
      ...o,
      children: /* @__PURE__ */ Jt(rh, { appearance: T, children: [
        /* @__PURE__ */ D("div", { className: "pittorica-carousel-viewport", children: /* @__PURE__ */ D(Ki, { mode: "popLayout", children: g.map((y, w) => {
          const b = (r + w) % p.length, P = ah(w);
          return w > 2 ? null : /* @__PURE__ */ D(
            Qe.div,
            {
              layout: !0,
              "data-visual-index": w,
              initial: { opacity: 0, x: 500 },
              animate: { opacity: 1, x: 0, ...P },
              exit: { opacity: 0, width: "0%" },
              className: "pittorica-carousel-item",
              onClick: (C) => x(C, b, w),
              children: y
            },
            b
          );
        }) }) }),
        /* @__PURE__ */ D(Ki, { children: l && /* @__PURE__ */ Jt(
          Qe.div,
          {
            initial: { opacity: 0 },
            animate: { opacity: 1 },
            exit: { opacity: 0 },
            className: "pittorica-carousel-lightbox",
            children: [
              /* @__PURE__ */ D(
                no,
                {
                  variant: "text",
                  onClick: () => u(!1),
                  className: "pittorica-carousel-lightbox-close",
                  as: "button",
                  children: /* @__PURE__ */ D(yo, { size: 32, color: "white" })
                }
              ),
              /* @__PURE__ */ D("div", { className: "pittorica-carousel-lightbox-content", children: /* @__PURE__ */ D(
                "div",
                {
                  "data-visual-index": "0",
                  style: { width: "100%", height: "100%" },
                  children: p[r]
                }
              ) })
            ]
          }
        ) }),
        /* @__PURE__ */ D(Nt, { mt: "4", children: /* @__PURE__ */ D(
          oh,
          {
            total: p.length,
            active: r,
            carouselId: d
          }
        ) })
      ] })
    }
  );
}, lo = ({
  children: t,
  src: e,
  alt: n,
  className: i,
  as: s,
  ...o
}) => /* @__PURE__ */ Jt(
  Nt,
  {
    as: s || "div",
    className: sn("pittorica-carousel-item-inner", i),
    style: { height: "100%", width: "100%" },
    ...o,
    children: [
      e && /* @__PURE__ */ D("div", { className: "pittorica-carousel-background-blur", children: /* @__PURE__ */ D("img", { src: e, alt: "", "aria-hidden": "true" }) }),
      /* @__PURE__ */ D("div", { className: "pittorica-carousel-main-image", children: e ? /* @__PURE__ */ D("img", { src: e, alt: n || "" }) : t }),
      e && t
    ]
  }
), co = ({
  children: t,
  className: e,
  as: n,
  ...i
}) => /* @__PURE__ */ D(
  Nt,
  {
    as: n || "div",
    className: sn("pittorica-carousel-description", e),
    ...i,
    children: /* @__PURE__ */ D(oo, { weight: "medium", children: t })
  }
), fh = {
  Root: ao,
  Item: lo,
  Description: co
};
ao.displayName = "Carousel.Root";
lo.displayName = "Carousel.Item";
co.displayName = "Carousel.Description";
export {
  fh as Carousel,
  co as CarouselDescription,
  lo as CarouselItem,
  ao as CarouselRoot
};
