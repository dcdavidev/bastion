import { jsxs as Qt, jsx as H } from "react/jsx-runtime";
import * as g from "react";
import { useLayoutEffect as _e, createContext as en, useState as vt, useMemo as tn, use as nn, useEffect as on } from "react";
import * as bt from "react-dom";
function yt(e) {
  var t, n, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var r = e.length;
    for (t = 0; t < r; t++) e[t] && (n = yt(e[t])) && (o && (o += " "), o += n);
  } else for (n in e) e[n] && (o && (o += " "), o += n);
  return o;
}
function rn() {
  for (var e, t, n = 0, o = "", r = arguments.length; n < r; n++) (e = arguments[n]) && (t = yt(e)) && (o && (o += " "), o += t);
  return o;
}
function we() {
  return typeof window < "u";
}
function re(e) {
  return Ve(e) ? (e.nodeName || "").toLowerCase() : "#document";
}
function $(e) {
  var t;
  return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window;
}
function j(e) {
  var t;
  return (t = (Ve(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement;
}
function Ve(e) {
  return we() ? e instanceof Node || e instanceof $(e).Node : !1;
}
function D(e) {
  return we() ? e instanceof Element || e instanceof $(e).Element : !1;
}
function N(e) {
  return we() ? e instanceof HTMLElement || e instanceof $(e).HTMLElement : !1;
}
function Le(e) {
  return !we() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof $(e).ShadowRoot;
}
const sn = /* @__PURE__ */ new Set(["inline", "contents"]);
function le(e) {
  const {
    overflow: t,
    overflowX: n,
    overflowY: o,
    display: r
  } = W(e);
  return /auto|scroll|overlay|hidden|clip/.test(t + o + n) && !sn.has(r);
}
const cn = /* @__PURE__ */ new Set(["table", "td", "th"]);
function an(e) {
  return cn.has(re(e));
}
const ln = [":popover-open", ":modal"];
function xe(e) {
  return ln.some((t) => {
    try {
      return e.matches(t);
    } catch {
      return !1;
    }
  });
}
const un = ["transform", "translate", "scale", "rotate", "perspective"], fn = ["transform", "translate", "scale", "rotate", "perspective", "filter"], dn = ["paint", "layout", "strict", "content"];
function We(e) {
  const t = Re(), n = D(e) ? W(e) : e;
  return un.some((o) => n[o] ? n[o] !== "none" : !1) || (n.containerType ? n.containerType !== "normal" : !1) || !t && (n.backdropFilter ? n.backdropFilter !== "none" : !1) || !t && (n.filter ? n.filter !== "none" : !1) || fn.some((o) => (n.willChange || "").includes(o)) || dn.some((o) => (n.contain || "").includes(o));
}
function pn(e) {
  let t = Y(e);
  for (; N(t) && !U(t); ) {
    if (We(t))
      return t;
    if (xe(t))
      return null;
    t = Y(t);
  }
  return null;
}
function Re() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
const mn = /* @__PURE__ */ new Set(["html", "body", "#document"]);
function U(e) {
  return mn.has(re(e));
}
function W(e) {
  return $(e).getComputedStyle(e);
}
function Ee(e) {
  return D(e) ? {
    scrollLeft: e.scrollLeft,
    scrollTop: e.scrollTop
  } : {
    scrollLeft: e.scrollX,
    scrollTop: e.scrollY
  };
}
function Y(e) {
  if (re(e) === "html")
    return e;
  const t = (
    // Step into the shadow DOM of the parent of a slotted node.
    e.assignedSlot || // DOM Element detected.
    e.parentNode || // ShadowRoot detected.
    Le(e) && e.host || // Fallback.
    j(e)
  );
  return Le(t) ? t.host : t;
}
function wt(e) {
  const t = Y(e);
  return U(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : N(t) && le(t) ? t : wt(t);
}
function Z(e, t, n) {
  var o;
  t === void 0 && (t = []), n === void 0 && (n = !0);
  const r = wt(e), i = r === ((o = e.ownerDocument) == null ? void 0 : o.body), s = $(r);
  if (i) {
    const c = Me(s);
    return t.concat(s, s.visualViewport || [], le(r) ? r : [], c && n ? Z(c) : []);
  }
  return t.concat(r, Z(r, [], n));
}
function Me(e) {
  return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null;
}
const pe = Math.min, J = Math.max, me = Math.round, ue = Math.floor, K = (e) => ({
  x: e,
  y: e
}), gn = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, hn = {
  start: "end",
  end: "start"
};
function Xe(e, t, n) {
  return J(e, pe(t, n));
}
function Se(e, t) {
  return typeof e == "function" ? e(t) : e;
}
function ee(e) {
  return e.split("-")[0];
}
function Ce(e) {
  return e.split("-")[1];
}
function xt(e) {
  return e === "x" ? "y" : "x";
}
function Rt(e) {
  return e === "y" ? "height" : "width";
}
const vn = /* @__PURE__ */ new Set(["top", "bottom"]);
function G(e) {
  return vn.has(ee(e)) ? "y" : "x";
}
function Et(e) {
  return xt(G(e));
}
function bn(e, t, n) {
  n === void 0 && (n = !1);
  const o = Ce(e), r = Et(e), i = Rt(r);
  let s = r === "x" ? o === (n ? "end" : "start") ? "right" : "left" : o === "start" ? "bottom" : "top";
  return t.reference[i] > t.floating[i] && (s = ge(s)), [s, ge(s)];
}
function yn(e) {
  const t = ge(e);
  return [ke(e), t, ke(t)];
}
function ke(e) {
  return e.replace(/start|end/g, (t) => hn[t]);
}
const ze = ["left", "right"], Ge = ["right", "left"], wn = ["top", "bottom"], xn = ["bottom", "top"];
function Rn(e, t, n) {
  switch (e) {
    case "top":
    case "bottom":
      return n ? t ? Ge : ze : t ? ze : Ge;
    case "left":
    case "right":
      return t ? wn : xn;
    default:
      return [];
  }
}
function En(e, t, n, o) {
  const r = Ce(e);
  let i = Rn(ee(e), n === "start", o);
  return r && (i = i.map((s) => s + "-" + r), t && (i = i.concat(i.map(ke)))), i;
}
function ge(e) {
  return e.replace(/left|right|bottom|top/g, (t) => gn[t]);
}
function Sn(e) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...e
  };
}
function Cn(e) {
  return typeof e != "number" ? Sn(e) : {
    top: e,
    right: e,
    bottom: e,
    left: e
  };
}
function he(e) {
  const {
    x: t,
    y: n,
    width: o,
    height: r
  } = e;
  return {
    width: o,
    height: r,
    top: n,
    left: t,
    right: t + o,
    bottom: n + r,
    x: t,
    y: n
  };
}
/*!
* tabbable 6.4.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
var Tn = ["input:not([inert]):not([inert] *)", "select:not([inert]):not([inert] *)", "textarea:not([inert]):not([inert] *)", "a[href]:not([inert]):not([inert] *)", "button:not([inert]):not([inert] *)", "[tabindex]:not(slot):not([inert]):not([inert] *)", "audio[controls]:not([inert]):not([inert] *)", "video[controls]:not([inert]):not([inert] *)", '[contenteditable]:not([contenteditable="false"]):not([inert]):not([inert] *)', "details>summary:first-of-type:not([inert]):not([inert] *)", "details:not([inert]):not([inert] *)"], Ne = /* @__PURE__ */ Tn.join(","), St = typeof Element > "u", ce = St ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector, ve = !St && Element.prototype.getRootNode ? function(e) {
  var t;
  return e == null || (t = e.getRootNode) === null || t === void 0 ? void 0 : t.call(e);
} : function(e) {
  return e == null ? void 0 : e.ownerDocument;
}, be = function(t, n) {
  var o;
  n === void 0 && (n = !0);
  var r = t == null || (o = t.getAttribute) === null || o === void 0 ? void 0 : o.call(t, "inert"), i = r === "" || r === "true", s = i || n && t && // closest does not exist on shadow roots, so we fall back to a manual
  // lookup upward, in case it is not defined.
  (typeof t.closest == "function" ? t.closest("[inert]") : be(t.parentNode));
  return s;
}, An = function(t) {
  var n, o = t == null || (n = t.getAttribute) === null || n === void 0 ? void 0 : n.call(t, "contenteditable");
  return o === "" || o === "true";
}, On = function(t, n, o) {
  if (be(t))
    return [];
  var r = Array.prototype.slice.apply(t.querySelectorAll(Ne));
  return n && ce.call(t, Ne) && r.unshift(t), r = r.filter(o), r;
}, Fe = function(t, n, o) {
  for (var r = [], i = Array.from(t); i.length; ) {
    var s = i.shift();
    if (!be(s, !1))
      if (s.tagName === "SLOT") {
        var c = s.assignedElements(), a = c.length ? c : s.children, l = Fe(a, !0, o);
        o.flatten ? r.push.apply(r, l) : r.push({
          scopeParent: s,
          candidates: l
        });
      } else {
        var u = ce.call(s, Ne);
        u && o.filter(s) && (n || !t.includes(s)) && r.push(s);
        var f = s.shadowRoot || // check for an undisclosed shadow
        typeof o.getShadowRoot == "function" && o.getShadowRoot(s), m = !be(f, !1) && (!o.shadowRootFilter || o.shadowRootFilter(s));
        if (f && m) {
          var d = Fe(f === !0 ? s.children : f.children, !0, o);
          o.flatten ? r.push.apply(r, d) : r.push({
            scopeParent: s,
            candidates: d
          });
        } else
          i.unshift.apply(i, s.children);
      }
  }
  return r;
}, Ct = function(t) {
  return !isNaN(parseInt(t.getAttribute("tabindex"), 10));
}, Tt = function(t) {
  if (!t)
    throw new Error("No node provided");
  return t.tabIndex < 0 && (/^(AUDIO|VIDEO|DETAILS)$/.test(t.tagName) || An(t)) && !Ct(t) ? 0 : t.tabIndex;
}, Pn = function(t, n) {
  var o = Tt(t);
  return o < 0 && n && !Ct(t) ? 0 : o;
}, In = function(t, n) {
  return t.tabIndex === n.tabIndex ? t.documentOrder - n.documentOrder : t.tabIndex - n.tabIndex;
}, At = function(t) {
  return t.tagName === "INPUT";
}, Dn = function(t) {
  return At(t) && t.type === "hidden";
}, Ln = function(t) {
  var n = t.tagName === "DETAILS" && Array.prototype.slice.apply(t.children).some(function(o) {
    return o.tagName === "SUMMARY";
  });
  return n;
}, Mn = function(t, n) {
  for (var o = 0; o < t.length; o++)
    if (t[o].checked && t[o].form === n)
      return t[o];
}, kn = function(t) {
  if (!t.name)
    return !0;
  var n = t.form || ve(t), o = function(c) {
    return n.querySelectorAll('input[type="radio"][name="' + c + '"]');
  }, r;
  if (typeof window < "u" && typeof window.CSS < "u" && typeof window.CSS.escape == "function")
    r = o(window.CSS.escape(t.name));
  else
    try {
      r = o(t.name);
    } catch (s) {
      return console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", s.message), !1;
    }
  var i = Mn(r, t.form);
  return !i || i === t;
}, Nn = function(t) {
  return At(t) && t.type === "radio";
}, Fn = function(t) {
  return Nn(t) && !kn(t);
}, $n = function(t) {
  var n, o = t && ve(t), r = (n = o) === null || n === void 0 ? void 0 : n.host, i = !1;
  if (o && o !== t) {
    var s, c, a;
    for (i = !!((s = r) !== null && s !== void 0 && (c = s.ownerDocument) !== null && c !== void 0 && c.contains(r) || t != null && (a = t.ownerDocument) !== null && a !== void 0 && a.contains(t)); !i && r; ) {
      var l, u, f;
      o = ve(r), r = (l = o) === null || l === void 0 ? void 0 : l.host, i = !!((u = r) !== null && u !== void 0 && (f = u.ownerDocument) !== null && f !== void 0 && f.contains(r));
    }
  }
  return i;
}, Ze = function(t) {
  var n = t.getBoundingClientRect(), o = n.width, r = n.height;
  return o === 0 && r === 0;
}, Bn = function(t, n) {
  var o = n.displayCheck, r = n.getShadowRoot;
  if (o === "full-native" && "checkVisibility" in t) {
    var i = t.checkVisibility({
      // Checking opacity might be desirable for some use cases, but natively,
      // opacity zero elements _are_ focusable and tabbable.
      checkOpacity: !1,
      opacityProperty: !1,
      contentVisibilityAuto: !0,
      visibilityProperty: !0,
      // This is an alias for `visibilityProperty`. Contemporary browsers
      // support both. However, this alias has wider browser support (Chrome
      // >= 105 and Firefox >= 106, vs. Chrome >= 121 and Firefox >= 122), so
      // we include it anyway.
      checkVisibilityCSS: !0
    });
    return !i;
  }
  if (getComputedStyle(t).visibility === "hidden")
    return !0;
  var s = ce.call(t, "details>summary:first-of-type"), c = s ? t.parentElement : t;
  if (ce.call(c, "details:not([open]) *"))
    return !0;
  if (!o || o === "full" || // full-native can run this branch when it falls through in case
  // Element#checkVisibility is unsupported
  o === "full-native" || o === "legacy-full") {
    if (typeof r == "function") {
      for (var a = t; t; ) {
        var l = t.parentElement, u = ve(t);
        if (l && !l.shadowRoot && r(l) === !0)
          return Ze(t);
        t.assignedSlot ? t = t.assignedSlot : !l && u !== t.ownerDocument ? t = u.host : t = l;
      }
      t = a;
    }
    if ($n(t))
      return !t.getClientRects().length;
    if (o !== "legacy-full")
      return !0;
  } else if (o === "non-zero-area")
    return Ze(t);
  return !1;
}, _n = function(t) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(t.tagName))
    for (var n = t.parentElement; n; ) {
      if (n.tagName === "FIELDSET" && n.disabled) {
        for (var o = 0; o < n.children.length; o++) {
          var r = n.children.item(o);
          if (r.tagName === "LEGEND")
            return ce.call(n, "fieldset[disabled] *") ? !0 : !r.contains(t);
        }
        return !0;
      }
      n = n.parentElement;
    }
  return !1;
}, Vn = function(t, n) {
  return !(n.disabled || Dn(n) || Bn(n, t) || // For a details element with a summary, the summary element gets the focus
  Ln(n) || _n(n));
}, Je = function(t, n) {
  return !(Fn(n) || Tt(n) < 0 || !Vn(t, n));
}, Wn = function(t) {
  var n = parseInt(t.getAttribute("tabindex"), 10);
  return !!(isNaN(n) || n >= 0);
}, Ot = function(t) {
  var n = [], o = [];
  return t.forEach(function(r, i) {
    var s = !!r.scopeParent, c = s ? r.scopeParent : r, a = Pn(c, s), l = s ? Ot(r.candidates) : c;
    a === 0 ? s ? n.push.apply(n, l) : n.push(c) : o.push({
      documentOrder: i,
      tabIndex: a,
      item: r,
      isScope: s,
      content: l
    });
  }), o.sort(In).reduce(function(r, i) {
    return i.isScope ? r.push.apply(r, i.content) : r.push(i.content), r;
  }, []).concat(n);
}, Pt = function(t, n) {
  n = n || {};
  var o;
  return n.getShadowRoot ? o = Fe([t], n.includeContainer, {
    filter: Je.bind(null, n),
    flatten: !1,
    getShadowRoot: n.getShadowRoot,
    shadowRootFilter: Wn
  }) : o = On(t, n.includeContainer, Je.bind(null, n)), Ot(o);
};
function Hn() {
  return /apple/i.test(navigator.vendor);
}
const Qe = "data-floating-ui-focusable", Kn = "input:not([type='hidden']):not([disabled]),[contenteditable]:not([contenteditable='false']),textarea:not([disabled])";
function jn(e) {
  let t = e.activeElement;
  for (; ((n = t) == null || (n = n.shadowRoot) == null ? void 0 : n.activeElement) != null; ) {
    var n;
    t = t.shadowRoot.activeElement;
  }
  return t;
}
function $e(e, t) {
  if (!e || !t)
    return !1;
  const n = t.getRootNode == null ? void 0 : t.getRootNode();
  if (e.contains(t))
    return !0;
  if (n && Le(n)) {
    let o = t;
    for (; o; ) {
      if (e === o)
        return !0;
      o = o.parentNode || o.host;
    }
  }
  return !1;
}
function se(e) {
  return "composedPath" in e ? e.composedPath()[0] : e.target;
}
function Ae(e, t) {
  if (t == null)
    return !1;
  if ("composedPath" in e)
    return e.composedPath().includes(t);
  const n = e;
  return n.target != null && t.contains(n.target);
}
function qn(e) {
  return e.matches("html,body");
}
function ae(e) {
  return (e == null ? void 0 : e.ownerDocument) || document;
}
function Un(e) {
  return N(e) && e.matches(Kn);
}
function Yn(e) {
  return e ? e.hasAttribute(Qe) ? e : e.querySelector("[" + Qe + "]") || e : null;
}
function fe(e, t, n) {
  return n === void 0 && (n = !0), e.filter((r) => {
    var i;
    return r.parentId === t && (!n || ((i = r.context) == null ? void 0 : i.open));
  }).flatMap((r) => [r, ...fe(e, r.id, n)]);
}
function Xn(e) {
  return "nativeEvent" in e;
}
function et(e, t) {
  return ["mouse", "pen"].includes(e);
}
var zn = typeof document < "u", Gn = function() {
}, Q = zn ? _e : Gn;
const Zn = {
  ...g
}, Jn = Zn.useInsertionEffect, Qn = Jn || ((e) => e());
function ne(e) {
  const t = g.useRef(() => {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Cannot call an event handler while rendering.");
  });
  return Qn(() => {
    t.current = e;
  }), g.useCallback(function() {
    for (var n = arguments.length, o = new Array(n), r = 0; r < n; r++)
      o[r] = arguments[r];
    return t.current == null ? void 0 : t.current(...o);
  }, []);
}
const It = () => ({
  getShadowRoot: !0,
  displayCheck: (
    // JSDOM does not support the `tabbable` library. To solve this we can
    // check if `ResizeObserver` is a real function (not polyfilled), which
    // determines if the current environment is JSDOM-like.
    typeof ResizeObserver == "function" && ResizeObserver.toString().includes("[native code]") ? "full" : "none"
  )
});
function Dt(e, t) {
  const n = Pt(e, It()), o = n.length;
  if (o === 0) return;
  const r = jn(ae(e)), i = n.indexOf(r), s = i === -1 ? t === 1 ? 0 : o - 1 : i + t;
  return n[s];
}
function eo(e) {
  return Dt(ae(e).body, 1) || e;
}
function to(e) {
  return Dt(ae(e).body, -1) || e;
}
function Oe(e, t) {
  const n = t || e.currentTarget, o = e.relatedTarget;
  return !o || !$e(n, o);
}
function no(e) {
  Pt(e, It()).forEach((n) => {
    n.dataset.tabindex = n.getAttribute("tabindex") || "", n.setAttribute("tabindex", "-1");
  });
}
function tt(e) {
  e.querySelectorAll("[data-tabindex]").forEach((n) => {
    const o = n.dataset.tabindex;
    delete n.dataset.tabindex, o ? n.setAttribute("tabindex", o) : n.removeAttribute("tabindex");
  });
}
function nt(e, t, n) {
  let {
    reference: o,
    floating: r
  } = e;
  const i = G(t), s = Et(t), c = Rt(s), a = ee(t), l = i === "y", u = o.x + o.width / 2 - r.width / 2, f = o.y + o.height / 2 - r.height / 2, m = o[c] / 2 - r[c] / 2;
  let d;
  switch (a) {
    case "top":
      d = {
        x: u,
        y: o.y - r.height
      };
      break;
    case "bottom":
      d = {
        x: u,
        y: o.y + o.height
      };
      break;
    case "right":
      d = {
        x: o.x + o.width,
        y: f
      };
      break;
    case "left":
      d = {
        x: o.x - r.width,
        y: f
      };
      break;
    default:
      d = {
        x: o.x,
        y: o.y
      };
  }
  switch (Ce(t)) {
    case "start":
      d[s] -= m * (n && l ? -1 : 1);
      break;
    case "end":
      d[s] += m * (n && l ? -1 : 1);
      break;
  }
  return d;
}
async function oo(e, t) {
  var n;
  t === void 0 && (t = {});
  const {
    x: o,
    y: r,
    platform: i,
    rects: s,
    elements: c,
    strategy: a
  } = e, {
    boundary: l = "clippingAncestors",
    rootBoundary: u = "viewport",
    elementContext: f = "floating",
    altBoundary: m = !1,
    padding: d = 0
  } = Se(t, e), v = Cn(d), b = c[m ? f === "floating" ? "reference" : "floating" : f], h = he(await i.getClippingRect({
    element: (n = await (i.isElement == null ? void 0 : i.isElement(b))) == null || n ? b : b.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(c.floating)),
    boundary: l,
    rootBoundary: u,
    strategy: a
  })), w = f === "floating" ? {
    x: o,
    y: r,
    width: s.floating.width,
    height: s.floating.height
  } : s.reference, x = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(c.floating)), E = await (i.isElement == null ? void 0 : i.isElement(x)) ? await (i.getScale == null ? void 0 : i.getScale(x)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, C = he(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: w,
    offsetParent: x,
    strategy: a
  }) : w);
  return {
    top: (h.top - C.top + v.top) / E.y,
    bottom: (C.bottom - h.bottom + v.bottom) / E.y,
    left: (h.left - C.left + v.left) / E.x,
    right: (C.right - h.right + v.right) / E.x
  };
}
const ro = async (e, t, n) => {
  const {
    placement: o = "bottom",
    strategy: r = "absolute",
    middleware: i = [],
    platform: s
  } = n, c = i.filter(Boolean), a = await (s.isRTL == null ? void 0 : s.isRTL(t));
  let l = await s.getElementRects({
    reference: e,
    floating: t,
    strategy: r
  }), {
    x: u,
    y: f
  } = nt(l, o, a), m = o, d = {}, v = 0;
  for (let b = 0; b < c.length; b++) {
    var p;
    const {
      name: h,
      fn: w
    } = c[b], {
      x,
      y: E,
      data: C,
      reset: T
    } = await w({
      x: u,
      y: f,
      initialPlacement: o,
      placement: m,
      strategy: r,
      middlewareData: d,
      rects: l,
      platform: {
        ...s,
        detectOverflow: (p = s.detectOverflow) != null ? p : oo
      },
      elements: {
        reference: e,
        floating: t
      }
    });
    u = x ?? u, f = E ?? f, d = {
      ...d,
      [h]: {
        ...d[h],
        ...C
      }
    }, T && v <= 50 && (v++, typeof T == "object" && (T.placement && (m = T.placement), T.rects && (l = T.rects === !0 ? await s.getElementRects({
      reference: e,
      floating: t,
      strategy: r
    }) : T.rects), {
      x: u,
      y: f
    } = nt(l, m, a)), b = -1);
  }
  return {
    x: u,
    y: f,
    placement: m,
    strategy: r,
    middlewareData: d
  };
}, io = function(e) {
  return e === void 0 && (e = {}), {
    name: "flip",
    options: e,
    async fn(t) {
      var n, o;
      const {
        placement: r,
        middlewareData: i,
        rects: s,
        initialPlacement: c,
        platform: a,
        elements: l
      } = t, {
        mainAxis: u = !0,
        crossAxis: f = !0,
        fallbackPlacements: m,
        fallbackStrategy: d = "bestFit",
        fallbackAxisSideDirection: v = "none",
        flipAlignment: p = !0,
        ...b
      } = Se(e, t);
      if ((n = i.arrow) != null && n.alignmentOffset)
        return {};
      const h = ee(r), w = G(c), x = ee(c) === c, E = await (a.isRTL == null ? void 0 : a.isRTL(l.floating)), C = m || (x || !p ? [ge(c)] : yn(c)), T = v !== "none";
      !m && T && C.push(...En(c, p, v, E));
      const M = [c, ...C], k = await a.detectOverflow(t, b), B = [];
      let S = ((o = i.flip) == null ? void 0 : o.overflows) || [];
      if (u && B.push(k[h]), f) {
        const R = bn(r, s, E);
        B.push(k[R[0]], k[R[1]]);
      }
      if (S = [...S, {
        placement: r,
        overflows: B
      }], !B.every((R) => R <= 0)) {
        var _, X;
        const R = (((_ = i.flip) == null ? void 0 : _.index) || 0) + 1, L = M[R];
        if (L && (!(f === "alignment" ? w !== G(L) : !1) || // We leave the current main axis only if every placement on that axis
        // overflows the main axis.
        S.every((y) => G(y.placement) === w ? y.overflows[0] > 0 : !0)))
          return {
            data: {
              index: R,
              overflows: S
            },
            reset: {
              placement: L
            }
          };
        let O = (X = S.filter((P) => P.overflows[0] <= 0).sort((P, y) => P.overflows[1] - y.overflows[1])[0]) == null ? void 0 : X.placement;
        if (!O)
          switch (d) {
            case "bestFit": {
              var V;
              const P = (V = S.filter((y) => {
                if (T) {
                  const A = G(y.placement);
                  return A === w || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  A === "y";
                }
                return !0;
              }).map((y) => [y.placement, y.overflows.filter((A) => A > 0).reduce((A, I) => A + I, 0)]).sort((y, A) => y[1] - A[1])[0]) == null ? void 0 : V[0];
              P && (O = P);
              break;
            }
            case "initialPlacement":
              O = c;
              break;
          }
        if (r !== O)
          return {
            reset: {
              placement: O
            }
          };
      }
      return {};
    }
  };
}, so = /* @__PURE__ */ new Set(["left", "top"]);
async function co(e, t) {
  const {
    placement: n,
    platform: o,
    elements: r
  } = e, i = await (o.isRTL == null ? void 0 : o.isRTL(r.floating)), s = ee(n), c = Ce(n), a = G(n) === "y", l = so.has(s) ? -1 : 1, u = i && a ? -1 : 1, f = Se(t, e);
  let {
    mainAxis: m,
    crossAxis: d,
    alignmentAxis: v
  } = typeof f == "number" ? {
    mainAxis: f,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: f.mainAxis || 0,
    crossAxis: f.crossAxis || 0,
    alignmentAxis: f.alignmentAxis
  };
  return c && typeof v == "number" && (d = c === "end" ? v * -1 : v), a ? {
    x: d * u,
    y: m * l
  } : {
    x: m * l,
    y: d * u
  };
}
const ao = function(e) {
  return e === void 0 && (e = 0), {
    name: "offset",
    options: e,
    async fn(t) {
      var n, o;
      const {
        x: r,
        y: i,
        placement: s,
        middlewareData: c
      } = t, a = await co(t, e);
      return s === ((n = c.offset) == null ? void 0 : n.placement) && (o = c.arrow) != null && o.alignmentOffset ? {} : {
        x: r + a.x,
        y: i + a.y,
        data: {
          ...a,
          placement: s
        }
      };
    }
  };
}, lo = function(e) {
  return e === void 0 && (e = {}), {
    name: "shift",
    options: e,
    async fn(t) {
      const {
        x: n,
        y: o,
        placement: r,
        platform: i
      } = t, {
        mainAxis: s = !0,
        crossAxis: c = !1,
        limiter: a = {
          fn: (h) => {
            let {
              x: w,
              y: x
            } = h;
            return {
              x: w,
              y: x
            };
          }
        },
        ...l
      } = Se(e, t), u = {
        x: n,
        y: o
      }, f = await i.detectOverflow(t, l), m = G(ee(r)), d = xt(m);
      let v = u[d], p = u[m];
      if (s) {
        const h = d === "y" ? "top" : "left", w = d === "y" ? "bottom" : "right", x = v + f[h], E = v - f[w];
        v = Xe(x, v, E);
      }
      if (c) {
        const h = m === "y" ? "top" : "left", w = m === "y" ? "bottom" : "right", x = p + f[h], E = p - f[w];
        p = Xe(x, p, E);
      }
      const b = a.fn({
        ...t,
        [d]: v,
        [m]: p
      });
      return {
        ...b,
        data: {
          x: b.x - n,
          y: b.y - o,
          enabled: {
            [d]: s,
            [m]: c
          }
        }
      };
    }
  };
};
function Lt(e) {
  const t = W(e);
  let n = parseFloat(t.width) || 0, o = parseFloat(t.height) || 0;
  const r = N(e), i = r ? e.offsetWidth : n, s = r ? e.offsetHeight : o, c = me(n) !== i || me(o) !== s;
  return c && (n = i, o = s), {
    width: n,
    height: o,
    $: c
  };
}
function He(e) {
  return D(e) ? e : e.contextElement;
}
function oe(e) {
  const t = He(e);
  if (!N(t))
    return K(1);
  const n = t.getBoundingClientRect(), {
    width: o,
    height: r,
    $: i
  } = Lt(t);
  let s = (i ? me(n.width) : n.width) / o, c = (i ? me(n.height) : n.height) / r;
  return (!s || !Number.isFinite(s)) && (s = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: s,
    y: c
  };
}
const uo = /* @__PURE__ */ K(0);
function Mt(e) {
  const t = $(e);
  return !Re() || !t.visualViewport ? uo : {
    x: t.visualViewport.offsetLeft,
    y: t.visualViewport.offsetTop
  };
}
function fo(e, t, n) {
  return t === void 0 && (t = !1), !n || t && n !== $(e) ? !1 : t;
}
function te(e, t, n, o) {
  t === void 0 && (t = !1), n === void 0 && (n = !1);
  const r = e.getBoundingClientRect(), i = He(e);
  let s = K(1);
  t && (o ? D(o) && (s = oe(o)) : s = oe(e));
  const c = fo(i, n, o) ? Mt(i) : K(0);
  let a = (r.left + c.x) / s.x, l = (r.top + c.y) / s.y, u = r.width / s.x, f = r.height / s.y;
  if (i) {
    const m = $(i), d = o && D(o) ? $(o) : o;
    let v = m, p = Me(v);
    for (; p && o && d !== v; ) {
      const b = oe(p), h = p.getBoundingClientRect(), w = W(p), x = h.left + (p.clientLeft + parseFloat(w.paddingLeft)) * b.x, E = h.top + (p.clientTop + parseFloat(w.paddingTop)) * b.y;
      a *= b.x, l *= b.y, u *= b.x, f *= b.y, a += x, l += E, v = $(p), p = Me(v);
    }
  }
  return he({
    width: u,
    height: f,
    x: a,
    y: l
  });
}
function Te(e, t) {
  const n = Ee(e).scrollLeft;
  return t ? t.left + n : te(j(e)).left + n;
}
function kt(e, t) {
  const n = e.getBoundingClientRect(), o = n.left + t.scrollLeft - Te(e, n), r = n.top + t.scrollTop;
  return {
    x: o,
    y: r
  };
}
function po(e) {
  let {
    elements: t,
    rect: n,
    offsetParent: o,
    strategy: r
  } = e;
  const i = r === "fixed", s = j(o), c = t ? xe(t.floating) : !1;
  if (o === s || c && i)
    return n;
  let a = {
    scrollLeft: 0,
    scrollTop: 0
  }, l = K(1);
  const u = K(0), f = N(o);
  if ((f || !f && !i) && ((re(o) !== "body" || le(s)) && (a = Ee(o)), N(o))) {
    const d = te(o);
    l = oe(o), u.x = d.x + o.clientLeft, u.y = d.y + o.clientTop;
  }
  const m = s && !f && !i ? kt(s, a) : K(0);
  return {
    width: n.width * l.x,
    height: n.height * l.y,
    x: n.x * l.x - a.scrollLeft * l.x + u.x + m.x,
    y: n.y * l.y - a.scrollTop * l.y + u.y + m.y
  };
}
function mo(e) {
  return Array.from(e.getClientRects());
}
function go(e) {
  const t = j(e), n = Ee(e), o = e.ownerDocument.body, r = J(t.scrollWidth, t.clientWidth, o.scrollWidth, o.clientWidth), i = J(t.scrollHeight, t.clientHeight, o.scrollHeight, o.clientHeight);
  let s = -n.scrollLeft + Te(e);
  const c = -n.scrollTop;
  return W(o).direction === "rtl" && (s += J(t.clientWidth, o.clientWidth) - r), {
    width: r,
    height: i,
    x: s,
    y: c
  };
}
const ot = 25;
function ho(e, t) {
  const n = $(e), o = j(e), r = n.visualViewport;
  let i = o.clientWidth, s = o.clientHeight, c = 0, a = 0;
  if (r) {
    i = r.width, s = r.height;
    const u = Re();
    (!u || u && t === "fixed") && (c = r.offsetLeft, a = r.offsetTop);
  }
  const l = Te(o);
  if (l <= 0) {
    const u = o.ownerDocument, f = u.body, m = getComputedStyle(f), d = u.compatMode === "CSS1Compat" && parseFloat(m.marginLeft) + parseFloat(m.marginRight) || 0, v = Math.abs(o.clientWidth - f.clientWidth - d);
    v <= ot && (i -= v);
  } else l <= ot && (i += l);
  return {
    width: i,
    height: s,
    x: c,
    y: a
  };
}
const vo = /* @__PURE__ */ new Set(["absolute", "fixed"]);
function bo(e, t) {
  const n = te(e, !0, t === "fixed"), o = n.top + e.clientTop, r = n.left + e.clientLeft, i = N(e) ? oe(e) : K(1), s = e.clientWidth * i.x, c = e.clientHeight * i.y, a = r * i.x, l = o * i.y;
  return {
    width: s,
    height: c,
    x: a,
    y: l
  };
}
function rt(e, t, n) {
  let o;
  if (t === "viewport")
    o = ho(e, n);
  else if (t === "document")
    o = go(j(e));
  else if (D(t))
    o = bo(t, n);
  else {
    const r = Mt(e);
    o = {
      x: t.x - r.x,
      y: t.y - r.y,
      width: t.width,
      height: t.height
    };
  }
  return he(o);
}
function Nt(e, t) {
  const n = Y(e);
  return n === t || !D(n) || U(n) ? !1 : W(n).position === "fixed" || Nt(n, t);
}
function yo(e, t) {
  const n = t.get(e);
  if (n)
    return n;
  let o = Z(e, [], !1).filter((c) => D(c) && re(c) !== "body"), r = null;
  const i = W(e).position === "fixed";
  let s = i ? Y(e) : e;
  for (; D(s) && !U(s); ) {
    const c = W(s), a = We(s);
    !a && c.position === "fixed" && (r = null), (i ? !a && !r : !a && c.position === "static" && !!r && vo.has(r.position) || le(s) && !a && Nt(e, s)) ? o = o.filter((u) => u !== s) : r = c, s = Y(s);
  }
  return t.set(e, o), o;
}
function wo(e) {
  let {
    element: t,
    boundary: n,
    rootBoundary: o,
    strategy: r
  } = e;
  const s = [...n === "clippingAncestors" ? xe(t) ? [] : yo(t, this._c) : [].concat(n), o], c = s[0], a = s.reduce((l, u) => {
    const f = rt(t, u, r);
    return l.top = J(f.top, l.top), l.right = pe(f.right, l.right), l.bottom = pe(f.bottom, l.bottom), l.left = J(f.left, l.left), l;
  }, rt(t, c, r));
  return {
    width: a.right - a.left,
    height: a.bottom - a.top,
    x: a.left,
    y: a.top
  };
}
function xo(e) {
  const {
    width: t,
    height: n
  } = Lt(e);
  return {
    width: t,
    height: n
  };
}
function Ro(e, t, n) {
  const o = N(t), r = j(t), i = n === "fixed", s = te(e, !0, i, t);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const a = K(0);
  function l() {
    a.x = Te(r);
  }
  if (o || !o && !i)
    if ((re(t) !== "body" || le(r)) && (c = Ee(t)), o) {
      const d = te(t, !0, i, t);
      a.x = d.x + t.clientLeft, a.y = d.y + t.clientTop;
    } else r && l();
  i && !o && r && l();
  const u = r && !o && !i ? kt(r, c) : K(0), f = s.left + c.scrollLeft - a.x - u.x, m = s.top + c.scrollTop - a.y - u.y;
  return {
    x: f,
    y: m,
    width: s.width,
    height: s.height
  };
}
function Pe(e) {
  return W(e).position === "static";
}
function it(e, t) {
  if (!N(e) || W(e).position === "fixed")
    return null;
  if (t)
    return t(e);
  let n = e.offsetParent;
  return j(e) === n && (n = n.ownerDocument.body), n;
}
function Ft(e, t) {
  const n = $(e);
  if (xe(e))
    return n;
  if (!N(e)) {
    let r = Y(e);
    for (; r && !U(r); ) {
      if (D(r) && !Pe(r))
        return r;
      r = Y(r);
    }
    return n;
  }
  let o = it(e, t);
  for (; o && an(o) && Pe(o); )
    o = it(o, t);
  return o && U(o) && Pe(o) && !We(o) ? n : o || pn(e) || n;
}
const Eo = async function(e) {
  const t = this.getOffsetParent || Ft, n = this.getDimensions, o = await n(e.floating);
  return {
    reference: Ro(e.reference, await t(e.floating), e.strategy),
    floating: {
      x: 0,
      y: 0,
      width: o.width,
      height: o.height
    }
  };
};
function So(e) {
  return W(e).direction === "rtl";
}
const Co = {
  convertOffsetParentRelativeRectToViewportRelativeRect: po,
  getDocumentElement: j,
  getClippingRect: wo,
  getOffsetParent: Ft,
  getElementRects: Eo,
  getClientRects: mo,
  getDimensions: xo,
  getScale: oe,
  isElement: D,
  isRTL: So
};
function $t(e, t) {
  return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height;
}
function To(e, t) {
  let n = null, o;
  const r = j(e);
  function i() {
    var c;
    clearTimeout(o), (c = n) == null || c.disconnect(), n = null;
  }
  function s(c, a) {
    c === void 0 && (c = !1), a === void 0 && (a = 1), i();
    const l = e.getBoundingClientRect(), {
      left: u,
      top: f,
      width: m,
      height: d
    } = l;
    if (c || t(), !m || !d)
      return;
    const v = ue(f), p = ue(r.clientWidth - (u + m)), b = ue(r.clientHeight - (f + d)), h = ue(u), x = {
      rootMargin: -v + "px " + -p + "px " + -b + "px " + -h + "px",
      threshold: J(0, pe(1, a)) || 1
    };
    let E = !0;
    function C(T) {
      const M = T[0].intersectionRatio;
      if (M !== a) {
        if (!E)
          return s();
        M ? s(!1, M) : o = setTimeout(() => {
          s(!1, 1e-7);
        }, 1e3);
      }
      M === 1 && !$t(l, e.getBoundingClientRect()) && s(), E = !1;
    }
    try {
      n = new IntersectionObserver(C, {
        ...x,
        // Handle <iframe>s
        root: r.ownerDocument
      });
    } catch {
      n = new IntersectionObserver(C, x);
    }
    n.observe(e);
  }
  return s(!0), i;
}
function Ao(e, t, n, o) {
  o === void 0 && (o = {});
  const {
    ancestorScroll: r = !0,
    ancestorResize: i = !0,
    elementResize: s = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: a = !1
  } = o, l = He(e), u = r || i ? [...l ? Z(l) : [], ...Z(t)] : [];
  u.forEach((h) => {
    r && h.addEventListener("scroll", n, {
      passive: !0
    }), i && h.addEventListener("resize", n);
  });
  const f = l && c ? To(l, n) : null;
  let m = -1, d = null;
  s && (d = new ResizeObserver((h) => {
    let [w] = h;
    w && w.target === l && d && (d.unobserve(t), cancelAnimationFrame(m), m = requestAnimationFrame(() => {
      var x;
      (x = d) == null || x.observe(t);
    })), n();
  }), l && !a && d.observe(l), d.observe(t));
  let v, p = a ? te(e) : null;
  a && b();
  function b() {
    const h = te(e);
    p && !$t(p, h) && n(), p = h, v = requestAnimationFrame(b);
  }
  return n(), () => {
    var h;
    u.forEach((w) => {
      r && w.removeEventListener("scroll", n), i && w.removeEventListener("resize", n);
    }), f == null || f(), (h = d) == null || h.disconnect(), d = null, a && cancelAnimationFrame(v);
  };
}
const Oo = ao, Po = lo, Io = io, Do = (e, t, n) => {
  const o = /* @__PURE__ */ new Map(), r = {
    platform: Co,
    ...n
  }, i = {
    ...r.platform,
    _c: o
  };
  return ro(e, t, {
    ...r,
    platform: i
  });
};
var Lo = typeof document < "u", Mo = function() {
}, de = Lo ? _e : Mo;
function ye(e, t) {
  if (e === t)
    return !0;
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "function" && e.toString() === t.toString())
    return !0;
  let n, o, r;
  if (e && t && typeof e == "object") {
    if (Array.isArray(e)) {
      if (n = e.length, n !== t.length) return !1;
      for (o = n; o-- !== 0; )
        if (!ye(e[o], t[o]))
          return !1;
      return !0;
    }
    if (r = Object.keys(e), n = r.length, n !== Object.keys(t).length)
      return !1;
    for (o = n; o-- !== 0; )
      if (!{}.hasOwnProperty.call(t, r[o]))
        return !1;
    for (o = n; o-- !== 0; ) {
      const i = r[o];
      if (!(i === "_owner" && e.$$typeof) && !ye(e[i], t[i]))
        return !1;
    }
    return !0;
  }
  return e !== e && t !== t;
}
function Bt(e) {
  return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function st(e, t) {
  const n = Bt(e);
  return Math.round(t * n) / n;
}
function Ie(e) {
  const t = g.useRef(e);
  return de(() => {
    t.current = e;
  }), t;
}
function ko(e) {
  e === void 0 && (e = {});
  const {
    placement: t = "bottom",
    strategy: n = "absolute",
    middleware: o = [],
    platform: r,
    elements: {
      reference: i,
      floating: s
    } = {},
    transform: c = !0,
    whileElementsMounted: a,
    open: l
  } = e, [u, f] = g.useState({
    x: 0,
    y: 0,
    strategy: n,
    placement: t,
    middlewareData: {},
    isPositioned: !1
  }), [m, d] = g.useState(o);
  ye(m, o) || d(o);
  const [v, p] = g.useState(null), [b, h] = g.useState(null), w = g.useCallback((y) => {
    y !== T.current && (T.current = y, p(y));
  }, []), x = g.useCallback((y) => {
    y !== M.current && (M.current = y, h(y));
  }, []), E = i || v, C = s || b, T = g.useRef(null), M = g.useRef(null), k = g.useRef(u), B = a != null, S = Ie(a), _ = Ie(r), X = Ie(l), V = g.useCallback(() => {
    if (!T.current || !M.current)
      return;
    const y = {
      placement: t,
      strategy: n,
      middleware: m
    };
    _.current && (y.platform = _.current), Do(T.current, M.current, y).then((A) => {
      const I = {
        ...A,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: X.current !== !1
      };
      R.current && !ye(k.current, I) && (k.current = I, bt.flushSync(() => {
        f(I);
      }));
    });
  }, [m, t, n, _, X]);
  de(() => {
    l === !1 && k.current.isPositioned && (k.current.isPositioned = !1, f((y) => ({
      ...y,
      isPositioned: !1
    })));
  }, [l]);
  const R = g.useRef(!1);
  de(() => (R.current = !0, () => {
    R.current = !1;
  }), []), de(() => {
    if (E && (T.current = E), C && (M.current = C), E && C) {
      if (S.current)
        return S.current(E, C, V);
      V();
    }
  }, [E, C, V, S, B]);
  const L = g.useMemo(() => ({
    reference: T,
    floating: M,
    setReference: w,
    setFloating: x
  }), [w, x]), O = g.useMemo(() => ({
    reference: E,
    floating: C
  }), [E, C]), P = g.useMemo(() => {
    const y = {
      position: n,
      left: 0,
      top: 0
    };
    if (!O.floating)
      return y;
    const A = st(O.floating, u.x), I = st(O.floating, u.y);
    return c ? {
      ...y,
      transform: "translate(" + A + "px, " + I + "px)",
      ...Bt(O.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: n,
      left: A,
      top: I
    };
  }, [n, c, O.floating, u.x, u.y]);
  return g.useMemo(() => ({
    ...u,
    update: V,
    refs: L,
    elements: O,
    floatingStyles: P
  }), [u, V, L, O, P]);
}
const No = (e, t) => ({
  ...Oo(e),
  options: [e, t]
}), Fo = (e, t) => ({
  ...Po(e),
  options: [e, t]
}), $o = (e, t) => ({
  ...Io(e),
  options: [e, t]
}), Bo = "data-floating-ui-focusable", ct = "active", at = "selected", _o = {
  ...g
};
let lt = !1, Vo = 0;
const ut = () => (
  // Ensure the id is unique with multiple independent versions of Floating UI
  // on <React 18
  "floating-ui-" + Math.random().toString(36).slice(2, 6) + Vo++
);
function Wo() {
  const [e, t] = g.useState(() => lt ? ut() : void 0);
  return Q(() => {
    e == null && t(ut());
  }, []), g.useEffect(() => {
    lt = !0;
  }, []), e;
}
const Ho = _o.useId, Ke = Ho || Wo;
let Be;
process.env.NODE_ENV !== "production" && (Be = /* @__PURE__ */ new Set());
function Ko() {
  for (var e, t = arguments.length, n = new Array(t), o = 0; o < t; o++)
    n[o] = arguments[o];
  const r = "Floating UI: " + n.join(" ");
  if (!((e = Be) != null && e.has(r))) {
    var i;
    (i = Be) == null || i.add(r), console.error(r);
  }
}
function jo() {
  const e = /* @__PURE__ */ new Map();
  return {
    emit(t, n) {
      var o;
      (o = e.get(t)) == null || o.forEach((r) => r(n));
    },
    on(t, n) {
      e.has(t) || e.set(t, /* @__PURE__ */ new Set()), e.get(t).add(n);
    },
    off(t, n) {
      var o;
      (o = e.get(t)) == null || o.delete(n);
    }
  };
}
const qo = /* @__PURE__ */ g.createContext(null), Uo = /* @__PURE__ */ g.createContext(null), _t = () => {
  var e;
  return ((e = g.useContext(qo)) == null ? void 0 : e.id) || null;
}, Vt = () => g.useContext(Uo);
function je(e) {
  return "data-floating-ui-" + e;
}
const Yo = {
  border: 0,
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: 0,
  position: "fixed",
  whiteSpace: "nowrap",
  width: "1px",
  top: 0,
  left: 0
}, ft = /* @__PURE__ */ g.forwardRef(function(t, n) {
  const [o, r] = g.useState();
  Q(() => {
    Hn() && r("button");
  }, []);
  const i = {
    ref: n,
    tabIndex: 0,
    // Role is only for VoiceOver
    role: o,
    "aria-hidden": o ? void 0 : !0,
    [je("focus-guard")]: "",
    style: Yo
  };
  return /* @__PURE__ */ H("span", {
    ...t,
    ...i
  });
}), Xo = {
  clipPath: "inset(50%)",
  position: "fixed",
  top: 0,
  left: 0
}, Wt = /* @__PURE__ */ g.createContext(null), dt = /* @__PURE__ */ je("portal");
function zo(e) {
  e === void 0 && (e = {});
  const {
    id: t,
    root: n
  } = e, o = Ke(), r = Zo(), [i, s] = g.useState(null), c = g.useRef(null);
  return Q(() => () => {
    i == null || i.remove(), queueMicrotask(() => {
      c.current = null;
    });
  }, [i]), Q(() => {
    if (!o || c.current) return;
    const a = t ? document.getElementById(t) : null;
    if (!a) return;
    const l = document.createElement("div");
    l.id = o, l.setAttribute(dt, ""), a.appendChild(l), c.current = l, s(l);
  }, [t, o]), Q(() => {
    if (n === null || !o || c.current) return;
    let a = n || (r == null ? void 0 : r.portalNode);
    a && !Ve(a) && (a = a.current), a = a || document.body;
    let l = null;
    t && (l = document.createElement("div"), l.id = t, a.appendChild(l));
    const u = document.createElement("div");
    u.id = o, u.setAttribute(dt, ""), a = l || a, a.appendChild(u), c.current = u, s(u);
  }, [t, n, o, r]), i;
}
function Go(e) {
  const {
    children: t,
    id: n,
    root: o,
    preserveTabOrder: r = !0
  } = e, i = zo({
    id: n,
    root: o
  }), [s, c] = g.useState(null), a = g.useRef(null), l = g.useRef(null), u = g.useRef(null), f = g.useRef(null), m = s == null ? void 0 : s.modal, d = s == null ? void 0 : s.open, v = (
    // The FocusManager and therefore floating element are currently open/
    // rendered.
    !!s && // Guards are only for non-modal focus management.
    !s.modal && // Don't render if unmount is transitioning.
    s.open && r && !!(o || i)
  );
  return g.useEffect(() => {
    if (!i || !r || m)
      return;
    function p(b) {
      i && Oe(b) && (b.type === "focusin" ? tt : no)(i);
    }
    return i.addEventListener("focusin", p, !0), i.addEventListener("focusout", p, !0), () => {
      i.removeEventListener("focusin", p, !0), i.removeEventListener("focusout", p, !0);
    };
  }, [i, r, m]), g.useEffect(() => {
    i && (d || tt(i));
  }, [d, i]), /* @__PURE__ */ Qt(Wt.Provider, {
    value: g.useMemo(() => ({
      preserveTabOrder: r,
      beforeOutsideRef: a,
      afterOutsideRef: l,
      beforeInsideRef: u,
      afterInsideRef: f,
      portalNode: i,
      setFocusManagerState: c
    }), [r, i]),
    children: [v && i && /* @__PURE__ */ H(ft, {
      "data-type": "outside",
      ref: a,
      onFocus: (p) => {
        if (Oe(p, i)) {
          var b;
          (b = u.current) == null || b.focus();
        } else {
          const h = s ? s.domReference : null, w = to(h);
          w == null || w.focus();
        }
      }
    }), v && i && /* @__PURE__ */ H("span", {
      "aria-owns": i.id,
      style: Xo
    }), i && /* @__PURE__ */ bt.createPortal(t, i), v && i && /* @__PURE__ */ H(ft, {
      "data-type": "outside",
      ref: l,
      onFocus: (p) => {
        if (Oe(p, i)) {
          var b;
          (b = f.current) == null || b.focus();
        } else {
          const h = s ? s.domReference : null, w = eo(h);
          w == null || w.focus(), s != null && s.closeOnFocusOut && (s == null || s.onOpenChange(!1, p.nativeEvent, "focus-out"));
        }
      }
    })]
  });
}
const Zo = () => g.useContext(Wt);
function pt(e) {
  return N(e.target) && e.target.tagName === "BUTTON";
}
function Jo(e) {
  return N(e.target) && e.target.tagName === "A";
}
function mt(e) {
  return Un(e);
}
function Qo(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: o,
    dataRef: r,
    elements: {
      domReference: i
    }
  } = e, {
    enabled: s = !0,
    event: c = "click",
    toggle: a = !0,
    ignoreMouse: l = !1,
    keyboardHandlers: u = !0,
    stickIfOpen: f = !0
  } = t, m = g.useRef(), d = g.useRef(!1), v = g.useMemo(() => ({
    onPointerDown(p) {
      m.current = p.pointerType;
    },
    onMouseDown(p) {
      const b = m.current;
      p.button === 0 && c !== "click" && (et(b) && l || (n && a && (!(r.current.openEvent && f) || r.current.openEvent.type === "mousedown") ? o(!1, p.nativeEvent, "click") : (p.preventDefault(), o(!0, p.nativeEvent, "click"))));
    },
    onClick(p) {
      const b = m.current;
      if (c === "mousedown" && m.current) {
        m.current = void 0;
        return;
      }
      et(b) && l || (n && a && (!(r.current.openEvent && f) || r.current.openEvent.type === "click") ? o(!1, p.nativeEvent, "click") : o(!0, p.nativeEvent, "click"));
    },
    onKeyDown(p) {
      m.current = void 0, !(p.defaultPrevented || !u || pt(p)) && (p.key === " " && !mt(i) && (p.preventDefault(), d.current = !0), !Jo(p) && p.key === "Enter" && o(!(n && a), p.nativeEvent, "click"));
    },
    onKeyUp(p) {
      p.defaultPrevented || !u || pt(p) || mt(i) || p.key === " " && d.current && (d.current = !1, o(!(n && a), p.nativeEvent, "click"));
    }
  }), [r, i, c, l, u, o, n, f, a]);
  return g.useMemo(() => s ? {
    reference: v
  } : {}, [s, v]);
}
const er = {
  pointerdown: "onPointerDown",
  mousedown: "onMouseDown",
  click: "onClick"
}, tr = {
  pointerdown: "onPointerDownCapture",
  mousedown: "onMouseDownCapture",
  click: "onClickCapture"
}, gt = (e) => {
  var t, n;
  return {
    escapeKey: typeof e == "boolean" ? e : (t = e == null ? void 0 : e.escapeKey) != null ? t : !1,
    outsidePress: typeof e == "boolean" ? e : (n = e == null ? void 0 : e.outsidePress) != null ? n : !0
  };
};
function nr(e, t) {
  t === void 0 && (t = {});
  const {
    open: n,
    onOpenChange: o,
    elements: r,
    dataRef: i
  } = e, {
    enabled: s = !0,
    escapeKey: c = !0,
    outsidePress: a = !0,
    outsidePressEvent: l = "pointerdown",
    referencePress: u = !1,
    referencePressEvent: f = "pointerdown",
    ancestorScroll: m = !1,
    bubbles: d,
    capture: v
  } = t, p = Vt(), b = ne(typeof a == "function" ? a : () => !1), h = typeof a == "function" ? b : a, w = g.useRef(!1), {
    escapeKey: x,
    outsidePress: E
  } = gt(d), {
    escapeKey: C,
    outsidePress: T
  } = gt(v), M = g.useRef(!1), k = ne((R) => {
    var L;
    if (!n || !s || !c || R.key !== "Escape" || M.current)
      return;
    const O = (L = i.current.floatingContext) == null ? void 0 : L.nodeId, P = p ? fe(p.nodesRef.current, O) : [];
    if (!x && (R.stopPropagation(), P.length > 0)) {
      let y = !0;
      if (P.forEach((A) => {
        var I;
        if ((I = A.context) != null && I.open && !A.context.dataRef.current.__escapeKeyBubbles) {
          y = !1;
          return;
        }
      }), !y)
        return;
    }
    o(!1, Xn(R) ? R.nativeEvent : R, "escape-key");
  }), B = ne((R) => {
    var L;
    const O = () => {
      var P;
      k(R), (P = se(R)) == null || P.removeEventListener("keydown", O);
    };
    (L = se(R)) == null || L.addEventListener("keydown", O);
  }), S = ne((R) => {
    var L;
    const O = i.current.insideReactTree;
    i.current.insideReactTree = !1;
    const P = w.current;
    if (w.current = !1, l === "click" && P || O || typeof h == "function" && !h(R))
      return;
    const y = se(R), A = "[" + je("inert") + "]", I = ae(r.floating).querySelectorAll(A);
    let z = D(y) ? y : null;
    for (; z && !U(z); ) {
      const F = Y(z);
      if (U(F) || !D(F))
        break;
      z = F;
    }
    if (I.length && D(y) && !qn(y) && // Clicked on a direct ancestor (e.g. FloatingOverlay).
    !$e(y, r.floating) && // If the target root element contains none of the markers, then the
    // element was injected after the floating element rendered.
    Array.from(I).every((F) => !$e(z, F)))
      return;
    if (N(y) && V) {
      const F = U(y), q = W(y), ie = /auto|scroll/, Ut = F || ie.test(q.overflowX), Yt = F || ie.test(q.overflowY), Xt = Ut && y.clientWidth > 0 && y.scrollWidth > y.clientWidth, zt = Yt && y.clientHeight > 0 && y.scrollHeight > y.clientHeight, Gt = q.direction === "rtl", Zt = zt && (Gt ? R.offsetX <= y.offsetWidth - y.clientWidth : R.offsetX > y.clientWidth), Jt = Xt && R.offsetY > y.clientHeight;
      if (Zt || Jt)
        return;
    }
    const Ue = (L = i.current.floatingContext) == null ? void 0 : L.nodeId, qt = p && fe(p.nodesRef.current, Ue).some((F) => {
      var q;
      return Ae(R, (q = F.context) == null ? void 0 : q.elements.floating);
    });
    if (Ae(R, r.floating) || Ae(R, r.domReference) || qt)
      return;
    const Ye = p ? fe(p.nodesRef.current, Ue) : [];
    if (Ye.length > 0) {
      let F = !0;
      if (Ye.forEach((q) => {
        var ie;
        if ((ie = q.context) != null && ie.open && !q.context.dataRef.current.__outsidePressBubbles) {
          F = !1;
          return;
        }
      }), !F)
        return;
    }
    o(!1, R, "outside-press");
  }), _ = ne((R) => {
    var L;
    const O = () => {
      var P;
      S(R), (P = se(R)) == null || P.removeEventListener(l, O);
    };
    (L = se(R)) == null || L.addEventListener(l, O);
  });
  g.useEffect(() => {
    if (!n || !s)
      return;
    i.current.__escapeKeyBubbles = x, i.current.__outsidePressBubbles = E;
    let R = -1;
    function L(I) {
      o(!1, I, "ancestor-scroll");
    }
    function O() {
      window.clearTimeout(R), M.current = !0;
    }
    function P() {
      R = window.setTimeout(
        () => {
          M.current = !1;
        },
        // 0ms or 1ms don't work in Safari. 5ms appears to consistently work.
        // Only apply to WebKit for the test to remain 0ms.
        Re() ? 5 : 0
      );
    }
    const y = ae(r.floating);
    c && (y.addEventListener("keydown", C ? B : k, C), y.addEventListener("compositionstart", O), y.addEventListener("compositionend", P)), h && y.addEventListener(l, T ? _ : S, T);
    let A = [];
    return m && (D(r.domReference) && (A = Z(r.domReference)), D(r.floating) && (A = A.concat(Z(r.floating))), !D(r.reference) && r.reference && r.reference.contextElement && (A = A.concat(Z(r.reference.contextElement)))), A = A.filter((I) => {
      var z;
      return I !== ((z = y.defaultView) == null ? void 0 : z.visualViewport);
    }), A.forEach((I) => {
      I.addEventListener("scroll", L, {
        passive: !0
      });
    }), () => {
      c && (y.removeEventListener("keydown", C ? B : k, C), y.removeEventListener("compositionstart", O), y.removeEventListener("compositionend", P)), h && y.removeEventListener(l, T ? _ : S, T), A.forEach((I) => {
        I.removeEventListener("scroll", L);
      }), window.clearTimeout(R);
    };
  }, [i, r, c, h, l, n, o, m, s, x, E, k, C, B, S, T, _]), g.useEffect(() => {
    i.current.insideReactTree = !1;
  }, [i, h, l]);
  const X = g.useMemo(() => ({
    onKeyDown: k,
    ...u && {
      [er[f]]: (R) => {
        o(!1, R.nativeEvent, "reference-press");
      },
      ...f !== "click" && {
        onClick(R) {
          o(!1, R.nativeEvent, "reference-press");
        }
      }
    }
  }), [k, o, u, f]), V = g.useMemo(() => ({
    onKeyDown: k,
    onMouseDown() {
      w.current = !0;
    },
    onMouseUp() {
      w.current = !0;
    },
    [tr[l]]: () => {
      i.current.insideReactTree = !0;
    }
  }), [k, l, i]);
  return g.useMemo(() => s ? {
    reference: X,
    floating: V
  } : {}, [s, X, V]);
}
function or(e) {
  const {
    open: t = !1,
    onOpenChange: n,
    elements: o
  } = e, r = Ke(), i = g.useRef({}), [s] = g.useState(() => jo()), c = _t() != null;
  if (process.env.NODE_ENV !== "production") {
    const d = o.reference;
    d && !D(d) && Ko("Cannot pass a virtual element to the `elements.reference` option,", "as it must be a real DOM element. Use `refs.setPositionReference()`", "instead.");
  }
  const [a, l] = g.useState(o.reference), u = ne((d, v, p) => {
    i.current.openEvent = d ? v : void 0, s.emit("openchange", {
      open: d,
      event: v,
      reason: p,
      nested: c
    }), n == null || n(d, v, p);
  }), f = g.useMemo(() => ({
    setPositionReference: l
  }), []), m = g.useMemo(() => ({
    reference: a || o.reference || null,
    floating: o.floating || null,
    domReference: o.reference
  }), [a, o.reference, o.floating]);
  return g.useMemo(() => ({
    dataRef: i,
    open: t,
    onOpenChange: u,
    elements: m,
    events: s,
    floatingId: r,
    refs: f
  }), [t, u, m, s, r, f]);
}
function rr(e) {
  e === void 0 && (e = {});
  const {
    nodeId: t
  } = e, n = or({
    ...e,
    elements: {
      reference: null,
      floating: null,
      ...e.elements
    }
  }), o = e.rootContext || n, r = o.elements, [i, s] = g.useState(null), [c, a] = g.useState(null), u = (r == null ? void 0 : r.domReference) || i, f = g.useRef(null), m = Vt();
  Q(() => {
    u && (f.current = u);
  }, [u]);
  const d = ko({
    ...e,
    elements: {
      ...r,
      ...c && {
        reference: c
      }
    }
  }), v = g.useCallback((x) => {
    const E = D(x) ? {
      getBoundingClientRect: () => x.getBoundingClientRect(),
      getClientRects: () => x.getClientRects(),
      contextElement: x
    } : x;
    a(E), d.refs.setReference(E);
  }, [d.refs]), p = g.useCallback((x) => {
    (D(x) || x === null) && (f.current = x, s(x)), (D(d.refs.reference.current) || d.refs.reference.current === null || // Don't allow setting virtual elements using the old technique back to
    // `null` to support `positionReference` + an unstable `reference`
    // callback ref.
    x !== null && !D(x)) && d.refs.setReference(x);
  }, [d.refs]), b = g.useMemo(() => ({
    ...d.refs,
    setReference: p,
    setPositionReference: v,
    domReference: f
  }), [d.refs, p, v]), h = g.useMemo(() => ({
    ...d.elements,
    domReference: u
  }), [d.elements, u]), w = g.useMemo(() => ({
    ...d,
    ...o,
    refs: b,
    elements: h,
    nodeId: t
  }), [d, b, h, t, o]);
  return Q(() => {
    o.dataRef.current.floatingContext = w;
    const x = m == null ? void 0 : m.nodesRef.current.find((E) => E.id === t);
    x && (x.context = w);
  }), g.useMemo(() => ({
    ...d,
    context: w,
    refs: b,
    elements: h
  }), [d, b, h, w]);
}
function De(e, t, n) {
  const o = /* @__PURE__ */ new Map(), r = n === "item";
  let i = e;
  if (r && e) {
    const {
      [ct]: s,
      [at]: c,
      ...a
    } = e;
    i = a;
  }
  return {
    ...n === "floating" && {
      tabIndex: -1,
      [Bo]: ""
    },
    ...i,
    ...t.map((s) => {
      const c = s ? s[n] : null;
      return typeof c == "function" ? e ? c(e) : null : c;
    }).concat(e).reduce((s, c) => (c && Object.entries(c).forEach((a) => {
      let [l, u] = a;
      if (!(r && [ct, at].includes(l)))
        if (l.indexOf("on") === 0) {
          if (o.has(l) || o.set(l, []), typeof u == "function") {
            var f;
            (f = o.get(l)) == null || f.push(u), s[l] = function() {
              for (var m, d = arguments.length, v = new Array(d), p = 0; p < d; p++)
                v[p] = arguments[p];
              return (m = o.get(l)) == null ? void 0 : m.map((b) => b(...v)).find((b) => b !== void 0);
            };
          }
        } else
          s[l] = u;
    }), s), {})
  };
}
function ir(e) {
  e === void 0 && (e = []);
  const t = e.map((c) => c == null ? void 0 : c.reference), n = e.map((c) => c == null ? void 0 : c.floating), o = e.map((c) => c == null ? void 0 : c.item), r = g.useCallback(
    (c) => De(c, e, "reference"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    t
  ), i = g.useCallback(
    (c) => De(c, e, "floating"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    n
  ), s = g.useCallback(
    (c) => De(c, e, "item"),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    o
  );
  return g.useMemo(() => ({
    getReferenceProps: r,
    getFloatingProps: i,
    getItemProps: s
  }), [r, i, s]);
}
const sr = /* @__PURE__ */ new Map([["select", "listbox"], ["combobox", "listbox"], ["label", !1]]);
function cr(e, t) {
  var n, o;
  t === void 0 && (t = {});
  const {
    open: r,
    elements: i,
    floatingId: s
  } = e, {
    enabled: c = !0,
    role: a = "dialog"
  } = t, l = Ke(), u = ((n = i.domReference) == null ? void 0 : n.id) || l, f = g.useMemo(() => {
    var w;
    return ((w = Yn(i.floating)) == null ? void 0 : w.id) || s;
  }, [i.floating, s]), m = (o = sr.get(a)) != null ? o : a, v = _t() != null, p = g.useMemo(() => m === "tooltip" || a === "label" ? {
    ["aria-" + (a === "label" ? "labelledby" : "describedby")]: r ? f : void 0
  } : {
    "aria-expanded": r ? "true" : "false",
    "aria-haspopup": m === "alertdialog" ? "dialog" : m,
    "aria-controls": r ? f : void 0,
    ...m === "listbox" && {
      role: "combobox"
    },
    ...m === "menu" && {
      id: u
    },
    ...m === "menu" && v && {
      role: "menuitem"
    },
    ...a === "select" && {
      "aria-autocomplete": "none"
    },
    ...a === "combobox" && {
      "aria-autocomplete": "list"
    }
  }, [m, f, v, r, u, a]), b = g.useMemo(() => {
    const w = {
      id: f,
      ...m && {
        role: m
      }
    };
    return m === "tooltip" || a === "label" ? w : {
      ...w,
      ...m === "menu" && {
        "aria-labelledby": u
      }
    };
  }, [m, f, u, a]), h = g.useCallback((w) => {
    let {
      active: x,
      selected: E
    } = w;
    const C = {
      role: "option",
      ...x && {
        id: f + "-fui-option"
      }
    };
    switch (a) {
      case "select":
      case "combobox":
        return {
          ...C,
          "aria-selected": E
        };
    }
    return {};
  }, [f, a]);
  return g.useMemo(() => c ? {
    reference: p,
    floating: b,
    item: h
  } : {}, [c, p, b, h]);
}
function Ht(e) {
  var t, n, o = "";
  if (typeof e == "string" || typeof e == "number") o += e;
  else if (typeof e == "object") if (Array.isArray(e)) {
    var r = e.length;
    for (t = 0; t < r; t++) e[t] && (n = Ht(e[t])) && (o && (o += " "), o += n);
  } else for (n in e) e[n] && (o && (o += " "), o += n);
  return o;
}
function ar() {
  for (var e, t, n = 0, o = "", r = arguments.length; n < r; n++) (e = arguments[n]) && (t = Ht(e)) && (o && (o += " "), o += t);
  return o;
}
const qe = ({
  as: e,
  children: t,
  display: n,
  m: o,
  mt: r,
  mr: i,
  mb: s,
  ml: c,
  mx: a,
  my: l,
  p: u,
  pt: f,
  pr: m,
  pb: d,
  pl: v,
  px: p,
  py: b,
  width: h,
  height: w,
  position: x,
  style: E,
  className: C,
  disabled: T,
  required: M,
  ...k
}) => {
  const B = e || "div", S = {};
  n && (S.display = n), h && (S.width = h), w && (S.height = w), x && (S.position = x), o && (S.margin = `var(--pittorica-space-${o})`), r && (S.marginTop = `var(--pittorica-space-${r})`), i && (S.marginRight = `var(--pittorica-space-${i})`), s && (S.marginBottom = `var(--pittorica-space-${s})`), c && (S.marginLeft = `var(--pittorica-space-${c})`), a && (S.marginLeft = `var(--pittorica-space-${a})`, S.marginRight = `var(--pittorica-space-${a})`), l && (S.marginTop = `var(--pittorica-space-${l})`, S.marginBottom = `var(--pittorica-space-${l})`), u && (S.padding = `var(--pittorica-space-${u})`), f && (S.paddingTop = `var(--pittorica-space-${f})`), m && (S.paddingRight = `var(--pittorica-space-${m})`), d && (S.paddingBottom = `var(--pittorica-space-${d})`), v && (S.paddingLeft = `var(--pittorica-space-${v})`), p && (S.paddingLeft = `var(--pittorica-space-${p})`, S.paddingRight = `var(--pittorica-space-${p})`), b && (S.paddingTop = `var(--pittorica-space-${b})`, S.paddingBottom = `var(--pittorica-space-${b})`);
  const _ = {
    ...E,
    ...S
  };
  return /* @__PURE__ */ H(
    B,
    {
      className: ar("pittorica-box", C),
      style: _,
      disabled: T,
      required: M,
      ...k,
      children: t
    }
  );
};
qe.displayName = "Box";
const lr = ({
  children: e,
  sourceColor: t = "indigo",
  appearance: n = "light",
  radius: o = "medium",
  className: r,
  style: i,
  id: s
}) => {
  const c = t.startsWith("#") || t.startsWith("rgb"), a = {
    id: s,
    className: ["pittorica-theme", r].filter(Boolean).join(" "),
    "data-source-color": c ? "custom" : t,
    "data-appearance": n,
    "data-radius": o,
    style: {
      ...i,
      ...c ? { "--pittorica-source-color": t } : {}
    }
  };
  return /* @__PURE__ */ H("div", { ...a, children: e });
}, Kt = en(null), jt = () => {
  const e = nn(Kt);
  if (!e)
    throw new Error("Popover components must be wrapped in <Popover.Root />");
  return e;
}, ht = ({
  children: e,
  placement: t = "bottom",
  appearance: n
}) => {
  const [o, r] = vt(!1), { refs: i, floatingStyles: s, context: c } = rr({
    open: o,
    onOpenChange: r,
    placement: t,
    whileElementsMounted: Ao,
    middleware: [No(8), $o(), Fo({ padding: 5 })]
  }), a = Qo(c), l = nr(c), u = cr(c), { getReferenceProps: f, getFloatingProps: m } = ir([
    a,
    l,
    u
  ]), d = tn(
    () => ({
      isOpen: o,
      setIsOpen: r,
      refs: i,
      floatingStyles: s,
      getReferenceProps: f,
      getFloatingProps: m,
      appearance: n
    }),
    [
      o,
      i,
      s,
      f,
      m,
      n
    ]
  );
  return /* @__PURE__ */ H(Kt, { value: d, children: e });
}, ur = ({
  children: e,
  as: t,
  ref: n,
  ...o
}) => {
  const { refs: r, getReferenceProps: i } = jt(), s = (a) => {
    r.setReference(a), n && (typeof n == "function" ? n(a) : typeof n == "object" && (n.current = a));
  };
  return /* @__PURE__ */ H(
    qe,
    {
      as: t || "span",
      display: "inline-flex",
      ...i(o),
      ref: s,
      children: e
    }
  );
}, fr = ({
  children: e,
  className: t,
  as: n,
  ref: o,
  style: r,
  ...i
}) => {
  const { isOpen: s, refs: c, floatingStyles: a, getFloatingProps: l, appearance: u } = jt(), [f, m] = vt();
  (globalThis.window === void 0 ? on : _e)(() => {
    if (s && c.domReference.current) {
      const h = c.domReference.current.closest(
        ".pittorica-theme"
      );
      if (h) {
        const w = h.dataset.appearance;
        m(w || void 0);
      }
    }
  }, [s, c.domReference]);
  const v = (h) => {
    c.setFloating(h), o && (typeof o == "function" ? o(h) : typeof o == "object" && (o.current = h));
  };
  return s ? /* @__PURE__ */ H(Go, { children: /* @__PURE__ */ H(lr, { appearance: u === "inherit" ? f : u ?? f, children: /* @__PURE__ */ H(
    qe,
    {
      as: n || "div",
      ...l(i),
      ref: v,
      className: rn("pittorica-popover-content", t),
      style: { ...a, ...r },
      children: e
    }
  ) }) }) : null;
}, mr = Object.assign(ht, {
  Root: ht,
  Trigger: ur,
  Content: fr
});
export {
  mr as Popover,
  fr as PopoverContent,
  ht as PopoverRoot,
  ur as PopoverTrigger
};
