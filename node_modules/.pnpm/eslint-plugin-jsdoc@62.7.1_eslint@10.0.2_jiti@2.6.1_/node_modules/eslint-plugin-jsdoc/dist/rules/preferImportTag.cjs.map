{"version":3,"file":"preferImportTag.cjs","names":["_iterateJsdoc","_interopRequireWildcard","require","_jsdoccomment","_eslint","_parseImportsExports","_semver","_interopRequireDefault","_toValidIdentifier","e","__esModule","default","t","WeakMap","r","n","o","i","f","__proto__","has","get","set","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","_default","exports","iterateJsdoc","context","indent","jsdoc","settings","sourceCode","utils","mode","enableFixer","exemptTypedefs","outputType","options","allComments","getAllComments","comments","filter","comment","test","value","map","commentNode","commentParserToESTree","parseComment","typedefs","flatMap","doc","tags","tag","isNameOrNamepathDefiningTag","imports","delimiter","createImportInserter","importText","fixer","programNode","ast","commentNodes","getCommentsBefore","insertTextBefore","semver","lt","Linter","version","sourceText","getText","hasCode","body","length","leadingMatch","match","leading","replaceTextRange","slice","startsWithNewline","iterateInlineImports","potentialType","type","parsedType","tryParseType","parseType","traverse","nde","parentNode","element","currentNode","pathSegments","nodes","extraPathSegments","quotes","propertyOrBrackets","unshift","right","stringify","pathType","undefined","meta","quote","getFixer","name","extrPathSegments","matchingName","toValidIdentifier","node","at","keys","key","newNode","shift","left","nameNode","src","source","tokens","unusedPathSegments","findMatchingTypedef","pthSegments","find","typedef","typedefNode","namepathMatch","pathSegment","push","matchingTypedef","reportJSDoc","findMatchingImport","imprt","parsedImport","parseImportsExports","estreeToString","replace","trim","namedImportsModuleSpecifier","namedImports","values","namedImportNames","names","namespaceImports","namespaceImportsDefault","namespaceImportsNamespace","namespace","namespaceImportsModuleSpecifier","lastPathSegment","includes","matchingImport","lastPthSegment","lstPathSegment","mightHaveTypePosition","tagMightHaveTypePosition","hasTypePosition","Boolean","iterateAllJsdocs","docs","description","url","fixable","schema","additionalProperties","properties","enum","module"],"sources":["../../src/rules/preferImportTag.js"],"sourcesContent":["import iterateJsdoc, {\n  parseComment,\n} from '../iterateJsdoc.js';\nimport {\n  commentParserToESTree,\n  estreeToString,\n  // getJSDocComment,\n  parse as parseType,\n  stringify,\n  traverse,\n  tryParse as tryParseType,\n} from '@es-joy/jsdoccomment';\nimport {\n  Linter,\n} from 'eslint';\nimport {\n  parseImportsExports,\n} from 'parse-imports-exports';\nimport semver from 'semver';\nimport toValidIdentifier from 'to-valid-identifier';\n\nexport default iterateJsdoc(({\n  context,\n  indent,\n  jsdoc,\n  settings,\n  sourceCode,\n  utils,\n}) => {\n  const {\n    mode,\n  } = settings;\n\n  const {\n    enableFixer = true,\n    exemptTypedefs = true,\n    outputType = 'namespaced-import',\n  } = context.options[0] || {};\n\n  const allComments = sourceCode.getAllComments();\n  const comments = allComments\n    .filter((comment) => {\n      return (/^\\*(?!\\*)/v).test(comment.value);\n    })\n    .map((commentNode) => {\n      return commentParserToESTree(\n        parseComment(commentNode, ''), mode === 'permissive' ? 'typescript' : mode,\n      );\n    });\n\n  const typedefs = comments\n    .flatMap((doc) => {\n      return doc.tags.filter(({\n        tag,\n      }) => {\n        return utils.isNameOrNamepathDefiningTag(tag);\n      });\n    });\n\n  const imports = comments\n    .flatMap((doc) => {\n      return doc.tags.filter(({\n        tag,\n      }) => {\n        return tag === 'import';\n      });\n    }).map((tag) => {\n      // Causes problems with stringification otherwise\n      tag.delimiter = '';\n      return tag;\n    });\n\n  /**\n   * Helper to insert an import statement at the top of the file.\n   * @param {string} importText - The import statement text (without newline)\n   * @returns {((fixer: import('eslint').Rule.RuleFixer) => import('eslint').Rule.Fix|void)} - Fixer function for ESLint\n   */\n  const createImportInserter = (importText) => {\n    return (fixer) => {\n      const programNode = sourceCode.ast;\n      const commentNodes = sourceCode.getCommentsBefore(programNode);\n\n      /* c8 ignore start -- ESLint < 10 */\n      if (commentNodes[0]) {\n        return fixer.insertTextBefore(\n          // @ts-expect-error - Comment is compatible with Node in practice\n          commentNodes[0],\n          `${importText}\\n${indent}`,\n        );\n      }\n\n      // For ESLint < 10, use the simple approach of inserting before programNode\n      if (semver.lt(Linter.version, '10.0.0')) {\n        return fixer.insertTextBefore(\n          programNode,\n          importText,\n        );\n      }\n\n      // For ESLint 10+, handle the changed Program node range\n      const sourceText = sourceCode.getText();\n      const hasCode = programNode.body && programNode.body.length > 0;\n      const leadingMatch = hasCode ? sourceText.match(/^(\\n[ \\t]*)/v) : null;\n      if (leadingMatch) {\n        const leading = leadingMatch[1];\n        return fixer.replaceTextRange(\n          [\n            leading.length, leading.length,\n          ],\n          `${importText}\\n${leading.slice(1)}`,\n        );\n      }\n\n      const startsWithNewline = sourceText[0] === '\\n';\n      return fixer.replaceTextRange(\n        startsWithNewline ? [\n          0, 1,\n        ] : [\n          0, 0,\n        ],\n        `${importText}\\n`,\n      );\n      /* c8 ignore end -- ESLint < 10 */\n    };\n  };\n\n  /**\n   * @param {import('@es-joy/jsdoccomment').JsdocTagWithInline} tag\n   */\n  const iterateInlineImports = (tag) => {\n    const potentialType = tag.type;\n    let parsedType;\n    try {\n      parsedType = mode === 'permissive' ?\n        tryParseType(/** @type {string} */ (potentialType)) :\n        parseType(/** @type {string} */ (potentialType), mode);\n    } catch {\n      return;\n    }\n\n    traverse(parsedType, (nde, parentNode) => {\n      // @ts-expect-error Adding our own property for use below\n      nde.parentNode = parentNode;\n    });\n\n    traverse(parsedType, (nde) => {\n      const {\n        element,\n        type,\n      } = /** @type {import('jsdoc-type-pratt-parser').ImportResult} */ (nde);\n      if (type !== 'JsdocTypeImport') {\n        return;\n      }\n\n      let currentNode = nde;\n\n      /** @type {string[]} */\n      const pathSegments = [];\n\n      /** @type {import('jsdoc-type-pratt-parser').NamePathResult[]} */\n      const nodes = [];\n\n      /** @type {string[]} */\n      const extraPathSegments = [];\n\n      /** @type {(import('jsdoc-type-pratt-parser').QuoteStyle|undefined)[]} */\n      const quotes = [];\n\n      const propertyOrBrackets = /** @type {import('jsdoc-type-pratt-parser').NamePathResult['pathType'][]} */ ([]);\n\n      // @ts-expect-error Referencing our own property added above\n      while (currentNode && currentNode.parentNode) {\n        // @ts-expect-error Referencing our own property added above\n        currentNode = currentNode.parentNode;\n        /* c8 ignore next 3 -- Guard */\n        if (currentNode.type !== 'JsdocTypeNamePath') {\n          break;\n        }\n\n        pathSegments.unshift(\n          currentNode.right.type === 'JsdocTypeIndexedAccessIndex' ?\n            stringify(currentNode.right.right) :\n            currentNode.right.value,\n        );\n        nodes.unshift(currentNode);\n        propertyOrBrackets.unshift(currentNode.pathType);\n        quotes.unshift(\n          currentNode.right.type === 'JsdocTypeIndexedAccessIndex' ?\n            undefined :\n            currentNode.right.meta.quote,\n        );\n      }\n\n      /**\n       * @param {string} name\n       * @param {string[]} extrPathSegments\n       */\n      const getFixer = (name, extrPathSegments) => {\n        const matchingName = toValidIdentifier(name);\n        return () => {\n          /** @type {import('jsdoc-type-pratt-parser').NamePathResult|undefined} */\n          let node = nodes.at(0);\n          if (!node) {\n            // Not really a NamePathResult, but will be converted later anyways\n            node = /** @type {import('jsdoc-type-pratt-parser').NamePathResult} */ (\n              /** @type {unknown} */\n              (nde)\n            );\n          }\n\n          const keys = /** @type {(keyof import('jsdoc-type-pratt-parser').NamePathResult)[]} */ (\n            Object.keys(node)\n          );\n\n          for (const key of keys) {\n            delete node[key];\n          }\n\n          if (extrPathSegments.length) {\n            let newNode = /** @type {import('jsdoc-type-pratt-parser').NamePathResult} */ (\n              /** @type {unknown} */\n              (node)\n            );\n            while (extrPathSegments.length && newNode) {\n              newNode.type = 'JsdocTypeNamePath';\n              newNode.right = {\n                meta: {\n                  quote: quotes.shift(),\n                },\n                type: 'JsdocTypeProperty',\n                value: /** @type {string} */ (extrPathSegments.shift()),\n              };\n\n              newNode.pathType = /** @type {import('jsdoc-type-pratt-parser').NamePathResult['pathType']} */ (\n                propertyOrBrackets.shift()\n              );\n              // @ts-expect-error Temporary\n              newNode.left = {};\n              newNode = /** @type {import('jsdoc-type-pratt-parser').NamePathResult} */ (\n                newNode.left\n              );\n            }\n\n            const nameNode = /** @type {import('jsdoc-type-pratt-parser').NameResult} */ (\n              /** @type {unknown} */\n              (newNode)\n            );\n            nameNode.type = 'JsdocTypeName';\n            nameNode.value = matchingName;\n          } else {\n            const newNode = /** @type {import('jsdoc-type-pratt-parser').NameResult} */ (\n              /** @type {unknown} */\n              (node)\n            );\n            newNode.type = 'JsdocTypeName';\n            newNode.value = matchingName;\n          }\n\n          for (const src of tag.source) {\n            if (src.tokens.type) {\n              src.tokens.type = `{${stringify(parsedType)}}`;\n              break;\n            }\n          }\n        };\n      };\n\n      /** @type {string[]} */\n      let unusedPathSegments = [];\n\n      const findMatchingTypedef = () => {\n        // Don't want typedefs to find themselves\n        if (!exemptTypedefs) {\n          return undefined;\n        }\n\n        const pthSegments = [\n          ...pathSegments,\n        ];\n        return typedefs.find((typedef) => {\n          let typedefNode = typedef.parsedType;\n          let namepathMatch;\n          while (typedefNode && typedefNode.type === 'JsdocTypeNamePath') {\n            const pathSegment = pthSegments.shift();\n            if (!pathSegment) {\n              namepathMatch = false;\n              break;\n            }\n\n            if (\n              (typedefNode.right.type === 'JsdocTypeIndexedAccessIndex' &&\n                stringify(typedefNode.right.right) !== pathSegment) ||\n              (typedefNode.right.type !== 'JsdocTypeIndexedAccessIndex' &&\n                typedefNode.right.value !== pathSegment)\n            ) {\n              if (namepathMatch === true) {\n                // It stopped matching, so stop\n                break;\n              }\n\n              extraPathSegments.push(pathSegment);\n              namepathMatch = false;\n              continue;\n            }\n\n            namepathMatch = true;\n\n            unusedPathSegments = pthSegments;\n\n            typedefNode = typedefNode.left;\n          }\n\n          return namepathMatch &&\n            // `import('eslint')` matches\n            typedefNode &&\n            typedefNode.type === 'JsdocTypeImport' &&\n            typedefNode.element.value === element.value;\n        });\n      };\n\n      // Check @typedef's first as should be longest match, allowing\n      //   for shorter abbreviations\n      const matchingTypedef = findMatchingTypedef();\n      if (matchingTypedef) {\n        utils.reportJSDoc(\n          'Inline `import()` found; using `@typedef`',\n          tag,\n          enableFixer ? getFixer(matchingTypedef.name, [\n            ...extraPathSegments,\n            ...unusedPathSegments.slice(-1),\n            ...unusedPathSegments.slice(0, -1),\n          ]) : null,\n        );\n        return;\n      }\n\n      const findMatchingImport = () => {\n        for (const imprt of imports) {\n          const parsedImport = parseImportsExports(\n            estreeToString(imprt).replace(/^\\s*@/v, '').trim(),\n          );\n\n          const namedImportsModuleSpecifier = Object.keys(parsedImport.namedImports || {})[0];\n\n          const namedImports = Object.values(parsedImport.namedImports || {})[0]?.[0];\n          const namedImportNames = (namedImports && namedImports.names && Object.keys(namedImports.names)) ?? [];\n\n          const namespaceImports = Object.values(parsedImport.namespaceImports || {})[0]?.[0];\n\n          const namespaceImportsDefault = namespaceImports && namespaceImports.default;\n          const namespaceImportsNamespace = namespaceImports && namespaceImports.namespace;\n          const namespaceImportsModuleSpecifier = Object.keys(parsedImport.namespaceImports || {})[0];\n\n          const lastPathSegment = pathSegments.at(-1);\n\n          if (\n            (namespaceImportsDefault &&\n                namespaceImportsModuleSpecifier === element.value) ||\n              (element.value === namedImportsModuleSpecifier && (\n                (lastPathSegment && namedImportNames.includes(lastPathSegment)) ||\n                lastPathSegment === 'default'\n              )) ||\n              (namespaceImportsNamespace &&\n                namespaceImportsModuleSpecifier === element.value)\n          ) {\n            return {\n              namedImportNames,\n              namedImports,\n              namedImportsModuleSpecifier,\n              namespaceImports,\n              namespaceImportsDefault,\n              namespaceImportsModuleSpecifier,\n              namespaceImportsNamespace,\n            };\n          }\n        }\n\n        return undefined;\n      };\n\n      const matchingImport = findMatchingImport();\n      if (matchingImport) {\n        const {\n          namedImportNames,\n          namedImports,\n          namedImportsModuleSpecifier,\n          namespaceImportsNamespace,\n        } = matchingImport;\n        if (!namedImportNames.length && namedImportsModuleSpecifier && namedImports.default) {\n          utils.reportJSDoc(\n            'Inline `import()` found; prefer `@import`',\n            tag,\n            enableFixer ? getFixer(namedImports.default, []) : null,\n          );\n          return;\n        }\n\n        const lastPthSegment = pathSegments.at(-1);\n        if (lastPthSegment && namedImportNames.includes(lastPthSegment)) {\n          utils.reportJSDoc(\n            'Inline `import()` found; prefer `@import`',\n            tag,\n            enableFixer ? getFixer(lastPthSegment, pathSegments.slice(0, -1)) : null,\n          );\n          return;\n        }\n\n        if (namespaceImportsNamespace) {\n          utils.reportJSDoc(\n            'Inline `import()` found; prefer `@import`',\n            tag,\n            enableFixer ? getFixer(namespaceImportsNamespace, [\n              ...pathSegments,\n            ]) : null,\n          );\n          return;\n        }\n      }\n\n      if (!pathSegments.length) {\n        utils.reportJSDoc(\n          'Inline `import()` found; prefer `@import`',\n          tag,\n          enableFixer ? (fixer) => {\n            getFixer(element.value, [])();\n            return createImportInserter(\n              `/** @import * as ${toValidIdentifier(element.value)} from '${element.value}'; */`,\n            )(fixer);\n          } : null,\n        );\n        return;\n      }\n\n      const lstPathSegment = pathSegments.at(-1);\n      if (lstPathSegment && lstPathSegment === 'default') {\n        utils.reportJSDoc(\n          'Inline `import()` found; prefer `@import`',\n          tag,\n          enableFixer ? (fixer) => {\n            getFixer(element.value, [])();\n            return createImportInserter(\n              `/** @import ${element.value} from '${element.value}'; */`,\n            )(fixer);\n          } : null,\n        );\n        return;\n      }\n\n      utils.reportJSDoc(\n        'Inline `import()` found; prefer `@import`',\n        tag,\n        enableFixer ? (fixer) => {\n          if (outputType === 'namespaced-import') {\n            getFixer(element.value, [\n              ...pathSegments,\n            ])();\n          } else {\n            getFixer(\n              /** @type {string} */ (pathSegments.at(-1)),\n              pathSegments.slice(0, -1),\n            )();\n          }\n\n          const importText = outputType === 'namespaced-import' ?\n            `/** @import * as ${toValidIdentifier(element.value)} from '${element.value}'; */` :\n            `/** @import { ${toValidIdentifier(\n              /* c8 ignore next -- TS */\n              pathSegments.at(-1) ?? '',\n            )} } from '${element.value}'; */`;\n\n          return createImportInserter(importText)(fixer);\n        } : null,\n      );\n    });\n  };\n\n  for (const tag of jsdoc.tags) {\n    const mightHaveTypePosition = utils.tagMightHaveTypePosition(tag.tag);\n    const hasTypePosition = mightHaveTypePosition === true && Boolean(tag.type);\n    if (hasTypePosition && (!exemptTypedefs || !utils.isNameOrNamepathDefiningTag(tag.tag))) {\n      iterateInlineImports(tag);\n    }\n  }\n}, {\n  iterateAllJsdocs: true,\n  meta: {\n    docs: {\n      description: 'Prefer `@import` tags to inline `import()` statements.',\n      url: 'https://github.com/gajus/eslint-plugin-jsdoc/blob/main/docs/rules/prefer-import-tag.md#repos-sticky-header',\n    },\n    fixable: 'code',\n    schema: [\n      {\n        additionalProperties: false,\n        properties: {\n          enableFixer: {\n            description: 'Whether or not to enable the fixer to add `@import` tags.',\n            type: 'boolean',\n          },\n          exemptTypedefs: {\n            description: 'Whether to allow `import()` statements within `@typedef`',\n            type: 'boolean',\n          },\n\n          // We might add `typedef` and `typedef-local-only`, but also raises\n          //   question of how deep the generated typedef should be\n          outputType: {\n            description: 'What kind of `@import` to generate when no matching `@typedef` or `@import` is found',\n            enum: [\n              'named-import',\n              'namespaced-import',\n            ],\n            type: 'string',\n          },\n        },\n        type: 'object',\n      },\n    ],\n    type: 'suggestion',\n  },\n});\n"],"mappings":"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","ignoreList":[]}