import { BYTE_ORDER_MARK, DEFAULT_IGNORES, EM_SPACE, EN_SPACE, FORM_FEED, IDEOGRAPHIC_SPACE, INVISIBLE_SEPARATORS, LINE_SEPARATOR, NARROW_NO_BREAK_SPACE, NON_BREAKING_SPACE, PARAGRAPH_SEPARATOR, VERTICAL_TAB, VISIBLE_MISC_SPACES, VUOTO_IGNORE_FILENAME, ZERO_WIDTH } from "../consts.js";
import fs from "node:fs/promises";
import path from "node:path";
import process from "node:process";
import chalk from "chalk";
import fg from "fast-glob";

//#region src/actions/expand-patterns.ts
/**
* Expand given patterns into globs.
* @param patterns The patterns to expand.
* @returns The expanded globs.
* @example
* await expandPatterns(['src', '*.ts']); // ['*.ts']
*/
async function expandPatterns(patterns) {
	const expanded = [];
	for (const p of patterns) {
		if (/[*?[\\]{}()!+@]/.test(p)) {
			expanded.push(p);
			continue;
		}
		try {
			const abs = path.resolve(process.cwd(), p);
			if ((await fs.stat(abs)).isDirectory()) {
				const rel = path.relative(process.cwd(), abs) || ".";
				expanded.push(rel === "." ? "**/*" : `${rel.replaceAll("\\", "/")}/**/*`);
				continue;
			}
		} catch {}
		expanded.push(p);
	}
	return expanded;
}

//#endregion
//#region src/helpers/read-gitignore-file.ts
/**
* Read .gitignore file in a directory, if present.
* @param dir The directory to read the .gitignore file from.
*
* @returns The patterns from the .gitignore file.
*
* @example
*
* ```ts
* const patterns = await readGitignoreFile(process.cwd());
* ```
*/
async function readGitignoreFile(dir) {
	const gitignorePath = path.join(dir, ".gitignore");
	try {
		return (await fs.readFile(gitignorePath, "utf8")).split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
	} catch {
		return [];
	}
}

//#endregion
//#region src/helpers/collect-gitignores.ts
/**
* Collect .gitignore patterns recursively from cwd and all subfolders.
* @param cwd The current working directory.
*
* @returns The collected .gitignore patterns.
*
* @example
*
* ```ts
* const patterns = await collectGitignores(process.cwd());
* ```
*/
async function collectGitignores(cwd) {
	const gitignoreFiles = await fg("**/.gitignore", {
		cwd,
		absolute: true,
		dot: true
	});
	const patterns = [];
	for (const file of gitignoreFiles) {
		const dir = path.dirname(file);
		const localPatterns = await readGitignoreFile(dir);
		const relDir = path.relative(cwd, dir) || ".";
		for (const p of localPatterns) patterns.push(relDir === "." ? p : `${relDir}/${p}`);
	}
	return patterns;
}

//#endregion
//#region src/helpers/instance-of-node-error.ts
/**
* A typeguarded version of `instanceof Error` for NodeJS.
* @param value The value to check.
* @param errorType The error type to check against.
*
* @returns True if the value is an instance of the given error type and has NodeJS-specific error properties.
*
* @example
*
* ```ts
* try {
*   // ...
* } catch (error) {
*   if (instanceOfNodeError(error, TypeError)) {
*     console.error(error.code);
*   }
* }
* ```
*/
function instanceOfNodeError(value, errorType) {
	if (!(value instanceof errorType)) return false;
	const candidate = value;
	return typeof candidate.code === "string" || typeof candidate.code === "number" || typeof candidate.errno === "number";
}

//#endregion
//#region src/helpers/load-config.ts
/**
* Load patterns from .vuotoignore file.
* @param cwd Current working directory.
* @returns Array of ignore patterns.
* @example
* ```ts
* const patterns = await loadVuotoIgnore(process.cwd());
* console.log(patterns); // ['dist/**', 'build/**']
* ```
*/
async function loadVuotoIgnore(cwd) {
	const vuotoignorePath = path.join(cwd, VUOTO_IGNORE_FILENAME);
	try {
		return (await fs.readFile(vuotoignorePath, "utf8")).split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
	} catch {
		return [];
	}
}

//#endregion
//#region src/helpers/resolve-config.ts
/**
* Merge built-in ignores with user .vuotoignore patterns.
* @param cwd Current working directory.
* @returns Combined ignore patterns.
* @example
* ```ts
* const patterns = await resolveIgnores(process.cwd());
* console.log(patterns); // [...DEFAULT_IGNORES, ...userPatterns]
* ```
*/
async function resolveIgnores(cwd) {
	const userPatterns = await loadVuotoIgnore(cwd);
	return [...DEFAULT_IGNORES, ...userPatterns];
}

//#endregion
//#region src/normalizers/byte-order-mark.ts
/**
* Removes byte order mark (U+FEFF).
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeByteOrderMark('\uFEFFHello'); // 'Hello'
* ```
*/
function normalizeByteOrderMark(input) {
	return input.replaceAll(BYTE_ORDER_MARK, "");
}

//#endregion
//#region src/normalizers/em-space.ts
/**
* Replaces em space (U+2003) with a normal space.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeEmSpace('Hello\u2003World'); // 'Hello World'
* ```
*/
function normalizeEmSpace(input) {
	return input.replaceAll(EM_SPACE, " ");
}

//#endregion
//#region src/normalizers/en-space.ts
/**
* Replaces en space (U+2002) with a normal space.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeEnSpace('Hello\u2002World'); // 'Hello World'
* ```
*/
function normalizeEnSpace(input) {
	return input.replaceAll(EN_SPACE, " ");
}

//#endregion
//#region src/normalizers/form-feed.ts
/**
* Replaces form feed (U+000C) with a newline.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeFormFeed('Hello\fWorld'); // 'Hello\nWorld'
* ```
*/
function normalizeFormFeed(input) {
	return input.replaceAll(FORM_FEED, "\n");
}

//#endregion
//#region src/normalizers/ideographic-space.ts
/**
* Replaces ideographic space (U+3000) with a normal space.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeIdeographicSpace('Hello\u3000World'); // 'Hello World'
* ```
*/
function normalizeIdeographicSpace(input) {
	return input.replaceAll(IDEOGRAPHIC_SPACE, " ");
}

//#endregion
//#region src/normalizers/invisible-separators.ts
/**
* Removes invisible separators.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeInvisibleSeparators('Hello\u2063World'); // 'HelloWorld'
* ```
*/
function normalizeInvisibleSeparators(input) {
	return input.replaceAll(INVISIBLE_SEPARATORS, "");
}

//#endregion
//#region src/normalizers/line-separator.ts
/**
* Replaces line separator (U+2028) with a newline.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeLineSeparator('Hello\u2028World'); // 'Hello\nWorld'
* ```
*/
function normalizeLineSeparator(input) {
	return input.replaceAll(LINE_SEPARATOR, "\n");
}

//#endregion
//#region src/normalizers/narrow-no-break-space.ts
/**
* Replaces narrow no-break space (U+202F) with a normal space.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeNarrowNoBreakSpace('Hello\u202FWorld'); // 'Hello World'
* ```
*/
function normalizeNarrowNoBreakSpace(input) {
	return input.replaceAll(NARROW_NO_BREAK_SPACE, " ");
}

//#endregion
//#region src/normalizers/non-breaking-space.ts
/**
* Replaces non-breaking space (U+00A0) with a normal space.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeNonBreakingSpace('Hello\u00A0World'); // 'Hello World'
* ```
*/
function normalizeNonBreakingSpace(input) {
	return input.replaceAll(NON_BREAKING_SPACE, " ");
}

//#endregion
//#region src/normalizers/paragraph-separator.ts
/**
* Replaces paragraph separator (U+2029) with a double newline.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeParagraphSeparator('Hello\u2029World'); // 'Hello\n\nWorld'
* ```
*/
function normalizeParagraphSeparator(input) {
	return input.replaceAll(PARAGRAPH_SEPARATOR, "\n\n");
}

//#endregion
//#region src/normalizers/vertical-tab.ts
/**
* Replaces vertical tab with a newline.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeVerticalTab('Hello\vWorld'); // 'Hello\nWorld'
* ```
*/
function normalizeVerticalTab(input) {
	return input.replaceAll(VERTICAL_TAB, "\n");
}

//#endregion
//#region src/normalizers/visible-misc-spaces.ts
/**
* Replaces various visible miscellaneous spaces with normal spaces.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeVisibleMiscSpaces('Hello\u2004World'); // 'Hello World'
* ```
*/
function normalizeVisibleMiscSpaces(input) {
	return input.replaceAll(VISIBLE_MISC_SPACES, " ");
}

//#endregion
//#region src/normalizers/zero-width.ts
/**
* Removes zero-width and invisible characters.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalizeZeroWidth('Hello\u200BWorld'); // 'HelloWorld'
* ```
*/
function normalizeZeroWidth(input) {
	return input.replaceAll(ZERO_WIDTH, "");
}

//#endregion
//#region src/normalize.ts
/**
* Applies all whitespace normalizations in sequence.
* @param input The string to normalize.
*
* @returns The normalized string.
*
* @example
*
* ```ts
* const normalized = normalize('Hello\u200BWorld'); // 'HelloWorld'
* ```
*/
function normalize(input) {
	let output = input;
	output = normalizeZeroWidth(output);
	output = normalizeByteOrderMark(output);
	output = normalizeInvisibleSeparators(output);
	output = normalizeNonBreakingSpace(output);
	output = normalizeNarrowNoBreakSpace(output);
	output = normalizeLineSeparator(output);
	output = normalizeParagraphSeparator(output);
	output = normalizeEmSpace(output);
	output = normalizeEnSpace(output);
	output = normalizeIdeographicSpace(output);
	output = normalizeVisibleMiscSpaces(output);
	output = normalizeFormFeed(output);
	output = normalizeVerticalTab(output);
	return output;
}

//#endregion
//#region src/actions/run-normalize.ts
/**
* Main logic: load .vuotoignore, collect files, run normalize with enhanced output.
* @param options The options for running the normalization.
* @example
* await runNormalize({ patterns: ['*.ts'] });
*/
async function runNormalize(options) {
	const { silent = false, verbose = false } = options;
	if (verbose && !silent) console.log(chalk.dim("Loading .vuotoignore patterns..."));
	const ignore = [...await resolveIgnores(process.cwd()), ...options.exclude ?? []];
	if (verbose && !silent) {
		console.log(chalk.dim(`Scanning patterns: ${options.patterns.join(", ")}`));
		console.log(chalk.dim(`Ignoring ${ignore.length} patterns`));
	}
	const files = await fg(options.patterns, {
		cwd: process.cwd(),
		absolute: true,
		ignore,
		dot: true,
		onlyFiles: true
	});
	if (files.length === 0) {
		if (!silent) console.error(chalk.yellow("⚠"), "No files matched the given patterns");
		process.exitCode = 1;
		return;
	}
	if (verbose && !silent) console.log(chalk.dim(`Found ${files.length} file(s) to process\n`));
	let hadIssues = false;
	let fixedCount = 0;
	let checkedCount = 0;
	for (const file of files) {
		const relPath = path.relative(process.cwd(), file);
		const source = await fs.readFile(file, "utf8");
		const fixed = normalize(source);
		if (options.fix) {
			if (source !== fixed) {
				await fs.writeFile(file, fixed, "utf8");
				fixedCount++;
				if (!silent) console.log(chalk.greenBright("✓"), chalk.dim("fixed"), chalk.cyanBright(relPath));
			} else if (verbose && !silent) console.log(chalk.dim("·"), chalk.dim("clean"), chalk.dim(relPath));
		} else {
			checkedCount++;
			if (source !== fixed) {
				hadIssues = true;
				if (!silent) console.log(chalk.redBright("✗"), chalk.dim("issues"), chalk.yellowBright(relPath));
			} else if (verbose && !silent) console.log(chalk.dim("·"), chalk.dim("clean"), chalk.dim(relPath));
		}
	}
	if (!silent) {
		console.log();
		if (options.fix) if (fixedCount > 0) console.log(chalk.greenBright.bold("✨ Success:"), `Fixed ${chalk.bold(fixedCount)} file(s)`);
		else console.log(chalk.greenBright.bold("✨ Success:"), `All ${chalk.bold(files.length)} file(s) are already clean!`);
		else if (hadIssues) console.log(chalk.redBright.bold("✗ Issues:"), `Found whitespace issues in ${chalk.bold(files.length - checkedCount)} file(s)`, chalk.dim("\n  (run with --fix to resolve)"));
		else console.log(chalk.greenBright.bold("✨ Success:"), `All ${chalk.bold(checkedCount)} file(s) are clean!`);
	}
	if (hadIssues && !options.fix) process.exitCode = 1;
}

//#endregion
export { loadVuotoIgnore as _, normalizeVerticalTab as a, readGitignoreFile as b, normalizeNarrowNoBreakSpace as c, normalizeIdeographicSpace as d, normalizeFormFeed as f, resolveIgnores as g, normalizeByteOrderMark as h, normalizeVisibleMiscSpaces as i, normalizeLineSeparator as l, normalizeEmSpace as m, normalize as n, normalizeParagraphSeparator as o, normalizeEnSpace as p, normalizeZeroWidth as r, normalizeNonBreakingSpace as s, runNormalize as t, normalizeInvisibleSeparators as u, instanceOfNodeError as v, expandPatterns as x, collectGitignores as y };