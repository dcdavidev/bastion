import { createRule } from "../createRule.mjs";
import sortPackageJson from "sort-package-json";

//#region src/rules/sort-collections.ts
const defaultCollections = new Set([
	"config",
	"dependencies",
	"devDependencies",
	"exports",
	"optionalDependencies",
	"overrides",
	"peerDependencies",
	"peerDependenciesMeta",
	"scripts"
]);
const rule = createRule({
	create(context) {
		const toSort = context.options[0] ? new Set(context.options[0]) : defaultCollections;
		return { "JSONProperty:exit"(node) {
			const { key: nodeKey, value: collection } = node;
			if (nodeKey.type !== "JSONLiteral" || collection.type !== "JSONObjectExpression") return;
			const keyPartsReversed = [nodeKey.value];
			for (let currNode = node.parent; currNode; currNode = currNode.parent) if (currNode.type === "JSONProperty" && currNode.key.type === "JSONLiteral") keyPartsReversed.push(currNode.key.value);
			else if (currNode.type === "JSONArrayExpression") return;
			const key = keyPartsReversed.reverse().join(".");
			if (!toSort.has(key)) return;
			const currentOrder = collection.properties;
			let desiredOrder;
			if (keyPartsReversed.at(-1) === "scripts") {
				const scriptsSource = context.sourceCode.getText(node);
				const { scripts: sortedScripts } = sortPackageJson(JSON.parse(`{${scriptsSource}}`));
				const propertyNodeMap = Object.fromEntries(collection.properties.map((prop) => [prop.key.value, prop]));
				desiredOrder = Object.keys(sortedScripts).map((prop) => propertyNodeMap[prop]);
			} else desiredOrder = currentOrder.toSorted((a, b) => {
				return a.key.value > b.key.value ? 1 : -1;
			});
			if (currentOrder.some((property, i) => desiredOrder[i] !== property)) context.report({
				data: { key },
				fix(fixer) {
					return fixer.replaceText(collection, JSON.stringify(desiredOrder.reduce((out, property) => {
						out[property.key.value] = JSON.parse(context.sourceCode.getText(property.value));
						return out;
					}, {}), null, 2).split("\n").join("\n  "));
				},
				loc: collection.loc,
				messageId: keyPartsReversed.at(-1) === "scripts" ? "unsortedScripts" : "unsortedKeys",
				node
			});
		} };
	},
	meta: {
		defaultOptions: [Array.from(defaultCollections)],
		docs: {
			category: "Best Practices",
			description: "Selected collections must be in a consistent order (lexicographical for most; lifecycle-aware for scripts).",
			recommended: true
		},
		fixable: "code",
		messages: {
			unsortedKeys: "Entries in '{{ key }}' are not in lexicographical order",
			unsortedScripts: "Entries in 'scripts' are not in lexicographical order and grouped by lifecycles"
		},
		schema: [{
			description: "Array of package properties to require sorting.",
			items: { type: "string" },
			type: "array"
		}],
		type: "layout"
	},
	name: "sort-collections"
});

//#endregion
export { rule };