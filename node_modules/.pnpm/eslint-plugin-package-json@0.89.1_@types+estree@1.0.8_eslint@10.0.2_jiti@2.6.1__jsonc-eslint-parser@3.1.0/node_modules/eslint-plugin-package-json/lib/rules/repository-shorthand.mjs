import { createRule } from "../createRule.mjs";
import { isJSONStringLiteral } from "../utils/predicates.mjs";
import { findPropertyWithKeyValue } from "../utils/findPropertyWithKeyValue.mjs";

//#region src/rules/repository-shorthand.ts
const providerRegexes = {
	bitbucket: /^(?:git\+)?(?:ssh:\/\/git@|http?s:\/\/)?(?:www\.)?bitbucket\.org\//,
	gist: /^(?:git\+)?(?:ssh:\/\/git@|http?s:\/\/)?(?:www\.)?gist\.github\.com\//,
	github: /^(?:git\+)?(?:ssh:\/\/git@|http?s:\/\/)?(?:www\.)?github\.com\//,
	gitlab: /^(?:git\+)?(?:ssh:\/\/git@|http?s:\/\/)?(?:www\.)?gitlab\.com\//
};
const providerUrls = {
	bitbucket: "https://bitbucket.org/",
	gist: "https://gist.github.com/",
	github: "https://github.com/",
	gitlab: "https://gitlab.com/"
};
const providers = Object.keys(providerRegexes);
const isProvider = (value) => value in providerRegexes;
const cleanUrl = (url, provider) => url.replace(providerRegexes[provider], "").replace(/\.git$/, "");
const getProviderFromUrl = (url) => {
	return providers.find((provider) => providerRegexes[provider].test(url));
};
const createShorthand = (url, provider) => {
	return `${provider}:${cleanUrl(url, provider)}`;
};
const createUrl = (shorthand) => {
	if (shorthand.includes(":")) {
		const [provider, repo] = shorthand.split(":");
		if (isProvider(provider)) return `${providerUrls[provider]}${repo}`;
	}
	return `${providerUrls.github}${shorthand}`;
};
const rule = createRule({
	create(context) {
		const [{ form = "object" } = {}] = context.options;
		function validateRepositoryForObject(node) {
			if (isJSONStringLiteral(node.value)) context.report({
				fix(fixer) {
					if (!isJSONStringLiteral(node.value) || node.value.value.split("/").filter(Boolean).length !== 2) return null;
					return fixer.replaceText(node.value, JSON.stringify({
						type: "git",
						url: createUrl(node.value.value)
					}, null, 2));
				},
				messageId: "preferObject",
				node: node.value
			});
		}
		function validateRepositoryForShorthand(node) {
			if (isJSONStringLiteral(node.value)) {
				const { value } = node.value;
				const provider = getProviderFromUrl(value);
				if (provider) context.report({
					fix(fixer) {
						return fixer.replaceText(node.value, JSON.stringify(createShorthand(value, provider)));
					},
					messageId: "preferShorthand",
					node: node.value
				});
				return;
			}
			if (node.value.type !== "JSONObjectExpression") return;
			const { properties } = node.value;
			if (findPropertyWithKeyValue(properties, "directory")) return;
			const typeProperty = findPropertyWithKeyValue(properties, "type");
			if (typeProperty?.value.type !== "JSONLiteral" || typeProperty.value.value !== "git") return;
			const urlProperty = findPropertyWithKeyValue(properties, "url");
			if (urlProperty?.value.type !== "JSONLiteral" || typeof urlProperty.value.value !== "string") return;
			const url = urlProperty.value.value;
			const provider = getProviderFromUrl(url);
			if (provider) context.report({
				fix(fixer) {
					return fixer.replaceText(node.value, JSON.stringify(createShorthand(url, provider)));
				},
				messageId: "preferShorthand",
				node: node.value
			});
		}
		return { JSONProperty(node) {
			if (node.key.type !== "JSONLiteral" || node.key.value !== "repository" || node.parent.parent.parent.type !== "Program") return;
			if (form === "shorthand") validateRepositoryForShorthand(node);
			else validateRepositoryForObject(node);
		} };
	},
	meta: {
		defaultOptions: [{ form: "object" }],
		docs: {
			category: "Best Practices",
			description: "Enforce either object or shorthand declaration for repository.",
			recommended: true
		},
		fixable: "code",
		messages: {
			preferObject: "Prefer an object locator for a repository.",
			preferShorthand: "Prefer a shorthand locator for a supported repository provider."
		},
		schema: [{
			additionalProperties: false,
			properties: { form: {
				description: "Specifies which repository form to enforce.",
				enum: ["object", "shorthand"],
				type: ["string"]
			} },
			type: "object"
		}],
		type: "suggestion"
	},
	name: "repository-shorthand"
});

//#endregion
export { rule };