import { createRule } from "../createRule.mjs";
import { isJSONStringLiteral } from "../utils/predicates.mjs";
import semver from "semver";

//#region src/rules/restrict-dependency-ranges.ts
const DEPENDENCY_TYPES = [
	"dependencies",
	"devDependencies",
	"optionalDependencies",
	"peerDependencies"
];
const RANGE_TYPES = [
	"caret",
	"pin",
	"tilde"
];
const schemaOptions = {
	additionalProperties: false,
	properties: {
		forDependencyTypes: {
			description: "Apply a range type restriction for an entire group of dependencies by which type of dependencies they belong to.",
			items: { enum: DEPENDENCY_TYPES },
			type: "array"
		},
		forPackages: {
			description: "The exact name of a package, or a regex pattern used to match a group of packages by name.",
			items: { type: "string" },
			type: "array"
		},
		forVersions: {
			description: "Apply a restriction to a specific semver range.",
			type: "string"
		},
		rangeType: {
			description: "Identifies which range type or types you want to apply to packages that match any of the other match options (or all dependencies if no other options are provided).",
			oneOf: [{ enum: RANGE_TYPES }, {
				items: { enum: RANGE_TYPES },
				type: "array"
			}]
		}
	},
	required: ["rangeType"],
	type: "object"
};
const SYMBOLS = {
	caret: "^",
	pin: "",
	tilde: "~"
};
/**
* Given the original version, update it to use the correct range type.
*/
const changeVersionRange = (version, rangeType) => {
	if (/^workspace:[~^*]$/.test(version)) switch (rangeType) {
		case "caret": return "workspace:^";
		case "pin": return "workspace:*";
		default: return "workspace:~";
	}
	return version.replace(/^(workspace:)?(\^|~|<=?|>=?)?/, `$1${SYMBOLS[rangeType]}`);
};
/**
* Check if the version is in a form that this rule supports.
*/
const isVersionSupported = (version) => {
	if (/^workspace:[*^~]$/.test(version)) return true;
	const rawVersion = version.replace(/^workspace:/, "");
	return !!semver.validRange(rawVersion);
};
const capitalize = (str) => {
	return str.charAt(0).toUpperCase() + str.slice(1);
};
const rule = createRule({
	create(context) {
		if (!context.options[0]) return {};
		const optionsArray = (Array.isArray(context.options[0]) ? context.options[0].toReversed() : [context.options[0]]).map((option) => ({
			...option,
			forPackages: option.forPackages?.map((pattern) => new RegExp(pattern)),
			rangeTypes: Array.isArray(option.rangeType) ? option.rangeType : [option.rangeType]
		}));
		return { "Program > JSONExpressionStatement > JSONObjectExpression > JSONProperty[key.type=JSONLiteral][value.type=JSONObjectExpression]"(node) {
			const dependencyType = node.key.value;
			if (!DEPENDENCY_TYPES.includes(dependencyType)) return;
			for (const property of node.value.properties) {
				if (!isJSONStringLiteral(property.key) || !isJSONStringLiteral(property.value)) continue;
				const name = property.key.value;
				const version = property.value.value;
				if (!isVersionSupported(version)) continue;
				const isPinned = !!semver.parse(version) || version === "workspace:*";
				const isTildeRange = !!semver.validRange(version) && version.startsWith("~") || version.startsWith("workspace:~");
				const isCaretRange = !!semver.validRange(version) && version.startsWith("^") || version.startsWith("workspace:^");
				for (const options of optionsArray) {
					if (options.forDependencyTypes && !options.forDependencyTypes.includes(dependencyType)) continue;
					if (options.forPackages) {
						if (!options.forPackages.some((packageNameRegex) => packageNameRegex.test(name))) continue;
					}
					if (options.forVersions && (/^workspace:[^~*]?$/.test(version) || version !== "*" && !semver.satisfies(version.replace(/(?:workspace:)?[^~]?/, ""), options.forVersions))) continue;
					const rangeTypes = options.rangeTypes;
					if (version === "*") {
						context.report({
							data: { rangeTypes: rangeTypes.join(", ") },
							messageId: "wrongRangeType",
							node: property.value
						});
						break;
					}
					if (!rangeTypes.find((rangeType) => {
						switch (rangeType) {
							case "caret": return isCaretRange;
							case "pin": return isPinned;
							case "tilde": return isTildeRange;
						}
					})) context.report({
						data: { rangeTypes: rangeTypes.join(", ") },
						messageId: "wrongRangeType",
						node: property.value,
						suggest: rangeTypes.map((rangeType) => ({
							fix(fixer) {
								return fixer.replaceText(property.value, `"${changeVersionRange(version, rangeType)}"`);
							},
							messageId: `changeTo${capitalize(rangeType)}`
						}))
					});
					break;
				}
			}
		} };
	},
	meta: {
		defaultOptions: [[]],
		docs: { description: "Restricts the range of dependencies to allow or disallow specific types of ranges." },
		hasSuggestions: true,
		messages: {
			changeToCaret: "Change to use a caret range.",
			changeToPin: "Pin the version.",
			changeToTilde: "Change to use a tilde range.",
			wrongRangeType: "This dependency is using the wrong range type.  Acceptable range type(s): {{rangeTypes}}"
		},
		schema: [{ oneOf: [schemaOptions, {
			description: "Array of configuration options, specifying range requirements.",
			items: schemaOptions,
			type: "array"
		}] }],
		type: "suggestion"
	},
	name: "restrict-dependency-ranges"
});

//#endregion
export { rule };