import { createRule } from "../createRule.mjs";
import { isJSONStringLiteral, isNotNullish } from "../utils/predicates.mjs";
import { fixRemoveArrayElement, fixRemoveObjectProperty } from "eslint-fix-utils";

//#region src/rules/unique-dependencies.ts
const dependencyPropertyNames = new Set([
	"bundledDependencies",
	"bundleDependencies",
	"dependencies",
	"devDependencies",
	"optionalDependencies",
	"overrides",
	"peerDependencies"
]);
const rule = createRule({
	create(context) {
		const dependenciesCache = {
			dependencies: [],
			devDependencies: [],
			peerDependencies: []
		};
		const trackForCrossGroupUniqueness = Object.keys(dependenciesCache);
		function check(elements, getNodeToRemove) {
			const seen = /* @__PURE__ */ new Set();
			for (const element of elements.filter(isNotNullish).filter(isJSONStringLiteral).reverse()) if (seen.has(element.value)) report(element);
			else seen.add(element.value);
			function report(node) {
				const removal = getNodeToRemove(node);
				context.report({
					messageId: "overridden",
					node,
					suggest: [{
						fix: removal.type === "JSONProperty" ? fixRemoveObjectProperty(context, removal) : fixRemoveArrayElement(context, removal, elements),
						messageId: "remove"
					}]
				});
			}
		}
		return {
			"Program > JSONExpressionStatement > JSONObjectExpression > JSONProperty[key.type=JSONLiteral]"(node) {
				if (!dependencyPropertyNames.has(node.key.value)) return;
				const nodeValueType = node.value.type;
				if (nodeValueType === "JSONArrayExpression") check(node.value.elements, (element) => element);
				if (nodeValueType === "JSONObjectExpression") {
					check(node.value.properties.map((property) => property.key), (property) => property.parent);
					if (trackForCrossGroupUniqueness.includes(node.key.value)) dependenciesCache[node.key.value] = node.value.properties;
				}
			},
			"Program:exit"() {
				const dependencyNames = new Set(dependenciesCache.dependencies.map((node) => node.key).filter(isJSONStringLiteral).map((dependencyNameNode) => dependencyNameNode.value));
				if (!dependencyNames.size) return;
				for (const dependencyType of ["devDependencies", "peerDependencies"]) {
					const otherDependencies = dependenciesCache[dependencyType];
					for (const otherDependencyNode of otherDependencies) {
						const otherDependencyKey = otherDependencyNode.key;
						if (isJSONStringLiteral(otherDependencyKey) && dependencyNames.has(otherDependencyKey.value)) context.report({
							messageId: "crossGroupDuplicate",
							node: otherDependencyNode,
							suggest: [{
								fix: fixRemoveObjectProperty(context, otherDependencyNode),
								messageId: "remove"
							}]
						});
					}
				}
			}
		};
	},
	meta: {
		docs: {
			category: "Best Practices",
			description: "Checks a dependency isn't specified more than once (i.e. in `dependencies` and `devDependencies`)",
			recommended: true
		},
		hasSuggestions: true,
		messages: {
			crossGroupDuplicate: "Dependency is also declared in \"dependencies\" and is redundant",
			overridden: "Dependency is overridden by a duplicate entry later on",
			remove: "Remove this redundant dependency"
		},
		schema: [],
		type: "suggestion"
	},
	name: "unique-dependencies"
});

//#endregion
export { rule };