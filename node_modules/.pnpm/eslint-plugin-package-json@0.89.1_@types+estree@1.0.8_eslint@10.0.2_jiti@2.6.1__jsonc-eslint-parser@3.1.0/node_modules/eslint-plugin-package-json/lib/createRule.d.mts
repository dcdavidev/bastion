import { Expression, ExpressionStatement } from "./node_modules/.pnpm/@types_estree@1.0.8/node_modules/@types/estree/index.mjs";
import { JSONSchema } from "./node_modules/.pnpm/json-schema-to-ts@3.1.1/node_modules/json-schema-to-ts/lib/types/definitions/jsonSchema.mjs";
import { FromSchema } from "./node_modules/.pnpm/json-schema-to-ts@3.1.1/node_modules/json-schema-to-ts/lib/types/index.mjs";
import { AST, RuleListener } from "jsonc-eslint-parser";
import { AST as AST$1, Rule, SourceCode } from "eslint";

//#region src/createRule.d.ts
type JsonAstBodyExpression = Expression & {
  properties: JsonAstBodyProperty[];
};
type JsonAstBodyProperty = AST.JSONProperty & {
  value: string;
};
interface JsonAstBodyStatement extends ExpressionStatement {
  expression: JsonAstBodyExpression;
}
interface PackageJsonAst extends AST$1.Program {
  body: [JsonAstBodyStatement];
}
interface PackageJsonPluginSettings {
  /**
   * Whether `require-*` rules, if used, should enforce the presence of
   * the corresponding property *in package.json files with `"private": true`*.
   *
   * If not specified, it will not enforce the presence only of `name` and `version` properties.
   */
  enforceForPrivate?: boolean;
}
interface PackageJsonRuleContext<Options extends unknown[] = unknown[]> extends Rule.RuleContext {
  options: Options;
  settings: {
    packageJson?: PackageJsonPluginSettings;
  };
  sourceCode: PackageJsonSourceCode;
}
interface PackageJsonRuleModule<Options extends unknown[] = unknown[], Schema extends JSONSchema[] = JSONSchema[]> {
  create(context: PackageJsonRuleContext<Options>): RuleListener;
  meta: Omit<Rule.RuleMetaData, "defaultOptions" | "docs" | "schema"> & {
    defaultOptions?: NoInfer<Options>;
    docs?: Rule.RuleMetaData["docs"] & {
      category?: string;
    };
    schema?: Schema;
  };
}
interface PackageJsonSourceCode extends SourceCode {
  ast: PackageJsonAst;
}
type InferJsonSchemasTupleType<T extends JSONSchema[]> = { [K in keyof T]?: FromSchema<T[K]> };
/**
 * Rule options type is inferred from the JSON schema by [json-schema-to-ts](https://www.npmjs.com/package/json-schema-to-ts).
 * If you're not satisfied with the inferred type, you may specify it manually in the first type parameter.
 */
declare function createRule<OptionsOverride extends unknown[] = never, const Schema extends JSONSchema[] = JSONSchema[], _OptionsResolved extends unknown[] = ([OptionsOverride] extends [never] ? InferJsonSchemasTupleType<Schema> : OptionsOverride)>(rule: PackageJsonRuleModule<_OptionsResolved, Schema> & {
  name: string;
}): PackageJsonRuleModule<_OptionsResolved, Schema>;
//#endregion
export { JsonAstBodyExpression, JsonAstBodyProperty, JsonAstBodyStatement, PackageJsonAst, PackageJsonPluginSettings, PackageJsonRuleContext, PackageJsonRuleModule, PackageJsonSourceCode, createRule };