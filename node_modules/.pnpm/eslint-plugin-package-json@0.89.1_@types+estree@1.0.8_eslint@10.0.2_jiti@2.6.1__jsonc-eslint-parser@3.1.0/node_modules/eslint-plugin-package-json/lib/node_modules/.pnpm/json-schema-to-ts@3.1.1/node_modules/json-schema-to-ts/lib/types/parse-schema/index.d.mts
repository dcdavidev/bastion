import { Never } from "../../../../../../ts-algebra@2.0.0/node_modules/ts-algebra/lib/meta-types/never.mjs";
import { Any } from "../../../../../../ts-algebra@2.0.0/node_modules/ts-algebra/lib/meta-types/any.mjs";
import { $Intersect } from "../../../../../../ts-algebra@2.0.0/node_modules/ts-algebra/lib/meta-types/intersection/index.mjs";
import { DeserializationPattern } from "../definitions/deserializationPattern.mjs";
import { JSONSchema } from "../definitions/jsonSchema.mjs";
import { And } from "../type-utils/and.mjs";
import { DoesExtend } from "../type-utils/extends.mjs";
import { AllOfSchema, ParseAllOfSchema } from "./allOf.mjs";
import { AnyOfSchema, ParseAnyOfSchema } from "./anyOf.mjs";
import { ConstSchema, ParseConstSchema } from "./const.mjs";
import { DeserializeSchema } from "./deserialize.mjs";
import { EnumSchema, ParseEnumSchema } from "./enum.mjs";
import { IfThenElseSchema, ParseIfThenElseSchema } from "./ifThenElse.mjs";
import { MultipleTypesSchema, ParseMultipleTypesSchema } from "./multipleTypes.mjs";
import { NotSchema, ParseNotSchema } from "./not.mjs";
import { NullableSchema, ParseNullableSchema } from "./nullable.mjs";
import { OneOfSchema, ParseOneOfSchema } from "./oneOf.mjs";
import { ParseReferenceSchema, ReferencingSchema } from "./references/index.mjs";
import { ParseSingleTypeSchema, SingleTypeSchema } from "./singleType.mjs";

//#region node_modules/.pnpm/json-schema-to-ts@3.1.1/node_modules/json-schema-to-ts/lib/types/parse-schema/index.d.ts
type ParseSchemaOptions = {
  parseNotKeyword: boolean;
  parseIfThenElseKeywords: boolean;
  keepDefaultedPropertiesOptional: boolean;
  rootSchema: JSONSchema;
  references: Record<string, JSONSchema>;
  deserialize: DeserializationPattern[] | false;
};
type ParseSchema<SCHEMA extends JSONSchema, OPTIONS extends ParseSchemaOptions, RESULT = (JSONSchema extends SCHEMA ? Any : SCHEMA extends true | string ? Any : SCHEMA extends false ? Never : SCHEMA extends NullableSchema ? ParseNullableSchema<SCHEMA, OPTIONS> : SCHEMA extends ReferencingSchema ? ParseReferenceSchema<SCHEMA, OPTIONS> : And<DoesExtend<OPTIONS["parseIfThenElseKeywords"], true>, DoesExtend<SCHEMA, IfThenElseSchema>> extends true ? SCHEMA extends IfThenElseSchema ? ParseIfThenElseSchema<SCHEMA, OPTIONS> : never : And<DoesExtend<OPTIONS["parseNotKeyword"], true>, DoesExtend<SCHEMA, NotSchema>> extends true ? SCHEMA extends NotSchema ? ParseNotSchema<SCHEMA, OPTIONS> : never : SCHEMA extends AllOfSchema ? ParseAllOfSchema<SCHEMA, OPTIONS> : SCHEMA extends OneOfSchema ? ParseOneOfSchema<SCHEMA, OPTIONS> : SCHEMA extends AnyOfSchema ? ParseAnyOfSchema<SCHEMA, OPTIONS> : SCHEMA extends EnumSchema ? ParseEnumSchema<SCHEMA, OPTIONS> : SCHEMA extends ConstSchema ? ParseConstSchema<SCHEMA, OPTIONS> : SCHEMA extends MultipleTypesSchema ? ParseMultipleTypesSchema<SCHEMA, OPTIONS> : SCHEMA extends SingleTypeSchema ? ParseSingleTypeSchema<SCHEMA, OPTIONS> : Any)> = OPTIONS extends {
  deserialize: DeserializationPattern[];
} ? $Intersect<DeserializeSchema<SCHEMA, OPTIONS>, RESULT> : RESULT;
//#endregion
export { ParseSchema, ParseSchemaOptions };