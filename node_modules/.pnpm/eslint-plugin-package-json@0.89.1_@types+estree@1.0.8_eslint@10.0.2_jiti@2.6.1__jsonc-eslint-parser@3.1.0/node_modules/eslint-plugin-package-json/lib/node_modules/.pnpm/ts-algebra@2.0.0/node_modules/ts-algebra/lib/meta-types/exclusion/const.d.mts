import { IsObject } from "../../utils/extends.mjs";
import { If } from "../../utils/if.mjs";
import { IsNever } from "../../utils/isNever.mjs";
import { Never, NeverType } from "../never.mjs";
import { Const, ConstType, ConstValue } from "../const.mjs";
import { EnumType } from "../enum.mjs";
import { IsObjectOpen, ObjectOpenProps, ObjectRequiredKeys, ObjectType, ObjectValues } from "../object.mjs";
import { PrimitiveType } from "../primitive.mjs";
import { TupleType } from "../tuple.mjs";
import { UnionType } from "../union.mjs";
import { Type } from "../type.mjs";
import { ArrayType } from "../array.mjs";
import { Resolve } from "../resolve.mjs";
import { AnyType } from "../any.mjs";
import { ExcludeUnion } from "./union.mjs";
import { _Exclude } from "./index.mjs";

//#region node_modules/.pnpm/ts-algebra@2.0.0/node_modules/ts-algebra/lib/meta-types/exclusion/const.d.ts
declare type ExcludeFromConst<META_CONST extends ConstType, META_TYPE> = META_TYPE extends Type ? META_TYPE extends NeverType ? META_CONST : META_TYPE extends AnyType ? Never : META_TYPE extends ConstType ? CheckNotExtendsResolved<META_CONST, META_TYPE> : META_TYPE extends EnumType ? CheckNotExtendsResolved<META_CONST, META_TYPE> : META_TYPE extends PrimitiveType ? CheckNotExtendsResolved<META_CONST, META_TYPE> : META_TYPE extends ArrayType ? CheckNotExtendsResolved<META_CONST, META_TYPE> : META_TYPE extends TupleType ? CheckNotExtendsResolved<META_CONST, META_TYPE> : META_TYPE extends ObjectType ? ExcludeObject<META_CONST, META_TYPE> : META_TYPE extends UnionType ? ExcludeUnion<META_CONST, META_TYPE> : Never : Never;
declare type CheckNotExtendsResolved<META_CONST extends ConstType, META_TYPE extends Type> = ConstValue<META_CONST> extends Resolve<META_TYPE, {
  deserialize: false;
}> ? Never : META_CONST;
declare type ExcludeObject<META_CONST extends ConstType, META_OBJECT extends ObjectType> = If<IsObject<ConstValue<META_CONST>>, ObjectRequiredKeys<META_OBJECT> extends keyof ConstValue<META_CONST> ? ExcludeObjectFromConst<META_CONST, META_OBJECT> : META_CONST, META_CONST>;
declare type ExcludeObjectFromConst<META_CONST extends ConstType, META_OBJECT extends ObjectType, EXCLUDED_CONST_VALUES = ExcludeConstValues<ConstValue<META_CONST>, META_OBJECT>> = If<IsNever<RepresentableKeys<EXCLUDED_CONST_VALUES>>, Never, META_CONST>;
declare type ExcludeConstValues<VALUE, META_OBJECT extends ObjectType> = { [KEY in keyof VALUE]: KEY extends keyof ObjectValues<META_OBJECT> ? _Exclude<Const<VALUE[KEY]>, ObjectValues<META_OBJECT>[KEY]> : IsObjectOpen<META_OBJECT> extends true ? _Exclude<Const<VALUE[KEY]>, ObjectOpenProps<META_OBJECT>> : Const<VALUE[KEY]> };
declare type RepresentableKeys<VALUES> = { [KEY in keyof VALUES]: VALUES[KEY] extends Never ? never : KEY }[keyof VALUES];
//#endregion
export { ExcludeFromConst };