import { And } from "../utils/and.mjs";
import { DoesExtend } from "../utils/extends.mjs";
import { If } from "../utils/if.mjs";
import { Not } from "../utils/not.mjs";
import { Never, NeverType } from "./never.mjs";
import { Deserialized, IsSerialized } from "./utils.mjs";
import { Type } from "./type.mjs";
import { Resolve, ResolveOptions } from "./resolve.mjs";

//#region node_modules/.pnpm/ts-algebra@2.0.0/node_modules/ts-algebra/lib/meta-types/tuple.d.ts
declare type TupleTypeId = "tuple";
declare type Tuple<VALUES extends Type[], OPEN_PROPS extends Type = Never, IS_SERIALIZED extends boolean = false, DESERIALIZED = never> = $Tuple<VALUES, OPEN_PROPS, IS_SERIALIZED, DESERIALIZED>;
declare type $Tuple<VALUES, OPEN_PROPS = Never, IS_SERIALIZED = false, DESERIALIZED = never> = IsAnyValueNever<VALUES> extends true ? Never : {
  type: TupleTypeId;
  values: VALUES;
  isOpen: Not<DoesExtend<OPEN_PROPS, NeverType>>;
  openProps: OPEN_PROPS;
  isSerialized: IS_SERIALIZED;
  deserialized: DESERIALIZED;
};
declare type IsAnyValueNever<TUPLE> = TUPLE extends [infer TUPLE_HEAD, ...infer TUPLE_TAIL] ? TUPLE_HEAD extends NeverType ? true : IsAnyValueNever<TUPLE_TAIL> : false;
declare type TupleType = {
  type: TupleTypeId;
  values: Type[];
  isOpen: boolean;
  openProps: Type;
  isSerialized: boolean;
  deserialized: unknown;
};
declare type TupleValues<META_TUPLE extends TupleType> = META_TUPLE["values"];
declare type IsTupleOpen<META_TUPLE extends TupleType> = META_TUPLE["isOpen"];
declare type TupleOpenProps<META_TUPLE extends TupleType> = META_TUPLE["openProps"];
declare type ResolveTuple<META_TUPLE extends TupleType, OPTIONS extends ResolveOptions> = If<And<OPTIONS["deserialize"], IsSerialized<META_TUPLE>>, Deserialized<META_TUPLE>, If<IsTupleOpen<META_TUPLE>, [...RecurseOnTuple<TupleValues<META_TUPLE>, OPTIONS>, ...Resolve<TupleOpenProps<META_TUPLE>, OPTIONS>[]], RecurseOnTuple<TupleValues<META_TUPLE>, OPTIONS>>>;
declare type RecurseOnTuple<VALUES extends Type[], OPTIONS extends ResolveOptions, RESULT extends unknown[] = []> = VALUES extends [infer VALUES_HEAD, ...infer VALUES_TAIL] ? VALUES_HEAD extends Type ? VALUES_TAIL extends Type[] ? RecurseOnTuple<VALUES_TAIL, OPTIONS, [...RESULT, Resolve<VALUES_HEAD, OPTIONS>]> : never : never : RESULT;
//#endregion
export { $Tuple, IsTupleOpen, ResolveTuple, Tuple, TupleOpenProps, TupleType, TupleValues };